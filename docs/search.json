[
  {
    "objectID": "materiais/introducao.html",
    "href": "materiais/introducao.html",
    "title": "Sobre o Curso",
    "section": "",
    "text": "Este curso foi desenvolvido para quem deseja dar os primeiros passos no mundo da análise de dados usando R, uma das linguagens mais poderosas e populares para ciência de dados. Em 16 horas de conteúdo prático e objetivo, você aprenderá não apenas a programar em R, mas também a integrar ferramentas modernas que potencializam seu aprendizado e produtividade.\n\n\nEste curso foi pensado para ser acessível a todos, independentemente da sua experiência prévia com programação. Os únicos requisitos são:\n\nComputador com acesso à internet (Windows, Mac ou Linux)\nCuriosidade e vontade de aprender\nDisposição para praticar e experimentar\n\nNão é necessário conhecimento prévio em programação, estatística ou análise de dados. Se você nunca escreveu uma linha de código, não se preocupe! O curso foi estruturado pensando exatamente em você. Iniciaremos do zero, apresentando cada conceito de forma clara e progressiva.\n\n\n\nAo final deste curso, você será capaz de:\nFundamentos de R e Análise de Dados:\n\nCompreender a sintaxe básica da linguagem R e executar operações fundamentais\nImportar, manipular e transformar dados de diferentes fontes utilizando o tidyverse\nAplicar técnicas de limpeza e preparação de dados para análises robustas\nRealizar análises exploratórias e extrair insights relevantes de conjuntos de dados\n\nVisualização de Dados:\n\nCriar visualizações profissionais e informativas usando ggplot2\nEscolher o tipo adequado de gráfico para diferentes tipos de dados e mensagens\nPersonalizar cores, temas e elementos visuais para comunicar resultados com clareza\nProduzir gráficos prontos para apresentações, relatórios e publicações\n\nControle de Versão e Colaboração:\n\nUtilizar Git e GitHub para versionar e documentar seu código\nColaborar em projetos de dados de forma organizada e profissional\nCompreender fluxos de trabalho modernos em ciência de dados\nPublicar e compartilhar seus projetos com a comunidade\n\nAprendizado Assistido por IA:\n\nUtilizar ferramentas de IA (ChatGPT e Claude) como assistentes no aprendizado\nFormular perguntas eficazes para obter ajuda precisa na resolução de problemas\nInterpretar e adaptar sugestões de código geradas por IA\nAcelerar seu processo de aprendizagem combinando estudo tradicional e ferramentas modernas\n\n\n\n\nO curso adota uma abordagem prática e hands-on, onde você aprenderá fazendo. Nossa metodologia se baseia em três pilares fundamentais:\nAprendizagem Ativa:\nCada conceito apresentado é imediatamente seguido de exercícios práticos. Acreditamos que a melhor forma de aprender programação é escrevendo código. Você trabalhará com dados reais e enfrentará problemas autênticos desde o primeiro dia, construindo confiança e competência progressivamente.\nEstrutura Modular:\nO conteúdo está organizado em módulos que se constroem de forma lógica e incremental. Começamos com os fundamentos do R, avançamos para manipulação de dados com tidyverse, exploramos visualização com ggplot2, e integramos controle de versão e ferramentas de IA ao longo do caminho. Cada módulo é independente mas conectado, permitindo que você compreenda tanto os detalhes quanto o panorama geral.\nAprendizado Assistido por IA:\nUma das características mais inovadoras deste curso é o uso integrado de inteligência artificial como ferramenta pedagógica. Você aprenderá não apenas R, mas também como usar ChatGPT e Claude para tirar dúvidas, debugar código, explorar alternativas e acelerar seu aprendizado. Esta é uma habilidade essencial no cenário atual da programação e ciência de dados.\nProjetos Práticos:\nAo invés de exercícios isolados, você desenvolverá pequenos projetos que simulam situações reais de análise de dados. Isso inclui trabalhar com datasets públicos, criar visualizações para comunicar resultados, e documentar seu trabalho de forma profissional usando GitHub.\nSuporte e Comunidade:\nDurante todo o curso, você terá acesso a materiais de referência, exemplos comentados e uma comunidade de colegas aprendendo junto com você. Incentivamos a colaboração e a troca de experiências, pois aprendemos muito ao ensinar e compartilhar conhecimento.\nPrepare-se para uma jornada transformadora! Ao final destas 16 horas, você não apenas saberá programar em R, mas terá desenvolvido uma mentalidade analítica e as ferramentas necessárias para continuar evoluindo de forma autônoma. Seja bem-vindo ao fascinante mundo da análise de dados!"
  },
  {
    "objectID": "materiais/introducao.html#pré-requisitos",
    "href": "materiais/introducao.html#pré-requisitos",
    "title": "Sobre o Curso",
    "section": "",
    "text": "Este curso foi pensado para ser acessível a todos, independentemente da sua experiência prévia com programação. Os únicos requisitos são:\n\nComputador com acesso à internet (Windows, Mac ou Linux)\nCuriosidade e vontade de aprender\nDisposição para praticar e experimentar\n\nNão é necessário conhecimento prévio em programação, estatística ou análise de dados. Se você nunca escreveu uma linha de código, não se preocupe! O curso foi estruturado pensando exatamente em você. Iniciaremos do zero, apresentando cada conceito de forma clara e progressiva."
  },
  {
    "objectID": "materiais/introducao.html#objetivos-de-aprendizagem",
    "href": "materiais/introducao.html#objetivos-de-aprendizagem",
    "title": "Sobre o Curso",
    "section": "",
    "text": "Ao final deste curso, você será capaz de:\nFundamentos de R e Análise de Dados:\n\nCompreender a sintaxe básica da linguagem R e executar operações fundamentais\nImportar, manipular e transformar dados de diferentes fontes utilizando o tidyverse\nAplicar técnicas de limpeza e preparação de dados para análises robustas\nRealizar análises exploratórias e extrair insights relevantes de conjuntos de dados\n\nVisualização de Dados:\n\nCriar visualizações profissionais e informativas usando ggplot2\nEscolher o tipo adequado de gráfico para diferentes tipos de dados e mensagens\nPersonalizar cores, temas e elementos visuais para comunicar resultados com clareza\nProduzir gráficos prontos para apresentações, relatórios e publicações\n\nControle de Versão e Colaboração:\n\nUtilizar Git e GitHub para versionar e documentar seu código\nColaborar em projetos de dados de forma organizada e profissional\nCompreender fluxos de trabalho modernos em ciência de dados\nPublicar e compartilhar seus projetos com a comunidade\n\nAprendizado Assistido por IA:\n\nUtilizar ferramentas de IA (ChatGPT e Claude) como assistentes no aprendizado\nFormular perguntas eficazes para obter ajuda precisa na resolução de problemas\nInterpretar e adaptar sugestões de código geradas por IA\nAcelerar seu processo de aprendizagem combinando estudo tradicional e ferramentas modernas"
  },
  {
    "objectID": "materiais/introducao.html#metodologia",
    "href": "materiais/introducao.html#metodologia",
    "title": "Sobre o Curso",
    "section": "",
    "text": "O curso adota uma abordagem prática e hands-on, onde você aprenderá fazendo. Nossa metodologia se baseia em três pilares fundamentais:\nAprendizagem Ativa:\nCada conceito apresentado é imediatamente seguido de exercícios práticos. Acreditamos que a melhor forma de aprender programação é escrevendo código. Você trabalhará com dados reais e enfrentará problemas autênticos desde o primeiro dia, construindo confiança e competência progressivamente.\nEstrutura Modular:\nO conteúdo está organizado em módulos que se constroem de forma lógica e incremental. Começamos com os fundamentos do R, avançamos para manipulação de dados com tidyverse, exploramos visualização com ggplot2, e integramos controle de versão e ferramentas de IA ao longo do caminho. Cada módulo é independente mas conectado, permitindo que você compreenda tanto os detalhes quanto o panorama geral.\nAprendizado Assistido por IA:\nUma das características mais inovadoras deste curso é o uso integrado de inteligência artificial como ferramenta pedagógica. Você aprenderá não apenas R, mas também como usar ChatGPT e Claude para tirar dúvidas, debugar código, explorar alternativas e acelerar seu aprendizado. Esta é uma habilidade essencial no cenário atual da programação e ciência de dados.\nProjetos Práticos:\nAo invés de exercícios isolados, você desenvolverá pequenos projetos que simulam situações reais de análise de dados. Isso inclui trabalhar com datasets públicos, criar visualizações para comunicar resultados, e documentar seu trabalho de forma profissional usando GitHub.\nSuporte e Comunidade:\nDurante todo o curso, você terá acesso a materiais de referência, exemplos comentados e uma comunidade de colegas aprendendo junto com você. Incentivamos a colaboração e a troca de experiências, pois aprendemos muito ao ensinar e compartilhar conhecimento.\nPrepare-se para uma jornada transformadora! Ao final destas 16 horas, você não apenas saberá programar em R, mas terá desenvolvido uma mentalidade analítica e as ferramentas necessárias para continuar evoluindo de forma autônoma. Seja bem-vindo ao fascinante mundo da análise de dados!"
  },
  {
    "objectID": "materiais/dia1_fundamentos.html",
    "href": "materiais/dia1_fundamentos.html",
    "title": "Dia 1",
    "section": "",
    "text": "Tempo previsto 19h00–22h00 (intervalo 20h30–20h50)\n\n\n\n\n\nOlá! Seja muito bem-vindo ao Curso Intensivo de R com GitHub e IA. Esta jornada de 16 horas foi cuidadosamente estruturada para transformar você de iniciante a alguém capaz de realizar análises de dados completas usando ferramentas modernas e profissionais.\n\n\n\nAo final deste curso, você será capaz de:\n\nProgramar em R com confiança, desde operações básicas até análises complexas\nManipular e transformar dados usando o ecossistema tidyverse\nCriar visualizações profissionais e informativas com ggplot2\nVersionar seu código com Git e colaborar via GitHub\nUsar inteligência artificial (ChatGPT e Claude) para acelerar seu aprendizado e resolver problemas\n\n\n\n\nNossa abordagem é 100% prática e hands-on:\n\nTeoria mínima necessária seguida de prática imediata\nDatasets reais desde o primeiro dia\nCommits diários no seu fork do repositório\nIA como assistente para explicação, depuração e geração de código\nMultiplataforma: todo conteúdo funciona em Windows, macOS e Linux\n\n\n\n\n\nDia 1 (hoje): Fundamentos de R + Ambiente reprodutível (RStudio, Git, GitHub, fork)\nDia 2: Lógica de programação, condicionais, funções e tidyverse básico\nDia 3: Transformações com tidyr/dplyr, leitura/escrita de dados e visualização com ggplot2\nDia 4: Integração prática do ChatGPT e Claude dentro do RStudio\n\n\n\n\n\nRepositório GitHub: https://github.com/viniciusjunqueira/curso-r-github-ia\nDatasets: incluídos no repositório + pacote palmerpenguins\nContato: junqueiravinicius@hotmail.com\n\n\n\n\n\n\n\n\nR é uma linguagem poderosa e gratuita, criada especificamente para análise de dados e estatística. Algumas razões para aprender R:\nEcosistema rico - Mais de 20.000 pacotes disponíveis para praticamente qualquer análise - tidyverse: conjunto integrado de ferramentas modernas para ciência de dados - ggplot2: sistema de visualização elegante e profissional\nReprodutibilidade - Tudo que você faz fica documentado em código - Fácil repetir análises com novos dados - R Markdown permite combinar código, resultados e narrativa\nComunidade ativa - Grande comunidade brasileira e internacional - Milhares de tutoriais, cursos e fóruns de ajuda - TidyTuesday: prática semanal com dados reais\nDemanda no mercado - Usado em empresas, universidades e governos - Essencial para ciência de dados, bioinformática, economia, ciências sociais - Combina bem com Python em pipelines modernos de dados\n\n\n\nGitHub não é apenas para programadores! É uma plataforma essencial para:\nControle de versão - Histórico completo de todas as mudanças no seu código - Possibilidade de voltar a versões anteriores - Nunca mais perder trabalho por acidente\nColaboração - Trabalhe em equipe sem conflitos - Contribua para projetos open-source - Receba feedback e sugestões\nPortfólio profissional - Mostre seus projetos para empregadores - Demonstre evolução e consistência - Compartilhe conhecimento com a comunidade\nIntegração moderna - Funciona perfeitamente com RStudio - Base para deployment de aplicações - Padrão da indústria para ciência de dados\n\n\n\nA inteligência artificial revolucionou o aprendizado de programação. Não é trapaça, é trabalhar de forma inteligente!\nAcelera o aprendizado - Explicações personalizadas para seu nível - Respostas imediatas para dúvidas específicas - Exemplos sob medida para seu contexto\nAssistência na depuração - Interpretação de mensagens de erro - Sugestões de correção - Identificação de problemas de lógica\nAumenta produtividade - Geração de código boilerplate - Refatoração e otimização - Criação de documentação\nFerramentas do curso - ChatGPT (OpenAI): excelente para explicações didáticas e geração rápida de código - Claude (Anthropic): ótimo para análises mais profundas e revisão de código complexo\n\nImportante: IA é uma ferramenta, não uma substituição do aprendizado. Use-a para entender conceitos, não apenas copiar código!\n\n\n\n\n\n\n\nObjetivos desta seção\n\nVerificar instalações (R, RStudio, Git)\nConfigurar Git e autenticar no GitHub\nEntender e aplicar o workflow com fork\nPreparar ambiente reprodutível com projetos .Rproj e here()\n\n\n\n\n\nR.version.string           # Versão do R\n# RStudio.Version()$version # Versão do RStudio\n# system(\"git --version\")    # Confirma Git disponível\n\n\n\n\nNo Terminal do RStudio (funciona em Windows/macOS/Linux):\ngit config --global user.name \"Seu Nome\"\ngit config --global user.email \"seu@email.com\"\n# Verificar\ngit config --global --list\n\n\n\nO que é um PAT?\nUm Personal Access Token (PAT) é como uma “senha especial” que permite ao RStudio se comunicar com o GitHub de forma segura. O GitHub não aceita mais senhas normais para operações via linha de comando, então o PAT é obrigatório.\nPasso a passo para criar e configurar o PAT:\n\n\n\n# install.packages(\"usethis\")\n# install.packages(\"gitcreds\")\n\n\n\n\n\n# usethis::create_github_token()\n\nEste comando abrirá seu navegador automaticamente na página de criação de tokens do GitHub. Você verá uma página pré-configurada com as permissões necessárias.\nNo navegador:\n\nFaça login no GitHub (se ainda não estiver logado)\nNote (New personal access token - classic):\n\nO campo “Note” já virá preenchido com algo como “DESCRIBE THE TOKEN’S USE CASE”\nRenomeie para algo descritivo como: RStudio-Curso-R-2024\n\nExpiration: escolha a duração do token\n\nPara o curso: 90 days é suficiente\nPara uso contínuo: No expiration (menos seguro, mas mais prático)\n\nPermissões (Scopes): o usethis já marca as principais\n\n✅ repo (controle total de repositórios privados)\n✅ workflow (atualizar workflows do GitHub Actions)\n✅ gist (criar gists)\n✅ user (atualizar dados do usuário)\nNão altere nada, as permissões pré-selecionadas são ideais\n\nClique em “Generate token” no final da página\nATENÇÃO: copie o token que aparece (começa com ghp_...)\n\n⚠️ VOCÊ SÓ VERÁ ESTE TOKEN UMA VEZ!\nCole em um lugar seguro temporariamente (bloco de notas)\n\n\n\n\n\n\n# gitcreds::gitcreds_set()\n\nQuando executar este comando, você verá algo assim no Console:\n? Enter password or token: \nCole o token que você copiou do GitHub e pressione Enter.\nVocê verá uma mensagem de confirmação:\n-&gt; Adding new credentials...\n-&gt; Removing credentials from cache...\n-&gt; Done.\n\n\n\n\n# usethis::git_sitrep()\n\nEste comando mostra o status da sua configuração Git/GitHub. Procure por:\n✔ GitHub user: 'seu-usuario'\n✔ Token: '&lt;discovered&gt;'\nSe você ver isso, está tudo configurado! ✅\nAlternativas ao PAT: - GitHub Desktop (aplicativo com interface gráfica - mais simples para iniciantes) - SSH (método avançado, requer configuração de chaves públicas/privadas)\n\n\n\n\n\nOriginal (instrutor)  →  FORK (sua conta)  →  CLONE (seu PC)  →  PUSH (para seu fork)\n\nAbra: https://github.com/viniciusjunqueira/curso-r-github-ia\n\nClique Fork → escolha sua conta → Create fork.\n\nClone SEU fork:\n\ngit clone https://github.com/SEU-USUARIO/curso-r-github-ia.git\ncd curso-r-github-ia\n\nAbra o projeto .Rproj no RStudio.\n\nCheque o remote:\n\ngit remote -v\n# Deve mostrar seu usuário em origin\n\nPor que fork? Você controla seu repositório, faz commits/push à vontade e não altera o repo do instrutor.\n\n\n\n\n\ncurso-r-github-ia/\n├── curso-r-github-ia.Rproj\n├── data/\n│   ├── raw/\n│   └── processed/\n├── scripts/\n├── output/\n│   ├── figures/\n│   └── tables/\n└── docs/\n\n# Caminhos: sempre prefira here::here()\n# install.packages(\"here\")\n# library(here)\n# caminho &lt;- here(\"data\", \"raw\", \"dados.csv\")\n# caminho\n\n\nUTF-8: salve arquivos com File → Save with Encoding → UTF-8 (evita problemas de acentuação em todos os SOs).\n\n\n\n\n\n\n\n\nO que são objetos em R?\nEm R, tudo é um objeto! Quando você cria uma variável, você está criando um objeto que armazena informação na memória. Os tipos básicos mais importantes são:\n\nNumérico (numeric): números decimais como 3.14, 10.5, -2.7\nInteiro (integer): números inteiros como 1L, 100L (o L indica inteiro)\nLógico (logical): valores verdadeiro/falso - TRUE ou FALSE\nCaractere (character): texto entre aspas como \"Olá\", \"R\", \"2024\"\n\nVocê cria objetos usando o operador de atribuição &lt;- (preferido) ou =.\n\n# Números, lógicos, strings\nx_num &lt;- 3.14; x_log &lt;- TRUE; x_chr &lt;- \"Olá, R!\"\nclass(x_num); typeof(x_num)\nclass(x_log); typeof(x_log)\nclass(x_chr); typeof(x_chr)\n\n# Aritmética\n10 + 2; 10 - 2; 10 * 2; 10 / 3; 2 ^ 3\n\n# Especiais\nInf; -Inf; NaN; NA\n\n\n\n\nO que são vetores?\nVetores são a estrutura de dados mais fundamental do R. Um vetor é uma coleção de elementos do mesmo tipo (todos números, ou todos textos, ou todos lógicos). Você pode pensar em um vetor como uma linha de dados em uma planilha.\nCaracterísticas importantes: - Criados com a função c() (de “combine” ou “concatenar”) - Todos os elementos devem ser do mesmo tipo - R é 1-indexed (o primeiro elemento está na posição 1, não 0) - Operações são vetorizadas (aplicadas a todos elementos automaticamente)\nIndexação é o processo de acessar elementos específicos de um vetor usando colchetes [].\n\nv &lt;- c(10, 20, 30, 40, 50)\nlength(v); mean(v); sum(v)\n\nv[1]; v[2:4]; v[-1]\nsel &lt;- v &gt; 25; sel; v[sel]\n\nnames(v) &lt;- letters[1:5]\nv[\"c\"]\n\n\n\n\nListas: estruturas flexíveis\nUma lista é uma estrutura que pode conter elementos de diferentes tipos - ao contrário dos vetores. Listas são extremamente versáteis e podem armazenar números, textos, vetores, outras listas e até data.frames!\nUso típico de listas: - Armazenar resultados complexos de análises - Combinar diferentes tipos de informação - Retornar múltiplos valores de uma função\nData.frames: a estrutura tabular\nUm data.frame é a estrutura mais importante para análise de dados em R. É similar a uma planilha do Excel ou uma tabela de banco de dados: tem linhas (observações) e colunas (variáveis).\nCaracterísticas do data.frame: - Cada coluna pode ser de um tipo diferente (uma coluna numérica, outra texto) - Cada coluna é um vetor e deve ter o mesmo comprimento - É como uma lista especial onde todos os elementos têm o mesmo tamanho - Ideal para dados tabulares (como datasets de pesquisa)\n\n# Lista: tipos mistos\nlst &lt;- list(id = 1, nome = \"Ana\", aprovado = TRUE)\nlst$nome\n\n# Data frame\nalunos &lt;- data.frame(\n  id = 1:4,\n  nome = c(\"Ana\", \"Bruno\", \"Caio\", \"Dani\"),\n  nota = c(8.5, 7.2, 9.1, 6.8),\n  ativo = c(TRUE, TRUE, FALSE, TRUE),\n  stringsAsFactors = FALSE\n)\nstr(alunos); nrow(alunos); ncol(alunos); names(alunos)\nhead(alunos, 2); tail(alunos, 2)\n\n# Acesso e novas colunas\nalunos$nome\nalunos$aprov &lt;- ifelse(alunos$nota &gt;= 7, \"Aprovado\", \"Recuperação\")\n\n\n\n\nO que são fatores?\nFatores são a forma do R representar variáveis categóricas (também chamadas de qualitativas). São usados para dados que podem assumir um número limitado de valores distintos, chamados de “níveis” (levels).\nQuando usar fatores: - Variáveis categóricas: sexo (M/F), região (Norte/Sul/Leste/Oeste), tratamento (Controle/Teste) - Variáveis ordinais: nível de escolaridade, grau de satisfação (Baixo/Médio/Alto) - Respostas de questionários com opções fixas\nVantagens dos fatores: - Economizam memória (armazenam códigos internos, não strings repetidas) - Permitem ordenação lógica (ex: Baixo &lt; Médio &lt; Alto) - Facilitam análises estatísticas e gráficos - Controlam quais valores são válidos\nTipos de fatores: - Nominais (sem ordem): cores, categorias - Ordinais (com ordem): níveis de satisfação, graus acadêmicos\n\nsexo &lt;- factor(c(\"F\", \"M\", \"M\", \"F\"), levels = c(\"F\", \"M\"))\nlevels(sexo)\n\nconceito &lt;- factor(c(\"B\", \"A\", \"C\", \"A\"), levels = c(\"C\", \"B\", \"A\"), ordered = TRUE)\nsummary(conceito)\n\n\n\n\n\n\n\nVamos usar um dataset real (palmerpenguins) para praticar inspeção e resumo com diferentes funções, incluindo dplyr::glimpse().\n\n\ninstall.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)\nlibrary(dplyr)\n\n# Visão geral do dataset\nstr(penguins)              # estrutura detalhada\ndplyr::glimpse(penguins)   # visão compacta e moderna (tidyverse style)\n\n# Informações básicas\nnames(penguins)            # nomes das colunas\nnrow(penguins)             # número de linhas\nncol(penguins)             # número de colunas\ndim(penguins)              # dimensões (linhas x colunas)\n\n# Primeiras e últimas observações\nhead(penguins)             # 6 primeiras linhas\ntail(penguins, 3)          # 3 últimas linhas\n\n# Resumo estatístico\nsummary(penguins)          # resumo de cada coluna\ncolSums(is.na(penguins))   # contagem de NAs por coluna\n\n# Selecionar colunas principais (R base)\npeng_min &lt;- penguins[, c(\"species\",\"bill_length_mm\",\"bill_depth_mm\",\n                          \"flipper_length_mm\",\"body_mass_g\")]\nhead(peng_min)\n\n# Criar nova variável: razão do bico\npenguins$raz_bico &lt;- with(penguins, bill_length_mm / bill_depth_mm)\nhead(penguins$raz_bico)\n\n# Estatísticas descritivas\nmean(penguins$flipper_length_mm, na.rm = TRUE)\nsd(penguins$body_mass_g, na.rm = TRUE)\nrange(penguins$bill_length_mm, na.rm = TRUE)\n\n# Estatísticas por grupo\ntapply(penguins$flipper_length_mm, penguins$species, mean, na.rm = TRUE)\ntapply(penguins$body_mass_g, penguins$species, median, na.rm = TRUE)\n\n# Tabelas de frequência\ntable(penguins$species)\n# table(penguins$species, penguins$island)\n\n\n\nAmbas mostram a estrutura dos dados, mas com estilos diferentes:\n\n# str(): estilo tradicional do R, mais verboso\nstr(penguins)\n\n# glimpse(): estilo tidyverse, mais compacto e legível\ndplyr::glimpse(penguins)\n\nVantagens do glimpse(): - Mostra tipo de cada coluna de forma clara - Apresenta primeiros valores de forma compacta - Melhor para datasets com muitas colunas - Estilo moderno e consistente com tidyverse\n\nDica: quando houver NAs, sempre use na.rm = TRUE nas funções de resumo estatístico.\n\n\n\n\n\n\n\n\n\nCrie um vetor numérico com 8 valores quaisquer.\n\nCalcule média, mediana e desvio-padrão.\n\nFiltre apenas os valores acima da média.\n\n\n# Seu código aqui\n\n\n\n\n\nCrie um data.frame com colunas: id, nome, nota, ativo.\n\nCrie uma nova coluna situacao usando ifelse(nota &gt;= 7, \"Aprovado\", \"Recuperação\").\n\nMostre apenas as colunas nome e situacao das 2 primeiras linhas.\n\n\n# Seu código aqui\n\n\n\n\n\nUse glimpse() para ter uma visão geral dos dados.\nConte quantos NAs existem em cada coluna.\n\nCrie uma nova coluna massa_kg convertendo body_mass_g para quilogramas.\n\nCalcule a média de flipper_length_mm por espécie usando tapply().\n\n\n# Seu código aqui\n\n\n\n\n\n\nNo Terminal do RStudio:\ngit add scripts/01_fundamentos.R\ngit commit -m \"Dia 1: fundamentos de R e setup\"\ngit push origin main\n\nConfirme no seu repositório forkado no GitHub se o commit apareceu.\n\n\n\n\n\n\nR, RStudio e Git instalados e funcionando.\n\nGit configurado com user.name e user.email.\n\nFork criado no GitHub e clone realizado do SEU fork.\n\nProjeto .Rproj aberto; função here() testada.\n\nEntendeu a diferença entre str() e glimpse().\nScript 01_fundamentos.R criado e salvo em UTF-8.\n\nCommit e push realizados com sucesso para SEU fork.\n\n\n\n\n\n\nR for Data Science (2e): https://r4ds.hadley.nz/\n\nHappy Git with R: https://happygitwithr.com/\n\nCheatsheets Posit: https://posit.co/resources/cheatsheets/\n\npalmerpenguins: https://allisonhorst.github.io/palmerpenguins/\ndplyr documentation: https://dplyr.tidyverse.org/\n\n\nNos vemos no Dia 2 para explorarmos lógica de programação e tidyverse! 🚀"
  },
  {
    "objectID": "materiais/dia1_fundamentos.html#apresentação-do-curso-15-min",
    "href": "materiais/dia1_fundamentos.html#apresentação-do-curso-15-min",
    "title": "Dia 1",
    "section": "",
    "text": "Olá! Seja muito bem-vindo ao Curso Intensivo de R com GitHub e IA. Esta jornada de 16 horas foi cuidadosamente estruturada para transformar você de iniciante a alguém capaz de realizar análises de dados completas usando ferramentas modernas e profissionais.\n\n\n\nAo final deste curso, você será capaz de:\n\nProgramar em R com confiança, desde operações básicas até análises complexas\nManipular e transformar dados usando o ecossistema tidyverse\nCriar visualizações profissionais e informativas com ggplot2\nVersionar seu código com Git e colaborar via GitHub\nUsar inteligência artificial (ChatGPT e Claude) para acelerar seu aprendizado e resolver problemas\n\n\n\n\nNossa abordagem é 100% prática e hands-on:\n\nTeoria mínima necessária seguida de prática imediata\nDatasets reais desde o primeiro dia\nCommits diários no seu fork do repositório\nIA como assistente para explicação, depuração e geração de código\nMultiplataforma: todo conteúdo funciona em Windows, macOS e Linux\n\n\n\n\n\nDia 1 (hoje): Fundamentos de R + Ambiente reprodutível (RStudio, Git, GitHub, fork)\nDia 2: Lógica de programação, condicionais, funções e tidyverse básico\nDia 3: Transformações com tidyr/dplyr, leitura/escrita de dados e visualização com ggplot2\nDia 4: Integração prática do ChatGPT e Claude dentro do RStudio\n\n\n\n\n\nRepositório GitHub: https://github.com/viniciusjunqueira/curso-r-github-ia\nDatasets: incluídos no repositório + pacote palmerpenguins\nContato: junqueiravinicius@hotmail.com"
  },
  {
    "objectID": "materiais/dia1_fundamentos.html#por-que-r-github-e-ia-15-min",
    "href": "materiais/dia1_fundamentos.html#por-que-r-github-e-ia-15-min",
    "title": "Dia 1",
    "section": "",
    "text": "R é uma linguagem poderosa e gratuita, criada especificamente para análise de dados e estatística. Algumas razões para aprender R:\nEcosistema rico - Mais de 20.000 pacotes disponíveis para praticamente qualquer análise - tidyverse: conjunto integrado de ferramentas modernas para ciência de dados - ggplot2: sistema de visualização elegante e profissional\nReprodutibilidade - Tudo que você faz fica documentado em código - Fácil repetir análises com novos dados - R Markdown permite combinar código, resultados e narrativa\nComunidade ativa - Grande comunidade brasileira e internacional - Milhares de tutoriais, cursos e fóruns de ajuda - TidyTuesday: prática semanal com dados reais\nDemanda no mercado - Usado em empresas, universidades e governos - Essencial para ciência de dados, bioinformática, economia, ciências sociais - Combina bem com Python em pipelines modernos de dados\n\n\n\nGitHub não é apenas para programadores! É uma plataforma essencial para:\nControle de versão - Histórico completo de todas as mudanças no seu código - Possibilidade de voltar a versões anteriores - Nunca mais perder trabalho por acidente\nColaboração - Trabalhe em equipe sem conflitos - Contribua para projetos open-source - Receba feedback e sugestões\nPortfólio profissional - Mostre seus projetos para empregadores - Demonstre evolução e consistência - Compartilhe conhecimento com a comunidade\nIntegração moderna - Funciona perfeitamente com RStudio - Base para deployment de aplicações - Padrão da indústria para ciência de dados\n\n\n\nA inteligência artificial revolucionou o aprendizado de programação. Não é trapaça, é trabalhar de forma inteligente!\nAcelera o aprendizado - Explicações personalizadas para seu nível - Respostas imediatas para dúvidas específicas - Exemplos sob medida para seu contexto\nAssistência na depuração - Interpretação de mensagens de erro - Sugestões de correção - Identificação de problemas de lógica\nAumenta produtividade - Geração de código boilerplate - Refatoração e otimização - Criação de documentação\nFerramentas do curso - ChatGPT (OpenAI): excelente para explicações didáticas e geração rápida de código - Claude (Anthropic): ótimo para análises mais profundas e revisão de código complexo\n\nImportante: IA é uma ferramenta, não uma substituição do aprendizado. Use-a para entender conceitos, não apenas copiar código!"
  },
  {
    "objectID": "materiais/dia1_fundamentos.html#ambientação-e-setup-40-min",
    "href": "materiais/dia1_fundamentos.html#ambientação-e-setup-40-min",
    "title": "Dia 1",
    "section": "",
    "text": "Objetivos desta seção\n\nVerificar instalações (R, RStudio, Git)\nConfigurar Git e autenticar no GitHub\nEntender e aplicar o workflow com fork\nPreparar ambiente reprodutível com projetos .Rproj e here()\n\n\n\n\n\nR.version.string           # Versão do R\n# RStudio.Version()$version # Versão do RStudio\n# system(\"git --version\")    # Confirma Git disponível\n\n\n\n\nNo Terminal do RStudio (funciona em Windows/macOS/Linux):\ngit config --global user.name \"Seu Nome\"\ngit config --global user.email \"seu@email.com\"\n# Verificar\ngit config --global --list\n\n\n\nO que é um PAT?\nUm Personal Access Token (PAT) é como uma “senha especial” que permite ao RStudio se comunicar com o GitHub de forma segura. O GitHub não aceita mais senhas normais para operações via linha de comando, então o PAT é obrigatório.\nPasso a passo para criar e configurar o PAT:\n\n\n\n# install.packages(\"usethis\")\n# install.packages(\"gitcreds\")\n\n\n\n\n\n# usethis::create_github_token()\n\nEste comando abrirá seu navegador automaticamente na página de criação de tokens do GitHub. Você verá uma página pré-configurada com as permissões necessárias.\nNo navegador:\n\nFaça login no GitHub (se ainda não estiver logado)\nNote (New personal access token - classic):\n\nO campo “Note” já virá preenchido com algo como “DESCRIBE THE TOKEN’S USE CASE”\nRenomeie para algo descritivo como: RStudio-Curso-R-2024\n\nExpiration: escolha a duração do token\n\nPara o curso: 90 days é suficiente\nPara uso contínuo: No expiration (menos seguro, mas mais prático)\n\nPermissões (Scopes): o usethis já marca as principais\n\n✅ repo (controle total de repositórios privados)\n✅ workflow (atualizar workflows do GitHub Actions)\n✅ gist (criar gists)\n✅ user (atualizar dados do usuário)\nNão altere nada, as permissões pré-selecionadas são ideais\n\nClique em “Generate token” no final da página\nATENÇÃO: copie o token que aparece (começa com ghp_...)\n\n⚠️ VOCÊ SÓ VERÁ ESTE TOKEN UMA VEZ!\nCole em um lugar seguro temporariamente (bloco de notas)\n\n\n\n\n\n\n# gitcreds::gitcreds_set()\n\nQuando executar este comando, você verá algo assim no Console:\n? Enter password or token: \nCole o token que você copiou do GitHub e pressione Enter.\nVocê verá uma mensagem de confirmação:\n-&gt; Adding new credentials...\n-&gt; Removing credentials from cache...\n-&gt; Done.\n\n\n\n\n# usethis::git_sitrep()\n\nEste comando mostra o status da sua configuração Git/GitHub. Procure por:\n✔ GitHub user: 'seu-usuario'\n✔ Token: '&lt;discovered&gt;'\nSe você ver isso, está tudo configurado! ✅\nAlternativas ao PAT: - GitHub Desktop (aplicativo com interface gráfica - mais simples para iniciantes) - SSH (método avançado, requer configuração de chaves públicas/privadas)\n\n\n\n\n\nOriginal (instrutor)  →  FORK (sua conta)  →  CLONE (seu PC)  →  PUSH (para seu fork)\n\nAbra: https://github.com/viniciusjunqueira/curso-r-github-ia\n\nClique Fork → escolha sua conta → Create fork.\n\nClone SEU fork:\n\ngit clone https://github.com/SEU-USUARIO/curso-r-github-ia.git\ncd curso-r-github-ia\n\nAbra o projeto .Rproj no RStudio.\n\nCheque o remote:\n\ngit remote -v\n# Deve mostrar seu usuário em origin\n\nPor que fork? Você controla seu repositório, faz commits/push à vontade e não altera o repo do instrutor.\n\n\n\n\n\ncurso-r-github-ia/\n├── curso-r-github-ia.Rproj\n├── data/\n│   ├── raw/\n│   └── processed/\n├── scripts/\n├── output/\n│   ├── figures/\n│   └── tables/\n└── docs/\n\n# Caminhos: sempre prefira here::here()\n# install.packages(\"here\")\n# library(here)\n# caminho &lt;- here(\"data\", \"raw\", \"dados.csv\")\n# caminho\n\n\nUTF-8: salve arquivos com File → Save with Encoding → UTF-8 (evita problemas de acentuação em todos os SOs)."
  },
  {
    "objectID": "materiais/dia1_fundamentos.html#fundamentos-de-r-50-min",
    "href": "materiais/dia1_fundamentos.html#fundamentos-de-r-50-min",
    "title": "Dia 1",
    "section": "",
    "text": "O que são objetos em R?\nEm R, tudo é um objeto! Quando você cria uma variável, você está criando um objeto que armazena informação na memória. Os tipos básicos mais importantes são:\n\nNumérico (numeric): números decimais como 3.14, 10.5, -2.7\nInteiro (integer): números inteiros como 1L, 100L (o L indica inteiro)\nLógico (logical): valores verdadeiro/falso - TRUE ou FALSE\nCaractere (character): texto entre aspas como \"Olá\", \"R\", \"2024\"\n\nVocê cria objetos usando o operador de atribuição &lt;- (preferido) ou =.\n\n# Números, lógicos, strings\nx_num &lt;- 3.14; x_log &lt;- TRUE; x_chr &lt;- \"Olá, R!\"\nclass(x_num); typeof(x_num)\nclass(x_log); typeof(x_log)\nclass(x_chr); typeof(x_chr)\n\n# Aritmética\n10 + 2; 10 - 2; 10 * 2; 10 / 3; 2 ^ 3\n\n# Especiais\nInf; -Inf; NaN; NA\n\n\n\n\nO que são vetores?\nVetores são a estrutura de dados mais fundamental do R. Um vetor é uma coleção de elementos do mesmo tipo (todos números, ou todos textos, ou todos lógicos). Você pode pensar em um vetor como uma linha de dados em uma planilha.\nCaracterísticas importantes: - Criados com a função c() (de “combine” ou “concatenar”) - Todos os elementos devem ser do mesmo tipo - R é 1-indexed (o primeiro elemento está na posição 1, não 0) - Operações são vetorizadas (aplicadas a todos elementos automaticamente)\nIndexação é o processo de acessar elementos específicos de um vetor usando colchetes [].\n\nv &lt;- c(10, 20, 30, 40, 50)\nlength(v); mean(v); sum(v)\n\nv[1]; v[2:4]; v[-1]\nsel &lt;- v &gt; 25; sel; v[sel]\n\nnames(v) &lt;- letters[1:5]\nv[\"c\"]\n\n\n\n\nListas: estruturas flexíveis\nUma lista é uma estrutura que pode conter elementos de diferentes tipos - ao contrário dos vetores. Listas são extremamente versáteis e podem armazenar números, textos, vetores, outras listas e até data.frames!\nUso típico de listas: - Armazenar resultados complexos de análises - Combinar diferentes tipos de informação - Retornar múltiplos valores de uma função\nData.frames: a estrutura tabular\nUm data.frame é a estrutura mais importante para análise de dados em R. É similar a uma planilha do Excel ou uma tabela de banco de dados: tem linhas (observações) e colunas (variáveis).\nCaracterísticas do data.frame: - Cada coluna pode ser de um tipo diferente (uma coluna numérica, outra texto) - Cada coluna é um vetor e deve ter o mesmo comprimento - É como uma lista especial onde todos os elementos têm o mesmo tamanho - Ideal para dados tabulares (como datasets de pesquisa)\n\n# Lista: tipos mistos\nlst &lt;- list(id = 1, nome = \"Ana\", aprovado = TRUE)\nlst$nome\n\n# Data frame\nalunos &lt;- data.frame(\n  id = 1:4,\n  nome = c(\"Ana\", \"Bruno\", \"Caio\", \"Dani\"),\n  nota = c(8.5, 7.2, 9.1, 6.8),\n  ativo = c(TRUE, TRUE, FALSE, TRUE),\n  stringsAsFactors = FALSE\n)\nstr(alunos); nrow(alunos); ncol(alunos); names(alunos)\nhead(alunos, 2); tail(alunos, 2)\n\n# Acesso e novas colunas\nalunos$nome\nalunos$aprov &lt;- ifelse(alunos$nota &gt;= 7, \"Aprovado\", \"Recuperação\")\n\n\n\n\nO que são fatores?\nFatores são a forma do R representar variáveis categóricas (também chamadas de qualitativas). São usados para dados que podem assumir um número limitado de valores distintos, chamados de “níveis” (levels).\nQuando usar fatores: - Variáveis categóricas: sexo (M/F), região (Norte/Sul/Leste/Oeste), tratamento (Controle/Teste) - Variáveis ordinais: nível de escolaridade, grau de satisfação (Baixo/Médio/Alto) - Respostas de questionários com opções fixas\nVantagens dos fatores: - Economizam memória (armazenam códigos internos, não strings repetidas) - Permitem ordenação lógica (ex: Baixo &lt; Médio &lt; Alto) - Facilitam análises estatísticas e gráficos - Controlam quais valores são válidos\nTipos de fatores: - Nominais (sem ordem): cores, categorias - Ordinais (com ordem): níveis de satisfação, graus acadêmicos\n\nsexo &lt;- factor(c(\"F\", \"M\", \"M\", \"F\"), levels = c(\"F\", \"M\"))\nlevels(sexo)\n\nconceito &lt;- factor(c(\"B\", \"A\", \"C\", \"A\"), levels = c(\"C\", \"B\", \"A\"), ordered = TRUE)\nsummary(conceito)"
  },
  {
    "objectID": "materiais/dia1_fundamentos.html#exploração-inicial-de-dados-40-min",
    "href": "materiais/dia1_fundamentos.html#exploração-inicial-de-dados-40-min",
    "title": "Dia 1",
    "section": "",
    "text": "Vamos usar um dataset real (palmerpenguins) para praticar inspeção e resumo com diferentes funções, incluindo dplyr::glimpse().\n\n\ninstall.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)\nlibrary(dplyr)\n\n# Visão geral do dataset\nstr(penguins)              # estrutura detalhada\ndplyr::glimpse(penguins)   # visão compacta e moderna (tidyverse style)\n\n# Informações básicas\nnames(penguins)            # nomes das colunas\nnrow(penguins)             # número de linhas\nncol(penguins)             # número de colunas\ndim(penguins)              # dimensões (linhas x colunas)\n\n# Primeiras e últimas observações\nhead(penguins)             # 6 primeiras linhas\ntail(penguins, 3)          # 3 últimas linhas\n\n# Resumo estatístico\nsummary(penguins)          # resumo de cada coluna\ncolSums(is.na(penguins))   # contagem de NAs por coluna\n\n# Selecionar colunas principais (R base)\npeng_min &lt;- penguins[, c(\"species\",\"bill_length_mm\",\"bill_depth_mm\",\n                          \"flipper_length_mm\",\"body_mass_g\")]\nhead(peng_min)\n\n# Criar nova variável: razão do bico\npenguins$raz_bico &lt;- with(penguins, bill_length_mm / bill_depth_mm)\nhead(penguins$raz_bico)\n\n# Estatísticas descritivas\nmean(penguins$flipper_length_mm, na.rm = TRUE)\nsd(penguins$body_mass_g, na.rm = TRUE)\nrange(penguins$bill_length_mm, na.rm = TRUE)\n\n# Estatísticas por grupo\ntapply(penguins$flipper_length_mm, penguins$species, mean, na.rm = TRUE)\ntapply(penguins$body_mass_g, penguins$species, median, na.rm = TRUE)\n\n# Tabelas de frequência\ntable(penguins$species)\n# table(penguins$species, penguins$island)\n\n\n\nAmbas mostram a estrutura dos dados, mas com estilos diferentes:\n\n# str(): estilo tradicional do R, mais verboso\nstr(penguins)\n\n# glimpse(): estilo tidyverse, mais compacto e legível\ndplyr::glimpse(penguins)\n\nVantagens do glimpse(): - Mostra tipo de cada coluna de forma clara - Apresenta primeiros valores de forma compacta - Melhor para datasets com muitas colunas - Estilo moderno e consistente com tidyverse\n\nDica: quando houver NAs, sempre use na.rm = TRUE nas funções de resumo estatístico."
  },
  {
    "objectID": "materiais/dia1_fundamentos.html#exercícios-guiados-20-min",
    "href": "materiais/dia1_fundamentos.html#exercícios-guiados-20-min",
    "title": "Dia 1",
    "section": "",
    "text": "Crie um vetor numérico com 8 valores quaisquer.\n\nCalcule média, mediana e desvio-padrão.\n\nFiltre apenas os valores acima da média.\n\n\n# Seu código aqui\n\n\n\n\n\nCrie um data.frame com colunas: id, nome, nota, ativo.\n\nCrie uma nova coluna situacao usando ifelse(nota &gt;= 7, \"Aprovado\", \"Recuperação\").\n\nMostre apenas as colunas nome e situacao das 2 primeiras linhas.\n\n\n# Seu código aqui\n\n\n\n\n\nUse glimpse() para ter uma visão geral dos dados.\nConte quantos NAs existem em cada coluna.\n\nCrie uma nova coluna massa_kg convertendo body_mass_g para quilogramas.\n\nCalcule a média de flipper_length_mm por espécie usando tapply().\n\n\n# Seu código aqui"
  },
  {
    "objectID": "materiais/dia1_fundamentos.html#primeiro-commit-5-min",
    "href": "materiais/dia1_fundamentos.html#primeiro-commit-5-min",
    "title": "Dia 1",
    "section": "",
    "text": "No Terminal do RStudio:\ngit add scripts/01_fundamentos.R\ngit commit -m \"Dia 1: fundamentos de R e setup\"\ngit push origin main\n\nConfirme no seu repositório forkado no GitHub se o commit apareceu."
  },
  {
    "objectID": "materiais/dia1_fundamentos.html#checklist-de-encerramento",
    "href": "materiais/dia1_fundamentos.html#checklist-de-encerramento",
    "title": "Dia 1",
    "section": "",
    "text": "R, RStudio e Git instalados e funcionando.\n\nGit configurado com user.name e user.email.\n\nFork criado no GitHub e clone realizado do SEU fork.\n\nProjeto .Rproj aberto; função here() testada.\n\nEntendeu a diferença entre str() e glimpse().\nScript 01_fundamentos.R criado e salvo em UTF-8.\n\nCommit e push realizados com sucesso para SEU fork."
  },
  {
    "objectID": "materiais/dia1_fundamentos.html#referências-rápidas",
    "href": "materiais/dia1_fundamentos.html#referências-rápidas",
    "title": "Dia 1",
    "section": "",
    "text": "R for Data Science (2e): https://r4ds.hadley.nz/\n\nHappy Git with R: https://happygitwithr.com/\n\nCheatsheets Posit: https://posit.co/resources/cheatsheets/\n\npalmerpenguins: https://allisonhorst.github.io/palmerpenguins/\ndplyr documentation: https://dplyr.tidyverse.org/\n\n\nNos vemos no Dia 2 para explorarmos lógica de programação e tidyverse! 🚀"
  },
  {
    "objectID": "materiais/dia2_logica_funcoes.html",
    "href": "materiais/dia2_logica_funcoes.html",
    "title": "Dia 2",
    "section": "",
    "text": "Objetivos do dia\n\nDominar operadores lógicos/relacionais e condicionais (if, ifelse, case_when).\n\nEntender loops vs. vetorização e criar funções próprias.\n\nAplicar um pipeline básico com dplyr e introduzir datas com lubridate.\n\nRegistrar o aprendizado com um commit no seu fork no GitHub.\n\n\nTempo previsto 19h00–22h00 (intervalo 20h30–20h50)\n\n\n\n\n\nOperadores são símbolos especiais que realizam operações entre valores. Eles são fundamentais para tomar decisões no código e controlar o fluxo de execução.\n\n\n\nOperadores relacionais comparam dois valores e retornam TRUE ou FALSE:\n\n== : igual a\n!= : diferente de\n\n&gt; : maior que\n&lt; : menor que\n&gt;= : maior ou igual\n&lt;= : menor ou igual\n\nOperadores lógicos combinam condições:\n\n& : E (AND) - ambas condições devem ser verdadeiras\n| : OU (OR) - pelo menos uma condição deve ser verdadeira\n! : NÃO (NOT) - inverte o valor lógico\nxor() : OU EXCLUSIVO - apenas uma condição pode ser verdadeira\n\nOperador especial: - %in% : verifica se um valor está presente em um vetor\n\n# Lógicos: & | ! xor()\nTRUE & FALSE    # FALSE (ambos precisam ser TRUE)\nTRUE | FALSE    # TRUE (pelo menos um é TRUE)\n!TRUE          # FALSE (inverte)\nxor(TRUE, FALSE) # TRUE (apenas um é TRUE)\n\n# Relacionais: == != &gt; &lt; &gt;= &lt;=\n3 == 3         # TRUE (igual)\n5 != 2         # TRUE (diferente)\n5 &gt; 2; 1 &lt; 0   # TRUE; FALSE\n2 &gt;= 2; 3 &lt;= 10 # TRUE; TRUE\n\n# %in% (teste de pertinência)\n2 %in% c(1, 2, 3)                        # TRUE\n\"Adelie\" %in% c(\"Chinstrap\", \"Gentoo\")   # FALSE\n\n\n\n\nCondicionais permitem que seu código tome decisões baseadas em condições. São como perguntas “se… então… senão…”.\nTrês formas principais:\n\nif/else - Estrutura clássica para um único valor\n\nAvalia uma condição e executa diferentes blocos de código\nÚtil para controle de fluxo em funções\n\nifelse() - Versão vetorizada para múltiplos valores\n\nAplica a condição a cada elemento de um vetor\nRetorna um vetor de resultados\nIdeal para criar novas colunas em data.frames\n\ncase_when() - Para múltiplas condições complexas\n\nAvalia várias regras em sequência\nPara na primeira regra verdadeira\nMais legível que ifelse() aninhados\n\n\n\n# if/else (escalar - um valor por vez)\nx &lt;- 18\nif (x &gt;= 18) {\n  status &lt;- \"maior_de_idade\"\n} else {\n  status &lt;- \"menor_de_idade\"\n}\nstatus\n\n# ifelse() (vetorizado - múltiplos valores)\nnotas &lt;- c(5.9, 7.5, 9.2, 6.0)\nresultado &lt;- ifelse(notas &gt;= 7, \"Aprovado\", \"Recuperação\")\nresultado\n\n# case_when() (múltiplas regras em ordem)\nlibrary(dplyr)\nfaixa &lt;- case_when(\n  notas &gt;= 9             ~ \"Excelente\",\n  notas &gt;= 7 & notas &lt; 9 ~ \"Bom\",\n  notas &gt;= 5 & notas &lt; 7 ~ \"Regular\",\n  TRUE                   ~ \"Insuficiente\"  # TRUE = \"caso contrário\"\n)\nfaixa\n\n\nDica didática: use ifelse() quando quiser vetorizar; case_when() quando houver várias regras.\n\n\n\n\n\n\n\n\nO que são loops?\nUm loop (laço) é uma estrutura que repete um bloco de código várias vezes. O loop for é o mais comum e executa o código uma vez para cada elemento de uma sequência.\nPor que evitar loops em R?\nR é uma linguagem vetorizada, o que significa que muitas operações funcionam automaticamente em vetores inteiros, sem precisar de loops explícitos. Operações vetorizadas são: - Mais rápidas (otimizadas internamente em C/Fortran) - Mais legíveis (menos linhas de código) - Mais idiomáticas (o “jeito R” de fazer)\nQuando usar loops: - Quando não existe alternativa vetorizada - Para operações que dependem de iterações anteriores - Em simulações e processos iterativos\n\nvalores &lt;- 1:5\n\n# Loop for (didático, mas não idiomático)\nsoma &lt;- 0\nfor (v in valores) {\n  soma &lt;- soma + v\n}\nsoma\n\n# Vetorizado (preferido em R!)\nsum(valores)  # Muito mais simples e rápido\n\n\n\n\nO que são funções?\nFunções são blocos de código que realizam uma tarefa específica e podem ser reutilizados. São fundamentais para: - Organizar código em partes lógicas - Reutilizar lógica sem repetir código - Documentar intenções através de nomes descritivos - Facilitar manutenção e debugging\nEstrutura de uma função:\nnome_funcao &lt;- function(argumento1, argumento2 = valor_padrao) {\n  # corpo da função\n  resultado &lt;- alguma_operacao\n  return(resultado)  # return é opcional (retorna última expressão)\n}\nBoas práticas: - Use nomes descritivos que indiquem o que a função faz - Valide entradas com stop(), stopifnot() ou if - Documente com comentários o que a função faz e quais são os argumentos - Retorne sempre o mesmo tipo de objeto\nExemplo prático: calculadora de IMC\n\n# Fórmula: IMC = peso(kg) / altura(m)^2\nimc &lt;- function(peso, altura) {\n  # Validação: altura não pode ser zero ou negativa\n  if (any(altura &lt;= 0)) stop(\"Altura deve ser &gt; 0\")\n  \n  # Cálculo vetorizado (funciona com um ou vários valores)\n  peso / (altura ^ 2)\n}\n\n# Testando com múltiplos valores\nimc(c(70, 80), c(1.70, 1.80))\n\n# Função para classificar IMC usando case_when()\nclassificar_imc &lt;- function(imc) {\n  dplyr::case_when(\n    imc &lt; 18.5              ~ \"Abaixo do peso\",\n    imc &gt;= 18.5 & imc &lt; 25  ~ \"Normal\",\n    imc &gt;= 25   & imc &lt; 30  ~ \"Sobrepeso\",\n    imc &gt;= 30               ~ \"Obesidade\"\n  )\n}\n\n# Combinando as duas funções\nval &lt;- imc(80, 1.75)\nclassificar_imc(val)\n\n\nPrincípio DRY (Don’t Repeat Yourself): se você copiou e colou código mais de 2 vezes, provavelmente deveria criar uma função!\n\n\n\n\n\n\n\nVamos aplicar dplyr no dataset palmerpenguins e criar um pequeno pipeline.\n\n\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\n# Remover linhas com NAs nas colunas essenciais\npeng &lt;- penguins |&gt;\n  filter(!is.na(species),\n         !is.na(bill_length_mm),\n         !is.na(bill_depth_mm),\n         !is.na(flipper_length_mm),\n         !is.na(body_mass_g))\n\n# Selecionar só o que precisamos\npeng_sel &lt;- peng |&gt;\n  select(species, island, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)\n\n# Criar nova variável (razão do bico) e reordenar\npeng_feat &lt;- peng_sel |&gt;\n  mutate(raz_bico = bill_length_mm / bill_depth_mm) |&gt;\n  arrange(species, desc(raz_bico))\n\n# Resumo por espécie\nresumo &lt;- peng_feat |&gt;\n  group_by(species) |&gt;\n  summarize(\n    n = n(),\n    media_flipper = mean(flipper_length_mm),\n    sd_flipper    = sd(flipper_length_mm),\n    media_massa   = mean(body_mass_g)\n  )\nresumo\n\n\n\n\n# Ambos funcionam; escolha um padrão para a turma.\n# Exemplo com |&gt; (pipe nativo do R &gt;= 4.1):\npenguins |&gt;\n  tidyr::drop_na(bill_length_mm) |&gt;\n  dplyr::summarize(media = mean(bill_length_mm))\n\n\n\n\n\n\n\nDatas aparecem em quase todos os projetos. Vamos ilustrar rapidamente.\n\n\nlibrary(lubridate)\n\n# Criação e parsing\nymd(\"2025-11-18\")\ndmy(\"18/11/2025\")\nmdy(\"11-18-2025\")\n\n# Componentes\nhoje &lt;- today()\nano(hoje); mes(hoje); wday(hoje, label = TRUE, abbr = FALSE)\n\n# Operações simples\nhoje + days(14)\ninterval(ymd(\"2025-11-01\"), ymd(\"2025-11-18\"))\n\n\nIntegrando no pipeline: quando houver colunas de data, transforme-as e derive mês/ano para agregações.\n\n\n\n\n\n\nDataset: palmerpenguins::penguins\n\n\n\n\nCrie um vetor de 8 notas qualquer.\n\nClassifique com ifelse() como Aprovado/Recuperação (corte em 7).\n\nDepois, crie uma classificação mais rica usando case_when() com 4 faixas.\n\n\n# Seu código aqui\n\n\n\n\n\nEscreva uma função zscore(x) que centraliza e escala (média 0, desvio 1).\n\nAplique em bill_length_mm removendo NAs antes.\n\nFaça um segundo argumento opcional na_rm = TRUE dentro da função.\n\n\n# Seu código aqui\n\n\n\n\n\nCrie peng3 filtrando linhas completas nas 4 medidas principais.\n\nCalcule, por espécie, média e desvio da nadadeira (flipper_length_mm).\n\nOrdene do maior para o menor e mostre as 5 primeiras linhas.\n\n\n# Seu código aqui\n\n\n\n\n\nCrie um vetor com 5 datas em formato “dd/mm/aaaa”.\n\nConverta com dmy() e extraia month() (com rótulo).\n\nSome 30 dias à primeira data e compute o intervalo até a última.\n\n\n# Seu código aqui\n\n\n\n\n\n\n\nUse nomes descritivos em snake_case.\nComente o porquê (não só o que) no código.\nValide entradas em funções (stop() para erros previsíveis).\nLeia mensagens de erro de baixo para cima (stack trace).\nMantenha scripts curtos e reutilizáveis.\n\n\n\n\n# message(), warning(), stop() para sinalizar eventos\n# browser() para inspecionar dentro de uma função (quando eval=TRUE)\n# traceback() após um erro\n\n\nIA como apoio (responsável): use ChatGPT/Claude para explicar erros e sugerir melhorias, mas sempre entenda e teste o código.\n\n\n\n\n\n\n\nSalve como scripts/02_logica_funcoes.R ou materiais/dia2_logica_funcoes.Rmd (este arquivo).\n\nNo Terminal do RStudio:\n\ngit add scripts/02_logica_funcoes.R\ngit commit -m \"Dia 2: lógica, funções e tidyverse (com lubridate)\"\ngit push origin main\n\nLembre-se: você está trabalhando no SEU fork. O repositório original permanece protegido.\n\n\n\n\n\n\nDominou operadores lógicos e relacionais\nEntendeu diferenças entre if/else, ifelse() e case_when()\nCompreendeu por que vetorização é preferível a loops\nCriou suas primeiras funções com validação\nAplicou pipeline básico com dplyr\nExplorou manipulação de datas com lubridate\nRealizou commit e push no seu fork\n\n\n\n\n\n\ndplyr cheatsheet: https://posit.co/resources/cheatsheets/\n\nR for Data Science (2e): https://r4ds.hadley.nz/\n\nHappy Git with R: https://happygitwithr.com/\n\npalmerpenguins: https://allisonhorst.github.io/palmerpenguins/\nlubridate: https://lubridate.tidyverse.org/\n\n\nNos vemos no Dia 3 para transformação de dados e visualização com ggplot2! 🚀"
  },
  {
    "objectID": "materiais/dia2_logica_funcoes.html#operadores-e-condicionais-30-min",
    "href": "materiais/dia2_logica_funcoes.html#operadores-e-condicionais-30-min",
    "title": "Dia 2",
    "section": "",
    "text": "Operadores são símbolos especiais que realizam operações entre valores. Eles são fundamentais para tomar decisões no código e controlar o fluxo de execução.\n\n\n\nOperadores relacionais comparam dois valores e retornam TRUE ou FALSE:\n\n== : igual a\n!= : diferente de\n\n&gt; : maior que\n&lt; : menor que\n&gt;= : maior ou igual\n&lt;= : menor ou igual\n\nOperadores lógicos combinam condições:\n\n& : E (AND) - ambas condições devem ser verdadeiras\n| : OU (OR) - pelo menos uma condição deve ser verdadeira\n! : NÃO (NOT) - inverte o valor lógico\nxor() : OU EXCLUSIVO - apenas uma condição pode ser verdadeira\n\nOperador especial: - %in% : verifica se um valor está presente em um vetor\n\n# Lógicos: & | ! xor()\nTRUE & FALSE    # FALSE (ambos precisam ser TRUE)\nTRUE | FALSE    # TRUE (pelo menos um é TRUE)\n!TRUE          # FALSE (inverte)\nxor(TRUE, FALSE) # TRUE (apenas um é TRUE)\n\n# Relacionais: == != &gt; &lt; &gt;= &lt;=\n3 == 3         # TRUE (igual)\n5 != 2         # TRUE (diferente)\n5 &gt; 2; 1 &lt; 0   # TRUE; FALSE\n2 &gt;= 2; 3 &lt;= 10 # TRUE; TRUE\n\n# %in% (teste de pertinência)\n2 %in% c(1, 2, 3)                        # TRUE\n\"Adelie\" %in% c(\"Chinstrap\", \"Gentoo\")   # FALSE\n\n\n\n\nCondicionais permitem que seu código tome decisões baseadas em condições. São como perguntas “se… então… senão…”.\nTrês formas principais:\n\nif/else - Estrutura clássica para um único valor\n\nAvalia uma condição e executa diferentes blocos de código\nÚtil para controle de fluxo em funções\n\nifelse() - Versão vetorizada para múltiplos valores\n\nAplica a condição a cada elemento de um vetor\nRetorna um vetor de resultados\nIdeal para criar novas colunas em data.frames\n\ncase_when() - Para múltiplas condições complexas\n\nAvalia várias regras em sequência\nPara na primeira regra verdadeira\nMais legível que ifelse() aninhados\n\n\n\n# if/else (escalar - um valor por vez)\nx &lt;- 18\nif (x &gt;= 18) {\n  status &lt;- \"maior_de_idade\"\n} else {\n  status &lt;- \"menor_de_idade\"\n}\nstatus\n\n# ifelse() (vetorizado - múltiplos valores)\nnotas &lt;- c(5.9, 7.5, 9.2, 6.0)\nresultado &lt;- ifelse(notas &gt;= 7, \"Aprovado\", \"Recuperação\")\nresultado\n\n# case_when() (múltiplas regras em ordem)\nlibrary(dplyr)\nfaixa &lt;- case_when(\n  notas &gt;= 9             ~ \"Excelente\",\n  notas &gt;= 7 & notas &lt; 9 ~ \"Bom\",\n  notas &gt;= 5 & notas &lt; 7 ~ \"Regular\",\n  TRUE                   ~ \"Insuficiente\"  # TRUE = \"caso contrário\"\n)\nfaixa\n\n\nDica didática: use ifelse() quando quiser vetorizar; case_when() quando houver várias regras."
  },
  {
    "objectID": "materiais/dia2_logica_funcoes.html#loops-vetorização-e-funções-25-min",
    "href": "materiais/dia2_logica_funcoes.html#loops-vetorização-e-funções-25-min",
    "title": "Dia 2",
    "section": "",
    "text": "O que são loops?\nUm loop (laço) é uma estrutura que repete um bloco de código várias vezes. O loop for é o mais comum e executa o código uma vez para cada elemento de uma sequência.\nPor que evitar loops em R?\nR é uma linguagem vetorizada, o que significa que muitas operações funcionam automaticamente em vetores inteiros, sem precisar de loops explícitos. Operações vetorizadas são: - Mais rápidas (otimizadas internamente em C/Fortran) - Mais legíveis (menos linhas de código) - Mais idiomáticas (o “jeito R” de fazer)\nQuando usar loops: - Quando não existe alternativa vetorizada - Para operações que dependem de iterações anteriores - Em simulações e processos iterativos\n\nvalores &lt;- 1:5\n\n# Loop for (didático, mas não idiomático)\nsoma &lt;- 0\nfor (v in valores) {\n  soma &lt;- soma + v\n}\nsoma\n\n# Vetorizado (preferido em R!)\nsum(valores)  # Muito mais simples e rápido\n\n\n\n\nO que são funções?\nFunções são blocos de código que realizam uma tarefa específica e podem ser reutilizados. São fundamentais para: - Organizar código em partes lógicas - Reutilizar lógica sem repetir código - Documentar intenções através de nomes descritivos - Facilitar manutenção e debugging\nEstrutura de uma função:\nnome_funcao &lt;- function(argumento1, argumento2 = valor_padrao) {\n  # corpo da função\n  resultado &lt;- alguma_operacao\n  return(resultado)  # return é opcional (retorna última expressão)\n}\nBoas práticas: - Use nomes descritivos que indiquem o que a função faz - Valide entradas com stop(), stopifnot() ou if - Documente com comentários o que a função faz e quais são os argumentos - Retorne sempre o mesmo tipo de objeto\nExemplo prático: calculadora de IMC\n\n# Fórmula: IMC = peso(kg) / altura(m)^2\nimc &lt;- function(peso, altura) {\n  # Validação: altura não pode ser zero ou negativa\n  if (any(altura &lt;= 0)) stop(\"Altura deve ser &gt; 0\")\n  \n  # Cálculo vetorizado (funciona com um ou vários valores)\n  peso / (altura ^ 2)\n}\n\n# Testando com múltiplos valores\nimc(c(70, 80), c(1.70, 1.80))\n\n# Função para classificar IMC usando case_when()\nclassificar_imc &lt;- function(imc) {\n  dplyr::case_when(\n    imc &lt; 18.5              ~ \"Abaixo do peso\",\n    imc &gt;= 18.5 & imc &lt; 25  ~ \"Normal\",\n    imc &gt;= 25   & imc &lt; 30  ~ \"Sobrepeso\",\n    imc &gt;= 30               ~ \"Obesidade\"\n  )\n}\n\n# Combinando as duas funções\nval &lt;- imc(80, 1.75)\nclassificar_imc(val)\n\n\nPrincípio DRY (Don’t Repeat Yourself): se você copiou e colou código mais de 2 vezes, provavelmente deveria criar uma função!"
  },
  {
    "objectID": "materiais/dia2_logica_funcoes.html#introdução-ao-tidyverse-45-min",
    "href": "materiais/dia2_logica_funcoes.html#introdução-ao-tidyverse-45-min",
    "title": "Dia 2",
    "section": "",
    "text": "Vamos aplicar dplyr no dataset palmerpenguins e criar um pequeno pipeline.\n\n\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\n# Remover linhas com NAs nas colunas essenciais\npeng &lt;- penguins |&gt;\n  filter(!is.na(species),\n         !is.na(bill_length_mm),\n         !is.na(bill_depth_mm),\n         !is.na(flipper_length_mm),\n         !is.na(body_mass_g))\n\n# Selecionar só o que precisamos\npeng_sel &lt;- peng |&gt;\n  select(species, island, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)\n\n# Criar nova variável (razão do bico) e reordenar\npeng_feat &lt;- peng_sel |&gt;\n  mutate(raz_bico = bill_length_mm / bill_depth_mm) |&gt;\n  arrange(species, desc(raz_bico))\n\n# Resumo por espécie\nresumo &lt;- peng_feat |&gt;\n  group_by(species) |&gt;\n  summarize(\n    n = n(),\n    media_flipper = mean(flipper_length_mm),\n    sd_flipper    = sd(flipper_length_mm),\n    media_massa   = mean(body_mass_g)\n  )\nresumo\n\n\n\n\n# Ambos funcionam; escolha um padrão para a turma.\n# Exemplo com |&gt; (pipe nativo do R &gt;= 4.1):\npenguins |&gt;\n  tidyr::drop_na(bill_length_mm) |&gt;\n  dplyr::summarize(media = mean(bill_length_mm))"
  },
  {
    "objectID": "materiais/dia2_logica_funcoes.html#datas-com-lubridate-10-min",
    "href": "materiais/dia2_logica_funcoes.html#datas-com-lubridate-10-min",
    "title": "Dia 2",
    "section": "",
    "text": "Datas aparecem em quase todos os projetos. Vamos ilustrar rapidamente.\n\n\nlibrary(lubridate)\n\n# Criação e parsing\nymd(\"2025-11-18\")\ndmy(\"18/11/2025\")\nmdy(\"11-18-2025\")\n\n# Componentes\nhoje &lt;- today()\nano(hoje); mes(hoje); wday(hoje, label = TRUE, abbr = FALSE)\n\n# Operações simples\nhoje + days(14)\ninterval(ymd(\"2025-11-01\"), ymd(\"2025-11-18\"))\n\n\nIntegrando no pipeline: quando houver colunas de data, transforme-as e derive mês/ano para agregações."
  },
  {
    "objectID": "materiais/dia2_logica_funcoes.html#exercícios-práticos-2025-min",
    "href": "materiais/dia2_logica_funcoes.html#exercícios-práticos-2025-min",
    "title": "Dia 2",
    "section": "",
    "text": "Dataset: palmerpenguins::penguins\n\n\n\n\nCrie um vetor de 8 notas qualquer.\n\nClassifique com ifelse() como Aprovado/Recuperação (corte em 7).\n\nDepois, crie uma classificação mais rica usando case_when() com 4 faixas.\n\n\n# Seu código aqui\n\n\n\n\n\nEscreva uma função zscore(x) que centraliza e escala (média 0, desvio 1).\n\nAplique em bill_length_mm removendo NAs antes.\n\nFaça um segundo argumento opcional na_rm = TRUE dentro da função.\n\n\n# Seu código aqui\n\n\n\n\n\nCrie peng3 filtrando linhas completas nas 4 medidas principais.\n\nCalcule, por espécie, média e desvio da nadadeira (flipper_length_mm).\n\nOrdene do maior para o menor e mostre as 5 primeiras linhas.\n\n\n# Seu código aqui\n\n\n\n\n\nCrie um vetor com 5 datas em formato “dd/mm/aaaa”.\n\nConverta com dmy() e extraia month() (com rótulo).\n\nSome 30 dias à primeira data e compute o intervalo até a última.\n\n\n# Seu código aqui"
  },
  {
    "objectID": "materiais/dia2_logica_funcoes.html#boas-práticas-e-debugging-20-min",
    "href": "materiais/dia2_logica_funcoes.html#boas-práticas-e-debugging-20-min",
    "title": "Dia 2",
    "section": "",
    "text": "Use nomes descritivos em snake_case.\nComente o porquê (não só o que) no código.\nValide entradas em funções (stop() para erros previsíveis).\nLeia mensagens de erro de baixo para cima (stack trace).\nMantenha scripts curtos e reutilizáveis.\n\n\n\n\n# message(), warning(), stop() para sinalizar eventos\n# browser() para inspecionar dentro de uma função (quando eval=TRUE)\n# traceback() após um erro\n\n\nIA como apoio (responsável): use ChatGPT/Claude para explicar erros e sugerir melhorias, mas sempre entenda e teste o código."
  },
  {
    "objectID": "materiais/dia2_logica_funcoes.html#commit-do-dia",
    "href": "materiais/dia2_logica_funcoes.html#commit-do-dia",
    "title": "Dia 2",
    "section": "",
    "text": "Salve como scripts/02_logica_funcoes.R ou materiais/dia2_logica_funcoes.Rmd (este arquivo).\n\nNo Terminal do RStudio:\n\ngit add scripts/02_logica_funcoes.R\ngit commit -m \"Dia 2: lógica, funções e tidyverse (com lubridate)\"\ngit push origin main\n\nLembre-se: você está trabalhando no SEU fork. O repositório original permanece protegido."
  },
  {
    "objectID": "materiais/dia2_logica_funcoes.html#checklist-de-encerramento",
    "href": "materiais/dia2_logica_funcoes.html#checklist-de-encerramento",
    "title": "Dia 2",
    "section": "",
    "text": "Dominou operadores lógicos e relacionais\nEntendeu diferenças entre if/else, ifelse() e case_when()\nCompreendeu por que vetorização é preferível a loops\nCriou suas primeiras funções com validação\nAplicou pipeline básico com dplyr\nExplorou manipulação de datas com lubridate\nRealizou commit e push no seu fork"
  },
  {
    "objectID": "materiais/dia2_logica_funcoes.html#referências-rápidas",
    "href": "materiais/dia2_logica_funcoes.html#referências-rápidas",
    "title": "Dia 2",
    "section": "",
    "text": "dplyr cheatsheet: https://posit.co/resources/cheatsheets/\n\nR for Data Science (2e): https://r4ds.hadley.nz/\n\nHappy Git with R: https://happygitwithr.com/\n\npalmerpenguins: https://allisonhorst.github.io/palmerpenguins/\nlubridate: https://lubridate.tidyverse.org/\n\n\nNos vemos no Dia 3 para transformação de dados e visualização com ggplot2! 🚀"
  },
  {
    "objectID": "materiais/cronograma.html#instalações-obrigatórias-para-todos-os-sistemas",
    "href": "materiais/cronograma.html#instalações-obrigatórias-para-todos-os-sistemas",
    "title": "Cronograma",
    "section": "Instalações obrigatórias (para todos os sistemas)",
    "text": "Instalações obrigatórias (para todos os sistemas)\n\nR (versão 4.3 ou superior)\nDownload: https://cran.r-project.org/\nRStudio Desktop (2023.09+)\nDownload: https://posit.co/download/rstudio-desktop/\nGit\nWindows: https://git-scm.com/download/win\nmacOS: verifique com git --version (ou use o instalador)\nLinux (Ubuntu/Debian):\nsudo apt update\nsudo apt install git\nConta no GitHub\nhttps://github.com/signup"
  },
  {
    "objectID": "materiais/cronograma.html#instalação-no-dia-1-a-3-núcleo-do-curso",
    "href": "materiais/cronograma.html#instalação-no-dia-1-a-3-núcleo-do-curso",
    "title": "Cronograma",
    "section": "Instalação no Dia 1 a 3 (núcleo do curso)",
    "text": "Instalação no Dia 1 a 3 (núcleo do curso)\ninstall.packages(c(\n  \"tidyverse\", \"here\", \"janitor\", \"skimr\",\n  \"readxl\", \"writexl\", \"rmarkdown\", \"knitr\",\n  \"lubridate\", \"scales\", \"patchwork\", \"broom\",\n  \"palmerpenguins\"\n))"
  },
  {
    "objectID": "materiais/cronograma.html#pacotes-de-ia-dia-4",
    "href": "materiais/cronograma.html#pacotes-de-ia-dia-4",
    "title": "Cronograma",
    "section": "Pacotes de IA (Dia 4)",
    "text": "Pacotes de IA (Dia 4)\ninstall.packages(c(\"gptstudio\", \"chattr\", \"httr2\", \"jsonlite\"))"
  },
  {
    "objectID": "materiais/cronograma.html#h00---20h30-ambientação-e-setup-completo",
    "href": "materiais/cronograma.html#h00---20h30-ambientação-e-setup-completo",
    "title": "Cronograma",
    "section": "19h00 - 20h30 | Ambientação e Setup Completo",
    "text": "19h00 - 20h30 | Ambientação e Setup Completo\nApresentação do curso, objetivos e metodologia.\nPor que R, GitHub e IA.\nChecklist de instalações (R, RStudio, Git).\nConfiguração do Git (user.name/user.email).\nAutenticação no GitHub (PAT recomendado).\nFazer fork do repositório do curso.\nClonar o fork no RStudio (Projeto .Rproj).\nVerificar git remote -v apontando para o fork do aluno."
  },
  {
    "objectID": "materiais/cronograma.html#h30---20h50-intervalo",
    "href": "materiais/cronograma.html#h30---20h50-intervalo",
    "title": "Cronograma",
    "section": "20h30 - 20h50 | Intervalo",
    "text": "20h30 - 20h50 | Intervalo"
  },
  {
    "objectID": "materiais/cronograma.html#h50---22h00-fundamentos-do-r",
    "href": "materiais/cronograma.html#h50---22h00-fundamentos-do-r",
    "title": "Cronograma",
    "section": "20h50 - 22h00 | Fundamentos do R",
    "text": "20h50 - 22h00 | Fundamentos do R\nObjetos e estruturas básicas: vetores, listas, data.frames, fatores.\nFunções básicas: c(), length(), class(), typeof().\nExploração: str(), head(), tail(), names(), dplyr::glimpse(), summary().\nIndexação: [], $, subsetting lógico.\nPrática guiada: criar vetores e data.frames, manipular objetos.\nCommit sugerido:\ngit add scripts/01_fundamentos.R\ngit commit -m \"Fundamentos do R - Dia 1\"\ngit push origin main"
  },
  {
    "objectID": "materiais/cronograma.html#h00---20h30-programação-em-r",
    "href": "materiais/cronograma.html#h00---20h30-programação-em-r",
    "title": "Cronograma",
    "section": "19h00 - 20h30 | Programação em R",
    "text": "19h00 - 20h30 | Programação em R\nOperadores lógicos e relacionais.\nCondicionais: if/else, ifelse() (vetorizado), dplyr::case_when().\nLoops e funções: for vs. vetorização, criação de funções, validação de entradas.\nBoas práticas e debugging: snake_case, comentários, leitura de traceback.\nMini demonstração de como a IA pode explicar um erro simples."
  },
  {
    "objectID": "materiais/cronograma.html#h30---20h50-intervalo-1",
    "href": "materiais/cronograma.html#h30---20h50-intervalo-1",
    "title": "Cronograma",
    "section": "20h30 - 20h50 | Intervalo",
    "text": "20h30 - 20h50 | Intervalo"
  },
  {
    "objectID": "materiais/cronograma.html#h50---22h00-introdução-ao-tidyverse",
    "href": "materiais/cronograma.html#h50---22h00-introdução-ao-tidyverse",
    "title": "Cronograma",
    "section": "20h50 - 22h00 | Introdução ao Tidyverse",
    "text": "20h50 - 22h00 | Introdução ao Tidyverse\nFilosofia tidyverse e uso de pipes (%&gt;% e |&gt;).\nVerbos essenciais do dplyr: filter(), select(), mutate(), arrange(), summarize(), group_by().\nDatas com lubridate: ymd/dmy/mdy, year/month/wday, today/now.\nExemplo integrado com palmerpenguins.\nCommit sugerido:\ngit commit -m \"Lógica, funções e tidyverse - Dia 2\""
  },
  {
    "objectID": "materiais/cronograma.html#h00---20h30-transformação-e-io-de-dados",
    "href": "materiais/cronograma.html#h00---20h30-transformação-e-io-de-dados",
    "title": "Cronograma",
    "section": "19h00 - 20h30 | Transformação e I/O de Dados",
    "text": "19h00 - 20h30 | Transformação e I/O de Dados\nReshape com tidyr: pivot_longer(), pivot_wider(), separate(), unite().\nTratamento de NAs: is.na(), drop_na(), replace_na(), fill().\nLeitura/Escrita: readr::read_csv(), read_csv2(), readxl::read_excel().\nPortabilidade com here::here() e organização de projetos.\nFerramentas úteis: janitor::clean_names(), skimr::skim()."
  },
  {
    "objectID": "materiais/cronograma.html#h30---20h50-intervalo-2",
    "href": "materiais/cronograma.html#h30---20h50-intervalo-2",
    "title": "Cronograma",
    "section": "20h30 - 20h50 | Intervalo",
    "text": "20h30 - 20h50 | Intervalo"
  },
  {
    "objectID": "materiais/cronograma.html#h50---22h00-visualização-com-ggplot2",
    "href": "materiais/cronograma.html#h50---22h00-visualização-com-ggplot2",
    "title": "Cronograma",
    "section": "20h50 - 22h00 | Visualização com ggplot2",
    "text": "20h50 - 22h00 | Visualização com ggplot2\nGramática de gráficos: camadas, aesthetics, geoms comuns.\nGráficos: dispersão, barras, boxplot, linhas, histograma/densidade.\nCombinação com patchwork, formatos com scales.\nPersonalização e salvamento: theme_*, labs(), ggsave().\nCommit sugerido:\ngit commit -m \"Transformação, I/O e visualização - Dia 3\""
  },
  {
    "objectID": "materiais/cronograma.html#h00---19h30-conceitos-e-modelos",
    "href": "materiais/cronograma.html#h00---19h30-conceitos-e-modelos",
    "title": "Cronograma",
    "section": "19h00 - 19h30 | Conceitos e modelos",
    "text": "19h00 - 19h30 | Conceitos e modelos\nPanorama rápido sobre LLMs, APIs, limites e custos.\nBoas práticas de uso responsável de IA: privacidade, dados sensíveis, versionamento de código gerado.\nComparação prática: quando usar ChatGPT e quando usar Claude."
  },
  {
    "objectID": "materiais/cronograma.html#h30---20h15-configuração-de-chaves-e-ambiente",
    "href": "materiais/cronograma.html#h30---20h15-configuração-de-chaves-e-ambiente",
    "title": "Cronograma",
    "section": "19h30 - 20h15 | Configuração de chaves e ambiente",
    "text": "19h30 - 20h15 | Configuração de chaves e ambiente\nVariáveis de ambiente no R: uso de ~/.Renviron e Sys.getenv().\nCriação de chaves de API e configuração local.\nNomes convencionados: - OPENAI_API_KEY para ChatGPT (OpenAI) - ANTHROPIC_API_KEY para Claude (Anthropic)\nExemplo de ~/.Renviron:\nOPENAI_API_KEY=coloque_sua_chave_aqui\nANTHROPIC_API_KEY=coloque_sua_chave_aqui\nTeste rápido no R:\nSys.getenv(\"OPENAI_API_KEY\")\nSys.getenv(\"ANTHROPIC_API_KEY\")\nInstalação de pacotes:\ninstall.packages(c(\"gptstudio\", \"chattr\", \"httr2\", \"jsonlite\"))"
  },
  {
    "objectID": "materiais/cronograma.html#h15---20h30-intervalo",
    "href": "materiais/cronograma.html#h15---20h30-intervalo",
    "title": "Cronograma",
    "section": "20h15 - 20h30 | Intervalo",
    "text": "20h15 - 20h30 | Intervalo"
  },
  {
    "objectID": "materiais/cronograma.html#h30---21h00-rstudio-gptstudio-chatgpt",
    "href": "materiais/cronograma.html#h30---21h00-rstudio-gptstudio-chatgpt",
    "title": "Cronograma",
    "section": "20h30 - 21h00 | RStudio + gptstudio (ChatGPT)",
    "text": "20h30 - 21h00 | RStudio + gptstudio (ChatGPT)\nAbertura dos Addins do gptstudio no RStudio (chat pane e code assistant).\nUso no editor: seleção de código e prompt de revisão.\nExemplos típicos: explicar erro, refatorar função, gerar testes unitários simples.\nScript de exemplo (via API manual com httr2):\nlibrary(httr2); library(jsonlite)\n\nendpoint &lt;- \"https://api.openai.com/v1/chat/completions\"\nprompt &lt;- \"Explique o que este código faz e sugira melhorias:\\n\\nx &lt;- 1:10; mean(x)\"\nbody &lt;- list(\n  model = \"gpt-4o-mini\",\n  messages = list(list(role=\"user\", content=prompt))\n)\n\nreq &lt;- request(endpoint) |&gt;\n  req_method(\"POST\") |&gt;\n  req_headers(Authorization = paste(\"Bearer\", Sys.getenv(\"OPENAI_API_KEY\"))) |&gt;\n  req_body_json(body)\n\nresp &lt;- req_perform(req)\njson &lt;- resp_body_json(resp)\ncat(json$choices[[1]]$message$content)"
  },
  {
    "objectID": "materiais/cronograma.html#h00---21h30-rstudio-chattr-claude",
    "href": "materiais/cronograma.html#h00---21h30-rstudio-chattr-claude",
    "title": "Cronograma",
    "section": "21h00 - 21h30 | RStudio + chattr (Claude)",
    "text": "21h00 - 21h30 | RStudio + chattr (Claude)\nFluxo básico com chattr::chat_claude().\nExemplos práticos: explicar um traceback, sugerir validação de argumentos, gerar esqueleto de RMarkdown.\nScript de exemplo (API manual com httr2):\nlibrary(httr2); library(jsonlite)\n\nendpoint &lt;- \"https://api.anthropic.com/v1/messages\"\nprompt &lt;- \"Revise a função abaixo e a torne mais robusta a NAs.\\n\\nsoma_media &lt;- function(x){ sum(x)/length(x) }\"\n\nbody &lt;- list(\n  model = \"claude-3-5-sonnet-latest\",\n  max_tokens = 300,\n  messages = list(list(role=\"user\", content=prompt))\n)\n\nreq &lt;- request(endpoint) |&gt;\n  req_method(\"POST\") |&gt;\n  req_headers(\n    Authorization = paste(\"Bearer\", Sys.getenv(\"ANTHROPIC_API_KEY\")),\n    \"anthropic-version\" = \"2023-06-01\",\n    \"content-type\" = \"application/json\"\n  ) |&gt;\n  req_body_json(body)\n\nresp &lt;- req_perform(req)\njson &lt;- resp_body_json(resp)\ncat(json$content[[1]]$text)"
  },
  {
    "objectID": "materiais/cronograma.html#h30---22h00-exercício-guiado-de-integração",
    "href": "materiais/cronograma.html#h30---22h00-exercício-guiado-de-integração",
    "title": "Cronograma",
    "section": "21h30 - 22h00 | Exercício guiado de integração",
    "text": "21h30 - 22h00 | Exercício guiado de integração\nTarefa 1: usar gptstudio para revisar um script curto de dplyr e propor 2 melhorias.\nTarefa 2: usar chattr para gerar uma função em R que: - receba um data.frame e uma coluna numérica - remova NAs, retorne média e desvio-padrão com nomes claros - inclua validação de tipos e mensagens de erro úteis\nEntrega esperada no fork do aluno: - scripts/04_ia_integracao_gptstudio.R - scripts/04_ia_integracao_claude.R - docs/relatorio_ia.Rmd com um parágrafo descrevendo o que a IA sugeriu, o que foi adotado e por quê.\nChecklist final: - variáveis de ambiente lidas com Sys.getenv() - addins do gptstudio funcionando - chamada mínima via httr2 para cada API - commit e push no fork\ngit add scripts/04_*.R docs/relatorio_ia.Rmd\ngit commit -m \"Integração ChatGPT e Claude no RStudio (Dia 4)\"\ngit push origin main"
  },
  {
    "objectID": "materiais/cronograma.html#windows",
    "href": "materiais/cronograma.html#windows",
    "title": "Cronograma",
    "section": "Windows",
    "text": "Windows\nGit não encontrado: reinstalar Git (opção Git from the command line…).\nAcentos estranhos: garantir UTF-8 ao salvar, ou usar locale(encoding=“latin1”) quando necessário.\nPacotes com erro: tentar instalar na biblioteca do usuário."
  },
  {
    "objectID": "materiais/cronograma.html#macos",
    "href": "materiais/cronograma.html#macos",
    "title": "Cronograma",
    "section": "macOS",
    "text": "macOS\nxcrun error com Git: xcode-select --install\nLaTeX não encontrado: tinytex::install_tinytex()"
  },
  {
    "objectID": "materiais/cronograma.html#linux-ubuntudebian",
    "href": "materiais/cronograma.html#linux-ubuntudebian",
    "title": "Cronograma",
    "section": "Linux (Ubuntu/Debian)",
    "text": "Linux (Ubuntu/Debian)\nCompilação de pacotes:\nsudo apt install build-essential libcurl4-openssl-dev libssl-dev libxml2-dev\nsudo apt install libfontconfig1-dev libharfbuzz-dev libfribidi-dev"
  },
  {
    "objectID": "materiais/cronograma.html#problemas-comuns-todos-os-so",
    "href": "materiais/cronograma.html#problemas-comuns-todos-os-so",
    "title": "Cronograma",
    "section": "Problemas comuns (todos os SO)",
    "text": "Problemas comuns (todos os SO)\nPermission denied ao fazer push: corrigir origin para o fork do aluno:\ngit remote set-url origin https://github.com/SEU-USUARIO/curso-r-github-ia.git\nAPI Key não encontrada: configurar no ~/.Renviron e reiniciar o R."
  },
  {
    "objectID": "materiais.html",
    "href": "materiais.html",
    "title": "Materiais do Curso",
    "section": "",
    "text": "Apostila completa\nCronograma"
  },
  {
    "objectID": "materiais.html#pdfs",
    "href": "materiais.html#pdfs",
    "title": "Materiais do Curso",
    "section": "",
    "text": "Apostila completa\nCronograma"
  },
  {
    "objectID": "materiais.html#pastas-e-dados",
    "href": "materiais.html#pastas-e-dados",
    "title": "Materiais do Curso",
    "section": "Pastas e dados",
    "text": "Pastas e dados\n\nmateriais/ – dados e exemplos"
  },
  {
    "objectID": "materiais.html#notas-em-r-markdown",
    "href": "materiais.html#notas-em-r-markdown",
    "title": "Materiais do Curso",
    "section": "Notas em R Markdown",
    "text": "Notas em R Markdown\nListe aqui os .Rmd que você quer publicar como páginas: - 01-introducao.Rmd - 02-basico.Rmd"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à Programação em R",
    "section": "",
    "text": "Bem-vindo! Aqui você encontra a organização do curso, links para a apostila, códigos e vídeos.\n\nApostila (PDF): curso_completo_master.pdf\nCronograma (PDF): cronograma.pdf\nRepositório no GitHub: https://github.com/viniciusjunqueira/curso-r-github-ia\n\nVeja também: Materiais e códigos"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html",
    "href": "materiais/dia3_manipulacao.html",
    "title": "Dia 3",
    "section": "",
    "text": "Objetivos do dia\n\nTransformar dados com tidyr (pivot, separate, unite)\nTratar valores ausentes adequadamente\nLer e escrever dados de diferentes formatos (CSV, Excel)\nOrganizar projetos com here::here()\nCriar visualizações profissionais com ggplot2\nCombinar gráficos e personalizar temas\n\n\nTempo previsto: 19h00–22h00 (intervalo 20h30–20h50)\n\n\n\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n# Pipeline básico com dplyr (revisão)\npenguins %&gt;%\n  filter(!is.na(bill_length_mm)) %&gt;%\n  select(species, island, bill_length_mm, body_mass_g) %&gt;%\n  mutate(massa_kg = body_mass_g / 1000) %&gt;%\n  group_by(species) %&gt;%\n  summarize(\n    n = n(),\n    media_bico = mean(bill_length_mm),\n    media_massa = mean(massa_kg)\n  ) %&gt;%\n  arrange(desc(media_massa))"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#revisão-rápida-do-dia-2-10-min",
    "href": "materiais/dia3_manipulacao.html#revisão-rápida-do-dia-2-10-min",
    "title": "Dia 3",
    "section": "",
    "text": "library(tidyverse)\nlibrary(palmerpenguins)\n\n# Pipeline básico com dplyr (revisão)\npenguins %&gt;%\n  filter(!is.na(bill_length_mm)) %&gt;%\n  select(species, island, bill_length_mm, body_mass_g) %&gt;%\n  mutate(massa_kg = body_mass_g / 1000) %&gt;%\n  group_by(species) %&gt;%\n  summarize(\n    n = n(),\n    media_bico = mean(bill_length_mm),\n    media_massa = mean(massa_kg)\n  ) %&gt;%\n  arrange(desc(media_massa))"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#tidyr-transformando-estruturas-de-dados",
    "href": "materiais/dia3_manipulacao.html#tidyr-transformando-estruturas-de-dados",
    "title": "Dia 3",
    "section": "1.1 Tidyr: Transformando estruturas de dados",
    "text": "1.1 Tidyr: Transformando estruturas de dados\n\nO que é Tidyr?\ntidyr é o pacote para reorganizar a estrutura dos seus dados. É essencial porque muitas vezes recebemos dados em formatos “bagunçados” (como planilhas do Excel) e precisamos transformá-los em formato “tidy” para análise.\nPrincipais funções:\n\npivot_longer() / pivot_wider(): converter entre formatos wide ↔︎ long\nseparate() / unite(): dividir ou unir colunas\ndrop_na(), replace_na(), fill(): tratar valores ausentes\n\n\n\npivot_longer(): Wide para Long\nO que faz: Transforma múltiplas colunas em duas novas colunas: uma com os nomes das colunas originais e outra com seus valores.\nQuando usar: Quando você tem múltiplas colunas que na verdade representam valores de uma mesma variável. Por exemplo, se você tem colunas “jan_2024”, “fev_2024”, “mar_2024”, elas na verdade representam valores de uma variável “mês”.\nPor que usar: Dados no formato long (tidy) facilitam muito análises com dplyr e visualizações com ggplot2.\n\n# Dados em formato WIDE (comum em planilhas)\nvendas_wide &lt;- tibble(\n  produto = c(\"Notebook\", \"Mouse\", \"Teclado\"),\n  jan_2024 = c(150, 320, 180),\n  fev_2024 = c(180, 350, 200),\n  mar_2024 = c(160, 380, 190)\n)\n\nvendas_wide\n\n# Transformar para LONG (formato tidy)\nvendas_long &lt;- vendas_wide %&gt;%\n  pivot_longer(\n    cols = jan_2024:mar_2024,        # Colunas para transformar\n    names_to = \"mes_ano\",             # Nome da nova coluna de categorias\n    values_to = \"quantidade\"          # Nome da nova coluna de valores\n  )\n\nvendas_long\n\n# Limpar a coluna mes_ano\nvendas_long &lt;- vendas_long %&gt;%\n  separate(mes_ano, into = c(\"mes\", \"ano\"), sep = \"_\") %&gt;%\n  mutate(\n    mes = case_when(\n      mes == \"jan\" ~ \"Janeiro\",\n      mes == \"fev\" ~ \"Fevereiro\",\n      mes == \"mar\" ~ \"Março\"\n    ),\n    ano = as.numeric(ano)\n  )\n\nvendas_long\n\n# Agora análises ficam fáceis!\nvendas_long %&gt;%\n  group_by(produto) %&gt;%\n  summarize(\n    total = sum(quantidade),\n    media = mean(quantidade)\n  )\n\n\n\npivot_wider(): Long para Wide\nO que faz: Transforma duas colunas (uma de categorias e outra de valores) em múltiplas colunas, onde cada categoria vira uma coluna.\nQuando usar: - Para criar tabelas de resumo mais legíveis (formato “planilha”) - Quando você precisa de uma coluna separada para cada categoria - Para preparar dados para certas análises ou relatórios\nÉ o inverso do pivot_longer()!\n\n# Reverter para wide\nvendas_long %&gt;%\n  unite(\"periodo\", mes, ano, sep = \"_\") %&gt;%  # Unir mês e ano\n  pivot_wider(\n    names_from = periodo,\n    values_from = quantidade\n  )\n\n# Exemplo prático: notas de alunos\nnotas_long &lt;- tibble(\n  aluno = rep(c(\"Ana\", \"Bruno\", \"Carla\"), each = 3),\n  disciplina = rep(c(\"Matemática\", \"Português\", \"História\"), 3),\n  nota = c(8.5, 9.0, 7.5, 7.0, 8.0, 8.5, 9.5, 8.5, 9.0)\n)\n\nnotas_long\n\n# Transformar: disciplinas viram colunas\nnotas_wide &lt;- notas_long %&gt;%\n  pivot_wider(\n    names_from = disciplina,\n    values_from = nota\n  )\n\nnotas_wide\n\n\n\nseparate() e unite()\nseparate(): Divide uma coluna em múltiplas colunas usando um separador.\nQuando usar separate(): - Quando você tem informações combinadas em uma única coluna (ex: “São Paulo-SP”) - Para extrair partes específicas de um texto (ex: dia, mês, ano de uma data) - Para limpar dados mal formatados\nArgumentos principais: - col: coluna a ser dividida - into: vetor com nomes das novas colunas - sep: separador (pode ser um caractere ou regex) - extra: o que fazer com pedaços extras (“warn”, “drop”, “merge”)\nunite(): Combina múltiplas colunas em uma única coluna.\nQuando usar unite(): - Para criar identificadores únicos combinando campos (ex: “SP_001”) - Para formatar datas ou textos de maneira específica - Para reverter um separate() anterior\nArgumentos principais: - col: nome da nova coluna - ...: colunas a combinar - sep: separador para usar na união\n\n# Dados com informação combinada\ndados &lt;- tibble(\n  nome_completo = c(\"Ana Silva\", \"Bruno Costa\", \"Carla Dias\"),\n  data_nasc = c(\"15/03/1995\", \"22/07/1998\", \"10/11/1993\"),\n  cidade_estado = c(\"São Paulo-SP\", \"Rio de Janeiro-RJ\", \"Belo Horizonte-MG\")\n)\n\ndados\n\n# SEPARATE: dividir colunas\ndados_separados &lt;- dados %&gt;%\n  separate(nome_completo, into = c(\"nome\", \"sobrenome\"), sep = \" \") %&gt;%\n  separate(data_nasc, into = c(\"dia\", \"mes\", \"ano\"), sep = \"/\") %&gt;%\n  separate(cidade_estado, into = c(\"cidade\", \"estado\"), sep = \"-\")\n\ndados_separados\n\n# UNITE: combinar colunas\ndados_unidos &lt;- dados_separados %&gt;%\n  unite(\"nome_completo\", nome, sobrenome, sep = \" \") %&gt;%\n  unite(\"data_nascimento\", dia, mes, ano, sep = \"/\")\n\ndados_unidos\n\n# Exemplo prático: limpar dados de telefone\ntelefones &lt;- tibble(\n  cliente = c(\"João\", \"Maria\", \"Pedro\"),\n  telefone = c(\"11-98765-4321\", \"21-99876-5432\", \"31-97654-3210\")\n)\n\ntelefones %&gt;%\n  separate(telefone, into = c(\"ddd\", \"numero\"), sep = \"-\", extra = \"merge\")"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#tratamento-de-valores-ausentes-na",
    "href": "materiais/dia3_manipulacao.html#tratamento-de-valores-ausentes-na",
    "title": "Dia 3",
    "section": "1.2 Tratamento de Valores Ausentes (NA)",
    "text": "1.2 Tratamento de Valores Ausentes (NA)\nO que são NAs?\nNA (Not Available) representa valores ausentes ou desconhecidos em R. Eles aparecem por diversos motivos: - Dados não coletados - Informação não disponível - Erros na coleta - Junção de tabelas sem correspondência\nPor que tratar NAs é importante?\n\nMuitas funções retornam NA se houver qualquer NA nos dados\nNAs podem distorcer análises estatísticas\nAlguns modelos não aceitam NAs\nÉ importante decidir conscientemente o que fazer com dados ausentes\n\nTrês estratégias principais: 1. Identificar: entender onde e quantos NAs existem 2. Remover: excluir linhas/colunas com NAs (quando apropriado) 3. Imputar: substituir NAs por valores estimados\n\nIdentificar NAs\nFunções úteis: - is.na(): retorna TRUE/FALSE para cada elemento - sum(is.na()): conta quantos NAs existem - mean(is.na()): proporção de NAs - complete.cases(): identifica linhas sem nenhum NA\n\n# Criar dados com NA para exemplo\ndados_na &lt;- tibble(\n  id = 1:10,\n  nome = c(\"Ana\", \"Bruno\", NA, \"Diego\", \"Elena\", \"Felipe\", NA, \"Hugo\", \"Iris\", \"João\"),\n  idade = c(25, NA, 30, 28, NA, 35, 22, NA, 27, 29),\n  salario = c(3000, 4500, NA, 5000, 3500, NA, 4000, 4800, NA, 5200)\n)\n\ndados_na\n\n# Contar NAs por coluna\ndados_na %&gt;%\n  summarize(across(everything(), ~sum(is.na(.))))\n\n# Proporção de NAs\ndados_na %&gt;%\n  summarize(across(everything(), ~mean(is.na(.)) * 100))\n\n# Identificar linhas com qualquer NA\ndados_na %&gt;%\n  filter(if_any(everything(), is.na))\n\n# Identificar linhas completas (sem NA)\ndados_na %&gt;%\n  filter(if_all(everything(), ~!is.na(.)))\n\n\n\nRemover NAs\nQuando remover NAs: - Quando representam uma porção pequena dos dados (&lt; 5%) - Quando são aleatórios (não há padrão sistemático) - Quando você tem dados suficientes mesmo após remoção\nCuidado: Remover NAs pode introduzir viés se eles não forem aleatórios!\nFunções: - drop_na(): remove linhas com qualquer NA (ou em colunas específicas) - na.omit(): similar ao drop_na (base R) - filter(!is.na()): remove NAs de colunas específicas\n\n# Remover linhas com QUALQUER NA\ndados_na %&gt;%\n  drop_na()\n\n# Remover linhas com NA em colunas específicas\ndados_na %&gt;%\n  drop_na(idade, salario)\n\n# Manter apenas linhas completas\ndados_na %&gt;%\n  na.omit()  # base R\n\n\n\nSubstituir NAs\nMétodos de imputação (substituição):\n\nValor fixo: substituir por 0, “Desconhecido”, etc.\n\nUse quando o NA tem significado específico (ex: ausência = zero)\n\nMedida central: substituir por média, mediana ou moda\n\nUse para variáveis numéricas quando NAs são poucos e aleatórios\nMediana é mais robusta a outliers que média\n\nForward/Backward fill: usar valor anterior ou posterior\n\nUse para séries temporais ou dados sequenciais\nfill(.direction = \"down\"): preenche para baixo\nfill(.direction = \"up\"): preenche para cima\n\nInterpolação: estimar baseado em valores próximos\n\nUse para séries temporais quando há padrão\nMais sofisticado que fill\n\n\nFunções: - replace_na(): substitui por valor específico - ifelse() + mean()/median(): substitui por estatística - fill(): preenche com valores adjacentes\n\n# Substituir por valor específico\ndados_na %&gt;%\n  mutate(\n    nome = replace_na(nome, \"Desconhecido\"),\n    idade = replace_na(idade, 0)\n  )\n\n# Substituir por medida central\ndados_na %&gt;%\n  mutate(\n    idade = ifelse(is.na(idade), median(idade, na.rm = TRUE), idade),\n    salario = ifelse(is.na(salario), mean(salario, na.rm = TRUE), salario)\n  )\n\n# Preencher com valor anterior/posterior (fill)\ndados_sequencial &lt;- tibble(\n  mes = 1:12,\n  vendas = c(100, 120, NA, NA, 150, NA, 170, 180, NA, 200, 210, NA)\n)\n\ndados_sequencial\n\n# Preencher para baixo (forward fill)\ndados_sequencial %&gt;%\n  fill(vendas, .direction = \"down\")\n\n# Preencher para cima (backward fill)\ndados_sequencial %&gt;%\n  fill(vendas, .direction = \"up\")\n\n# Interpolação linear (mais sofisticado)\ndados_sequencial %&gt;%\n  mutate(vendas = zoo::na.approx(vendas, na.rm = FALSE))"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#leitura-e-escrita-de-dados-io",
    "href": "materiais/dia3_manipulacao.html#leitura-e-escrita-de-dados-io",
    "title": "Dia 3",
    "section": "1.3 Leitura e Escrita de Dados (I/O)",
    "text": "1.3 Leitura e Escrita de Dados (I/O)\nI/O = Input/Output (Entrada/Saída)\nA capacidade de ler e escrever arquivos é fundamental para qualquer análise de dados. Você precisará: - Importar dados de diversas fontes (CSV, Excel, bancos de dados) - Exportar resultados para compartilhar ou usar em outras ferramentas\n\nPor que usar readr em vez de funções base do R?\nreadr (parte do tidyverse) é melhor porque: - ✅ Mais rápido (até 10x) - ✅ Produz tibbles em vez de data.frames - ✅ Não converte strings em fatores automaticamente - ✅ Melhor tratamento de encoding (acentos!) - ✅ Mensagens mais claras sobre tipos de colunas - ✅ Sintaxe consistente e intuitiva\n\n\nLeitura de arquivos CSV\nCSV = Comma-Separated Values (Valores Separados por Vírgula)\nÉ o formato mais comum para dados tabulares. Mas atenção: existem variações!\nread_csv(): Para arquivos com separador vírgula (padrão internacional) - Exemplo: 1,2,3 - Decimal com ponto: 3.14\nread_csv2(): Para arquivos com separador ponto-e-vírgula (padrão brasileiro) - Exemplo: 1;2;3 - Decimal com vírgula: 3,14\nParâmetros importantes: - col_types: especificar tipos das colunas (evita surpresas) - locale: controlar encoding e formatos regionais - skip: pular linhas iniciais (cabeçalhos, notas) - n_max: ler apenas primeiras linhas (para testar) - na: definir quais valores representam NA\n\nlibrary(readr)\nlibrary(here)\n\n# Ler CSV com separador vírgula (padrão internacional)\n# dados &lt;- read_csv(here(\"data\", \"raw\", \"dados.csv\"))\n\n# Ler CSV com separador ponto-e-vírgula (padrão brasileiro)\n# dados &lt;- read_csv2(here(\"data\", \"raw\", \"dados.csv\"))\n\n# Especificar encoding (importante para acentos!)\n# dados &lt;- read_csv(\n#   here(\"data\", \"raw\", \"dados.csv\"),\n#   locale = locale(encoding = \"UTF-8\")\n# )\n\n# Para arquivos com encoding Windows (latin1)\n# dados &lt;- read_csv(\n#   here(\"data\", \"raw\", \"dados.csv\"),\n#   locale = locale(encoding = \"latin1\")\n# )\n\n# Especificar tipos de colunas\n# dados &lt;- read_csv(\n#   here(\"data\", \"raw\", \"dados.csv\"),\n#   col_types = cols(\n#     id = col_integer(),\n#     nome = col_character(),\n#     data = col_date(format = \"%d/%m/%Y\"),\n#     valor = col_double()\n#   )\n# )\n\n# Pular linhas iniciais\n# dados &lt;- read_csv(here(\"data\", \"raw\", \"dados.csv\"), skip = 2)\n\n# Ler apenas primeiras linhas (para testar)\n# dados_preview &lt;- read_csv(here(\"data\", \"raw\", \"dados.csv\"), n_max = 100)\n\n\n\nO problema do encoding (acentuação)\nEncoding define como caracteres especiais (acentos, ç, etc.) são armazenados.\nProblemas comuns: - Arquivo criado no Windows → ler no Mac/Linux → acentos aparecem como � - Excel salva em encoding diferente → R lê errado → “São Paulo” vira “SÃ£o Paulo”\nSoluções: - UTF-8: padrão universal moderno - SEMPRE use para novos arquivos - latin1 (ISO-8859-1): comum em arquivos Windows antigos - Use locale(encoding = \"...\") para especificar\nComo descobrir o encoding? 1. Abra o arquivo no RStudio e veja se acentos estão corretos 2. Teste UTF-8 primeiro, depois latin1 3. Use guess_encoding() do readr para ajudar\n\n\nLeitura de arquivos Excel\nPor que ler Excel? - Formato muito usado em empresas e pesquisas - Pode conter múltiplas planilhas - Formatação e fórmulas (que precisamos extrair)\nreadxl vs writexl: - readxl: LER arquivos Excel (.xlsx, .xls) - writexl: ESCREVER arquivos Excel\nVantagens do readxl: - ✅ Não precisa de Java ou Excel instalado - ✅ Funciona em Windows, Mac e Linux - ✅ Lê .xlsx (novo) e .xls (antigo) - ✅ Preserva tipos de dados\nParâmetros úteis: - sheet: qual planilha ler (por nome ou número) - range: ler apenas parte da planilha (ex: “A1:E100”) - skip: pular linhas iniciais - col_names: se primeira linha tem nomes das colunas - na: valores que devem ser tratados como NA\n\nlibrary(readxl)\n\n# Ler primeira planilha\n# dados &lt;- read_excel(here(\"data\", \"raw\", \"planilha.xlsx\"))\n\n# Especificar planilha por nome ou número\n# dados &lt;- read_excel(here(\"data\", \"raw\", \"planilha.xlsx\"), sheet = \"Vendas\")\n# dados &lt;- read_excel(here(\"data\", \"raw\", \"planilha.xlsx\"), sheet = 2)\n\n# Especificar intervalo de células\n# dados &lt;- read_excel(\n#   here(\"data\", \"raw\", \"planilha.xlsx\"), \n#   range = \"A1:E100\"\n# )\n\n# Pular linhas\n# dados &lt;- read_excel(here(\"data\", \"raw\", \"planilha.xlsx\"), skip = 3)\n\n# Ver nomes das planilhas\n# excel_sheets(here(\"data\", \"raw\", \"planilha.xlsx\"))\n\n\n\nEscrita de dados\nPor que exportar dados? - Compartilhar resultados com colegas - Backup de dados processados - Usar em outras ferramentas (Excel, Power BI, Python) - Guardar resultados intermediários de análises longas\nFormatos e quando usar:\n\nCSV (write_csv, write_csv2):\n\n✅ Universal - abre em qualquer programa\n✅ Tamanho pequeno (texto simples)\n❌ Não preserva formatação\n❌ Problemas com encoding\nUse para: compartilhar dados simples\n\nExcel (write_xlsx):\n\n✅ Fácil para não-programadores abrirem\n✅ Mantém formatação básica\n❌ Tamanho maior que CSV\nUse para: relatórios para stakeholders\n\nRDS (saveRDS, readRDS):\n\n✅ Preserva tipos de dados perfeitamente\n✅ Comprimido (tamanho pequeno)\n✅ Rápido para ler/escrever\n❌ Só abre no R\nUse para: dados intermediários, objetos R complexos\n\n\nDica: Sempre salve dados originais em data/raw/ e processados em data/processed/\n\n\nOrganização de Projetos com here()\nO problema dos caminhos:\nCaminho absoluto (❌ NÃO USAR):\ndados &lt;- read_csv(\"C:/Users/vinicius/Documents/projeto/data/dados.csv\")\nProblema: Só funciona no SEU computador!\nCaminho relativo com setwd() (❌ EVITAR):\nsetwd(\"C:/Users/vinicius/Documents/projeto\")\ndados &lt;- read_csv(\"data/dados.csv\")\nProblema: Frágil, não funciona em scripts executados de outros lugares\nA solução: here() (✅ SEMPRE USAR)\ndados &lt;- read_csv(here(\"data\", \"dados.csv\"))\nVantagens do here(): - ✅ Funciona em Windows, Mac e Linux - ✅ Funciona independente de onde você executa o script - ✅ Colaboração: código funciona para todos - ✅ Raiz do projeto é detectada automaticamente (.Rproj)\nComo funciona: 1. here() encontra a raiz do projeto (onde está o .Rproj) 2. Constrói caminhos a partir dessa raiz 3. Usa separadores corretos para cada sistema operacional\nEstrutura recomendada de projeto:\nmeu-projeto/\n├── meu-projeto.Rproj    ← here() usa isso como raiz\n├── data/\n│   ├── raw/             ← Dados originais (NUNCA modificar!)\n│   └── processed/       ← Dados processados/limpos\n├── scripts/             ← Scripts de análise\n├── output/\n│   ├── figures/         ← Gráficos salvos\n│   └── tables/          ← Tabelas exportadas\n├── docs/                ← Relatórios e documentação\n└── README.md            ← Descrição do projeto\nBoas práticas: - Sempre use projetos .Rproj - Sempre use here() para caminhos - Nunca modifique dados em data/raw/ - Documente estrutura no README.md\n\n# Criar dados de exemplo\ndados_exemplo &lt;- tibble(\n  id = 1:5,\n  nome = c(\"Ana\", \"Bruno\", \"Carla\", \"Diego\", \"Elena\"),\n  nota = c(8.5, 7.0, 9.0, 6.5, 8.0)\n)\n\n# Salvar como CSV (UTF-8)\n# write_csv(dados_exemplo, here(\"output\", \"tables\", \"notas.csv\"))\n\n# Salvar como CSV com separador ponto-e-vírgula\n# write_csv2(dados_exemplo, here(\"output\", \"tables\", \"notas.csv\"))\n\n# Salvar como Excel (requer writexl)\n# library(writexl)\n# write_xlsx(dados_exemplo, here(\"output\", \"tables\", \"notas.xlsx\"))\n\n# Salvar como RDS (formato nativo R - preserva tipos)\n# saveRDS(dados_exemplo, here(\"output\", \"tables\", \"notas.rds\"))\n\n# Ler RDS\n# dados &lt;- readRDS(here(\"output\", \"tables\", \"notas.rds\"))\n\n\n\nOrganização de Projetos com here()\nPor que usar here()?\nO pacote here resolve caminhos relativos de forma portável, funcionando em qualquer sistema operacional e evitando problemas com diretórios de trabalho.\n\nlibrary(here)\n\n# Estrutura recomendada de projeto:\n# meu-projeto/\n# ├── meu-projeto.Rproj\n# ├── data/\n# │   ├── raw/          # Dados originais (nunca modificar!)\n# │   └── processed/    # Dados processados\n# ├── scripts/          # Scripts R\n# ├── output/\n# │   ├── figures/      # Gráficos\n# │   └── tables/       # Tabelas\n# ├── docs/             # Documentação e relatórios\n# └── README.md\n\n# Ver raiz do projeto\nhere()\n\n# Construir caminhos portáveis\nhere(\"data\", \"raw\", \"dados.csv\")\nhere(\"output\", \"figures\", \"grafico1.png\")\nhere(\"scripts\", \"01_analise.R\")\n\n# Exemplo de uso completo\n# dados &lt;- read_csv(here(\"data\", \"raw\", \"vendas.csv\"))\n# \n# dados_processados &lt;- dados %&gt;%\n#   filter(ano == 2024) %&gt;%\n#   mutate(vendas_milhares = vendas / 1000)\n# \n# write_csv(dados_processados, here(\"data\", \"processed\", \"vendas_2024.csv\"))"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#ferramentas-úteis",
    "href": "materiais/dia3_manipulacao.html#ferramentas-úteis",
    "title": "Dia 3",
    "section": "1.4 Ferramentas Úteis",
    "text": "1.4 Ferramentas Úteis\n\njanitor: Limpeza de dados\nO que é janitor?\njanitor é um pacote focado em limpar dados bagunçados - especialmente aqueles que vêm de planilhas Excel criadas por humanos (não por programas).\nProblemas comuns que janitor resolve: - Nomes de colunas com espaços, acentos, caracteres especiais - Linhas e colunas completamente vazias - Linhas duplicadas - Formatação inconsistente\nPrincipais funções:\n1. clean_names(): Limpa nomes de colunas automaticamente - Remove espaços → substitui por _ - Remove acentos e caracteres especiais - Converte tudo para minúsculas - Formato snake_case - Use sempre que importar dados de Excel!\n2. tabyl(): Tabelas de frequência melhoradas - Mais informativa que table() do R base - Funciona bem com pipes - Fácil adicionar percentuais e totais\n3. adorn_*: Funções para embelezar tabelas - adorn_percentages(): adiciona percentuais - adorn_pct_formatting(): formata percentuais - adorn_ns(): mostra contagens junto com percentuais - adorn_totals(): adiciona linha/coluna de totais\n4. remove_empty(): Remove linhas/colunas vazias - Comum em dados de Excel com células vazias fantasmas - remove_empty(\"rows\"): remove linhas vazias - remove_empty(\"cols\"): remove colunas vazias - remove_empty(c(\"rows\", \"cols\")): remove ambos\n5. get_dupes(): Encontra linhas duplicadas - Mostra quais linhas estão duplicadas - Mais informativo que duplicated()\n\n\nskimr: Exploração rápida\nO que é skimr?\nskimr fornece resumos estatísticos completos de forma rápida e visual - muito melhor que summary() do R base.\nVantagens do skim(): - ✅ Um resumo por tipo de variável (numérico, texto, data, etc.) - ✅ Mostra quantidade de dados ausentes - ✅ Histogramas inline (mini-histogramas na tabela!) - ✅ Estatísticas relevantes automaticamente - ✅ Funciona com group_by() para resumos por grupo - ✅ Output limpo e organizado\nO que skim() mostra:\nPara variáveis numéricas: - n_missing: quantos NAs - complete_rate: % de valores completos - mean, sd: média e desvio padrão - p0, p25, p50, p75, p100: percentis (min, Q1, mediana, Q3, max) - hist: mini-histograma visual!\nPara variáveis de texto: - n_missing, complete_rate - min, max: comprimento mínimo/máximo - empty: quantas strings vazias - n_unique: quantos valores únicos\nPara variáveis lógicas: - mean: proporção de TRUEs - count: contagem de TRUE/FALSE\nUso típico:\n# Exploração inicial rápida\ndados %&gt;% skim()\n\n# Por grupo\ndados %&gt;% group_by(categoria) %&gt;% skim()\n\n# Apenas numéricos\ndados %&gt;% skim() %&gt;% filter(skim_type == \"numeric\")\nQuando usar: - Primeira exploração de um dataset novo - Checagem rápida de qualidade dos dados - Identificação de outliers e problemas - Documentação de características dos dados\n\nlibrary(janitor)\n\n# Dados bagunçados (comum em planilhas)\ndados_sujos &lt;- tibble(\n  `Nome Completo` = c(\"Ana Silva\", \"Bruno Costa\"),\n  `Idade (anos)` = c(25, 30),\n  `Salário Mensal (R$)` = c(5000, 6000),\n  `E-mail!!!` = c(\"ana@email.com\", \"bruno@email.com\")\n)\n\ndados_sujos\n\n# Limpar nomes de colunas automaticamente\ndados_limpos &lt;- dados_sujos %&gt;%\n  clean_names()\n\ndados_limpos\nnames(dados_limpos)\n\n# Tabulação cruzada melhorada\npenguins %&gt;%\n  tabyl(species, island) %&gt;%\n  adorn_percentages(\"row\") %&gt;%\n  adorn_pct_formatting() %&gt;%\n  adorn_ns()\n\n# Remover linhas/colunas completamente vazias\ndados_com_vazios &lt;- tibble(\n  a = c(1, 2, NA, 4),\n  b = c(NA, NA, NA, NA),  # Coluna vazia\n  c = c(5, 6, 7, 8)\n)\n\ndados_com_vazios %&gt;%\n  remove_empty(c(\"rows\", \"cols\"))\n\n\n\nskimr: Exploração rápida\n\nlibrary(skimr)\n\n# Resumo estatístico completo\npenguins %&gt;%\n  skim()\n\n# Por grupo\npenguins %&gt;%\n  group_by(species) %&gt;%\n  skim()\n\n# Customizar saída\npenguins %&gt;%\n  skim() %&gt;%\n  filter(skim_type == \"numeric\") %&gt;%\n  select(skim_variable, n_missing, numeric.mean, numeric.sd)"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#gramática-de-gráficos",
    "href": "materiais/dia3_manipulacao.html#gramática-de-gráficos",
    "title": "Dia 3",
    "section": "2.1 Gramática de Gráficos",
    "text": "2.1 Gramática de Gráficos\n\nO que é ggplot2?\nggplot2 é um sistema de visualização baseado na “Grammar of Graphics” (Gramática de Gráficos) - uma filosofia que trata gráficos como sentenças construídas por camadas.\nPor que ggplot2 é revolucionário? - Você descreve o que quer ver, não como desenhar - Gráficos complexos são combinações de camadas simples - Consistência: mesma lógica para todos os tipos de gráficos - Flexibilidade: fácil personalizar qualquer aspecto\nAnalogia: É como escrever uma frase: - Sujeito (data): seus dados - Verbo (geom): o que mostrar (pontos, linhas, barras) - Advérbios (aes): como mapear variáveis (x, y, cor, tamanho) - Adjetivos (themes, scales): aparência e estilo\n\n\nComponentes essenciais:\n1. Data (dados): O dataset que você quer visualizar\nggplot(data = penguins)  # Apenas especifica os dados\n2. Aesthetics (aes): Mapeamento de variáveis para propriedades visuais - x, y: posição nos eixos - color: cor de pontos/linhas - fill: cor de preenchimento - size: tamanho - shape: forma (círculo, triângulo, etc.) - alpha: transparência (0 = invisível, 1 = opaco) - linetype: tipo de linha (sólida, tracejada, etc.)\n# Exemplo de aesthetics\naes(x = flipper_length_mm,        # eixo x\n    y = body_mass_g,               # eixo y\n    color = species,               # cor por espécie\n    size = bill_length_mm)         # tamanho por comprimento do bico\n3. Geometries (geom): Tipo de representação visual - geom_point(): pontos (gráfico de dispersão) - geom_line(): linhas - geom_bar(): barras - geom_boxplot(): boxplots - geom_histogram(): histogramas - E muitos outros…\n4. Scales: Controle fino de como os dados são mapeados - scale_x_continuous(): escala do eixo x - scale_color_manual(): cores personalizadas - scale_y_log10(): escala logarítmica\n5. Themes: Aparência geral (não afeta os dados) - theme_minimal(): minimalista - theme_bw(): preto e branco - theme_classic(): clássico - theme(): personalização completa\n\n\nA lógica do + (soma de camadas)\nEm ggplot2, você adiciona camadas com +:\nggplot(data = dados, aes(x = var1, y = var2)) +  # Base\n  geom_point() +                                   # Camada 1: pontos\n  geom_smooth() +                                  # Camada 2: linha de tendência\n  labs(title = \"Meu gráfico\") +                   # Camada 3: títulos\n  theme_minimal()                                  # Camada 4: tema\nImportante: Use + no final da linha, não no início!\n\n\nAesthetics globais vs locais\nGlobal (no ggplot()): aplica-se a todas as camadas\nggplot(dados, aes(x = var1, y = var2, color = grupo)) +\n  geom_point() +      # Usa cor\n  geom_smooth()       # Também usa cor\nLocal (dentro do geom_*()): aplica-se apenas àquela camada\nggplot(dados, aes(x = var1, y = var2)) +\n  geom_point(aes(color = grupo)) +  # Apenas pontos coloridos\n  geom_smooth()                      # Linha sem cor\n\nlibrary(ggplot2)\n\n# Estrutura básica\n# ggplot(data = dados, aes(x = var1, y = var2)) +\n#   geom_point()\n\n# Exemplo com palmerpenguins\nggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +\n  geom_point()\n\n# Adicionar cor por espécie\nggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +\n  geom_point()\n\n# Adicionar forma por ilha\nggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, \n                     color = species, shape = island)) +\n  geom_point(size = 3, alpha = 0.7)"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#tipos-de-gráficos-geoms",
    "href": "materiais/dia3_manipulacao.html#tipos-de-gráficos-geoms",
    "title": "Dia 3",
    "section": "2.2 Tipos de Gráficos (geoms)",
    "text": "2.2 Tipos de Gráficos (geoms)\n\nEscolhendo o tipo certo de gráfico\nPergunte-se: 1. Quantas variáveis quero mostrar? (1, 2, 3+) 2. Que tipo de variáveis? (categórica vs numérica) 3. Qual história quero contar? (distribuição, relação, comparação, evolução)\nGuia rápido: - Relação entre 2 numéricas → Dispersão (geom_point) - Comparar categorias → Barras (geom_bar/geom_col) - Distribuição de 1 numérica → Histograma ou Densidade - Comparar distribuições → Boxplot ou Violin - Evolução temporal → Linhas (geom_line) - Parte do todo → Pizza (evite!) ou Barras empilhadas\n\n\nGráfico de Dispersão (geom_point)\nQuando usar: - Mostrar relação entre duas variáveis numéricas - Identificar correlações, tendências ou padrões - Visualizar clusters ou outliers\nParâmetros úteis: - size: tamanho dos pontos (número ou mapeado a variável) - alpha: transparência (útil quando há sobreposição) - shape: forma dos pontos (círculo, triângulo, quadrado, etc.) - color: cor (fixa ou mapeada a variável categórica)\nDica: Use geom_smooth() junto para adicionar linha de tendência!\nTipos de relação que você pode identificar: - Positiva: x aumenta, y aumenta - Negativa: x aumenta, y diminui - Não-linear: curva ou padrão complexo - Sem relação: pontos dispersos aleatoriamente\n\n# Dispersão básica\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\n\n# Com cores e tamanhos\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g,\n                     color = species, size = bill_length_mm)) +\n  geom_point(alpha = 0.6)\n\n# Adicionar linha de tendência\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species), alpha = 0.6) +\n  geom_smooth(method = \"lm\", se = TRUE)\n\n\n\nGráfico de Barras (geom_bar / geom_col)\nDiferença importante: - geom_bar(): conta automaticamente (para dados brutos) - Use quando: quer contar quantas vezes cada categoria aparece - Exemplo: quantos alunos de cada curso\n\ngeom_col(): usa valores que já estão calculados\n\nUse quando: já tem os valores agregados\nExemplo: vendas totais por mês (já somadas)\n\n\nQuando usar barras: - Comparar quantidades entre categorias - Mostrar rankings - Visualizar composição (barras empilhadas) - Dados temporais discretos (meses, anos)\nParâmetros importantes:\nposition: Como organizar múltiplas barras - \"stack\" (padrão): empilhadas uma sobre a outra - \"dodge\": lado a lado - \"fill\": empilhadas proporcionalmente (100%)\nwidth: Largura das barras (0-1) - Menor = barras mais finas com mais espaço\nfill vs color: - fill: cor de preenchimento da barra - color: cor da borda da barra\nDicas de design: - Ordene categorias por valor (não alfabeticamente) - Use cores apenas quando necessário (não decore por decorar) - Evite 3D (distorce percepção) - Comece eixo y em zero (não engane visualmente) - Considere barras horizontais se nomes de categorias forem longos\n\n# Contagem (geom_bar)\nggplot(penguins, aes(x = species)) +\n  geom_bar()\n\n# Com preenchimento por outra variável\nggplot(penguins, aes(x = species, fill = island)) +\n  geom_bar()\n\n# Barras lado a lado\nggplot(penguins, aes(x = species, fill = island)) +\n  geom_bar(position = \"dodge\")\n\n# Proporção (100%)\nggplot(penguins, aes(x = species, fill = island)) +\n  geom_bar(position = \"fill\") +\n  labs(y = \"Proporção\")\n\n# Barras horizontais\nggplot(penguins, aes(y = species)) +\n  geom_bar()\n\n# geom_col (quando você tem valores agregados)\nresumo &lt;- penguins %&gt;%\n  group_by(species) %&gt;%\n  summarize(massa_media = mean(body_mass_g, na.rm = TRUE))\n\nggplot(resumo, aes(x = species, y = massa_media)) +\n  geom_col(fill = \"steelblue\")\n\n\n\nBoxplot (geom_boxplot)\nO que é um boxplot?\nUm boxplot (ou diagrama de caixa) mostra a distribuição de dados através de quartis. É uma forma compacta de ver: - A mediana (linha central) - A dispersão (tamanho da caixa) - Outliers (pontos isolados)\nAnatomia do boxplot:\n    máximo (ou Q3 + 1.5*IQR)\n        │\n    ┌───┴───┐\n    │  Q3   │  ← 75% dos dados estão abaixo\n    │───────│  ← mediana (Q2)\n    │  Q1   │  ← 25% dos dados estão abaixo\n    └───┬───┘\n        │\n    mínimo (ou Q1 - 1.5*IQR)\n    \n    ●  ← outliers (pontos fora do padrão)\nQuando usar: - Comparar distribuições entre grupos - Identificar outliers - Ver simetria/assimetria dos dados - Quando tem muitas categorias (mais eficiente que múltiplos histogramas)\nVantagens: - Mostra 5 estatísticas de uma vez (min, Q1, mediana, Q3, max) - Identifica outliers automaticamente - Compacto - fácil comparar muitos grupos\nDesvantagens: - Não mostra a forma exata da distribuição - Pode esconder bimodalidade (duas “montanhas”) - Menos intuitivo para público não-técnico\nAlternativas: - Violin plot (geom_violin): mostra a forma completa da distribuição - Jitter plot (geom_jitter): mostra todos os pontos individuais - Combinação: boxplot + jitter = melhor dos dois mundos\nDicas: - Use geom_jitter() junto para mostrar pontos individuais - Ordene grupos por mediana para facilitar comparação - Use cores para distinguir grupos, mas não exagere\n\n# Boxplot básico\nggplot(penguins, aes(x = species, y = body_mass_g)) +\n  geom_boxplot()\n\n# Com cores\nggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) +\n  geom_boxplot()\n\n# Adicionar pontos individuais\nggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) +\n  geom_boxplot(alpha = 0.7) +\n  geom_jitter(width = 0.2, alpha = 0.3, size = 1)\n\n# Violin plot (alternativa)\nggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) +\n  geom_violin()\n\n\n\nGráfico de Linhas (geom_line)\nQuando usar: - Dados temporais (séries temporais) - Mostrar tendências ou evolução - Dados com ordem natural (temperatura ao longo do dia) - Conectar pontos sequenciais\nCUIDADO: Não use linhas para: - Dados categóricos sem ordem (espécies, nomes) - Quando não há continuidade entre pontos\nPor que usar linhas em vez de barras para séries temporais? - Linhas enfatizam tendência e fluxo - Mais fácil ver mudanças ao longo do tempo - Menos “peso visual” quando há muitos pontos - Facilita comparação de múltiplas séries\nParâmetros úteis: - size: espessura da linha - linetype: tipo de linha (sólida, tracejada, pontilhada) - color: cor da linha - group: quando tem múltiplas linhas\nDica: Combine geom_line() + geom_point() para destacar valores individuais\n\n\nHistograma e Densidade (geom_histogram / geom_density)\nHistograma (geom_histogram)\nO que mostra: A distribuição de uma variável numérica dividida em “bins” (intervalos).\nQuando usar: - Entender a forma da distribuição (simétrica, assimétrica, bimodal) - Identificar moda (valor mais frequente) - Ver dispersão dos dados - Detectar outliers\nParâmetro crítico: bins (ou binwidth) - bins: número de barras (padrão = 30) - binwidth: largura de cada barra - Importante: Número de bins muda a interpretação! - Poucos bins → padrões grosseiros, perde detalhes - Muitos bins → muito detalhado, difícil ver padrão geral - Teste diferentes valores!\nTipos de distribuição que você pode identificar: - Normal (sino): simétrica, maioria no centro - Assimétrica positiva: cauda longa à direita - Assimétrica negativa: cauda longa à esquerda - Bimodal: duas “montanhas” (dois grupos distintos) - Uniforme: todas as barras similares (raro em dados reais)\nDensidade (geom_density)\nO que mostra: Uma versão “suavizada” do histograma - uma curva contínua.\nVantagens sobre histograma: - Não depende de escolha arbitrária de bins - Mais suave e fácil de interpretar - Melhor para comparar múltiplas distribuições sobrepostas - Mais “bonito” visualmente\nDesvantagens: - Pode ser menos intuitivo para público não-técnico - Pode suavizar demais e esconder detalhes\nQuando usar cada um: - Histograma: primeira exploração, apresentação para não-técnicos - Densidade: comparar grupos, análise mais refinada, publicações\nDica: Use alpha (transparência) quando sobrepor múltiplas distribuições!\n\n# Criar dados temporais\nvendas_tempo &lt;- tibble(\n  mes = 1:12,\n  vendas = c(100, 120, 150, 140, 170, 190, 200, 210, 195, 220, 240, 250),\n  custos = c(80, 90, 100, 95, 110, 120, 125, 130, 120, 135, 145, 150)\n)\n\n# Linha simples\nggplot(vendas_tempo, aes(x = mes, y = vendas)) +\n  geom_line()\n\n# Com pontos\nggplot(vendas_tempo, aes(x = mes, y = vendas)) +\n  geom_line(color = \"blue\", size = 1) +\n  geom_point(color = \"blue\", size = 3)\n\n# Múltiplas linhas (precisa pivotear)\nvendas_long &lt;- vendas_tempo %&gt;%\n  pivot_longer(cols = c(vendas, custos), names_to = \"tipo\", values_to = \"valor\")\n\nggplot(vendas_long, aes(x = mes, y = valor, color = tipo)) +\n  geom_line(size = 1) +\n  geom_point(size = 2)\n\n\n\nHistograma e Densidade (geom_histogram / geom_density)\n\n# Histograma\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(bins = 30, fill = \"steelblue\", color = \"white\")\n\n# Ajustar número de bins\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(bins = 15, fill = \"steelblue\", alpha = 0.7)\n\n# Por grupo\nggplot(penguins, aes(x = body_mass_g, fill = species)) +\n  geom_histogram(bins = 30, alpha = 0.6, position = \"identity\")\n\n# Densidade\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_density(fill = \"steelblue\", alpha = 0.5)\n\n# Densidade por grupo\nggplot(penguins, aes(x = body_mass_g, fill = species)) +\n  geom_density(alpha = 0.5)"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#personalização",
    "href": "materiais/dia3_manipulacao.html#personalização",
    "title": "Dia 3",
    "section": "2.3 Personalização",
    "text": "2.3 Personalização\n\nLabels (labs) - Comunicando claramente\nPor que labels são importantes?\nUm gráfico sem bons labels é como um livro sem capa - ninguém sabe do que se trata! Labels transformam um gráfico técnico em uma ferramenta de comunicação.\nElementos de labs():\n\ntitle: Título principal - O QUE o gráfico mostra\n\nSeja descritivo: “Relação entre…” não apenas “Gráfico 1”\nMáximo 1-2 linhas\n\nsubtitle: Subtítulo - Contexto adicional ou detalhes\n\nInformação complementar sobre período, amostra, etc.\n\nx / y: Rótulos dos eixos - SEMPRE inclua unidades!\n\n❌ “Massa”\n✅ “Massa Corporal (g)”\n\ncolor / fill / size / etc.: Legendas\n\nRenomeie para termos claros: “Espécie” em vez de “species”\n\ncaption: Nota de rodapé - Fonte dos dados, créditos\n\nExemplo: “Fonte: Palmer Archipelago LTER”\n\n\nRegra de ouro: Seu gráfico deve se explicar sozinho. Uma pessoa que nunca viu seus dados deveria entender o que está sendo mostrado apenas olhando o gráfico.\n\n\nTemas (themes) - Definindo a aparência\nO que são temas?\nTemas controlam a aparência não-dados do gráfico: cor de fundo, linhas de grade, fontes, etc. Não afetam os dados em si, apenas como são apresentados.\nTemas prontos (built-in):\n\ntheme_gray() (padrão): fundo cinza, grade branca\n\nUso: padrão, nada especial\n\ntheme_bw(): preto e branco, fundo branco\n\nUso: impressão P&B, publicações acadêmicas\n\ntheme_minimal(): minimalista, sem bordas\n\nUso: apresentações modernas, relatórios limpos\nRecomendado para iniciantes!\n\ntheme_classic(): eixos simples, sem grades\n\nUso: estilo clássico, gráficos “científicos”\n\ntheme_dark(): fundo escuro\n\nUso: apresentações em projetores, dashboards\n\ntheme_void(): completamente limpo\n\nUso: mapas, visualizações artísticas\n\n\nComo personalizar temas?\nUse theme() para ajustar elementos específicos:\ntheme(\n  plot.title = element_text(size = 16, face = \"bold\"),\n  axis.text = element_text(size = 12),\n  legend.position = \"bottom\",\n  panel.grid.minor = element_blank()  # Remove grade secundária\n)\nElementos ajustáveis: - element_text(): texto (título, eixos, legendas) - element_line(): linhas (eixos, grades) - element_rect(): retângulos (fundo, bordas) - element_blank(): remove o elemento\nDica: Combine tema pronto + ajustes finos:\ntheme_minimal() + theme(legend.position = \"bottom\")\n\n\nEscalas (scales) - Controle fino\nO que são scales?\nScales controlam como os dados são mapeados para propriedades visuais. Toda aesthetic (x, y, color, size, etc.) tem uma scale.\nPor que ajustar scales? - Cores mais bonitas ou acessíveis - Eixos com quebras específicas - Transformações (log, sqrt) - Formatação de valores (moeda, percentual)\nTipos principais:\n1. Scales de posição (eixos x e y)\n# Controlar quebras e limites\nscale_y_continuous(\n  breaks = seq(0, 100, 10),    # Onde mostrar marcas\n  limits = c(0, 100),          # Limite do eixo\n  expand = c(0, 0)             # Remover espaço extra\n)\n\n# Transformações\nscale_y_log10()                # Escala logarítmica\nscale_x_sqrt()                 # Raiz quadrada\nscale_x_reverse()              # Inverter eixo\n2. Scales de cor\n# Cores manuais\nscale_color_manual(values = c(\"red\", \"blue\", \"green\"))\n\n# Paletas viridis (acessíveis para daltônicos!)\nscale_color_viridis_d()        # Discreta (categórica)\nscale_color_viridis_c()        # Contínua (numérica)\n\n# Paletas Brewer\nscale_color_brewer(palette = \"Set1\")\n3. Formatação com scales (pacote)\nlibrary(scales)\n\n# Formatar números\nscale_y_continuous(labels = label_comma())      # 1,000\nscale_y_continuous(labels = label_percent())    # 50%\nscale_y_continuous(labels = label_dollar())     # $100\nscale_y_continuous(labels = label_number(\n  prefix = \"R$ \",\n  decimal.mark = \",\",\n  big.mark = \".\"\n))  # R$ 1.000,00\nCores para daltônicos:\nUse paletas acessíveis! ~8% dos homens têm daltonismo.\n✅ Boas escolhas: - scale_color_viridis_d() (melhor!) - scale_color_brewer(palette = \"Set2\") - Esquemas azul-laranja (distinguíveis)\n❌ Evite: - Vermelho-verde (indistinguíveis para daltônicos) - Muitas cores similares\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n  geom_point() +\n  labs(\n    title = \"Relação entre Nadadeira e Massa Corporal\",\n    subtitle = \"Dados do Arquipélago Palmer, Antártica\",\n    x = \"Comprimento da Nadadeira (mm)\",\n    y = \"Massa Corporal (g)\",\n    color = \"Espécie\",\n    caption = \"Fonte: palmerpenguins package\"\n  )\n\n\n\nTemas (themes)\n\ngrafico_base &lt;- ggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) +\n  geom_boxplot() +\n  labs(title = \"Massa Corporal por Espécie\")\n\n# Tema padrão (gray)\ngrafico_base\n\n# Tema minimalista\ngrafico_base + theme_minimal()\n\n# Tema BW\ngrafico_base + theme_bw()\n\n# Tema clássico\ngrafico_base + theme_classic()\n\n# Tema escuro\ngrafico_base + theme_dark()\n\n# Customizar tema\ngrafico_base +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.text = element_text(size = 12),\n    legend.position = \"bottom\"\n  )\n\n\n\nEscalas (scales)\n\nlibrary(scales)\n\n# Escala de cores manual\nggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +\n  geom_point() +\n  scale_color_manual(values = c(\"darkorange\", \"purple\", \"cyan4\"))\n\n# Escala de cores viridis (acessível e bonita)\nggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +\n  geom_point() +\n  scale_color_viridis_d()\n\n# Escala de eixo\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point() +\n  scale_y_continuous(\n    labels = label_comma(),  # Formatar números com vírgula\n    breaks = seq(3000, 6000, 500)\n  )\n\n# Transformação logarítmica\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point() +\n  scale_y_log10()"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#combinando-gráficos-patchwork",
    "href": "materiais/dia3_manipulacao.html#combinando-gráficos-patchwork",
    "title": "Dia 3",
    "section": "2.4 Combinando Gráficos (patchwork)",
    "text": "2.4 Combinando Gráficos (patchwork)\nPor que combinar gráficos?\nMuitas vezes você quer mostrar múltiplas visualizações relacionadas lado a lado: - Comparar diferentes aspectos dos mesmos dados - Mostrar “antes e depois” - Painéis para relatórios e apresentações - Contar uma história visual completa\npatchwork vs alternativas:\n\nBase R (par(mfrow), layout): complexo, limitado\ngridExtra (grid.arrange): funcional mas verboso\npatchwork: simples, intuitivo, poderoso ✅\n\nSintaxe básica de patchwork:\n# + : lado a lado (horizontal)\ngrafico1 + grafico2\n\n# / : um em cima do outro (vertical)\ngrafico1 / grafico2\n\n# Combinar: () agrupa operações\n(grafico1 + grafico2) / grafico3\nOperadores: - + : lado a lado - / : empilhar - | : lado a lado (alternativa ao +) - () : agrupar\nLayouts complexos:\n# 2x2\n(g1 + g2) / (g3 + g4)\n\n# L-shape\ng1 + (g2 / g3)\n\n# Tamanhos diferentes\ng1 + g2 + plot_layout(widths = c(2, 1))  # g1 é 2x mais largo\nFuncionalidades úteis:\n1. plot_annotation(): Adicionar título geral e caption\n(g1 + g2) / (g3 + g4) +\n  plot_annotation(\n    title = \"Análise Completa\",\n    subtitle = \"Dados de 2024\",\n    caption = \"Fonte: MinhaFonte\",\n    tag_levels = \"A\"  # Adiciona A, B, C, D...\n  )\n2. plot_layout(): Controlar layout\ng1 + g2 + g3 +\n  plot_layout(\n    ncol = 2,              # Número de colunas\n    guides = \"collect\",    # Coletar legendas\n    widths = c(2, 1, 1),  # Larguras relativas\n    heights = c(1, 2)      # Alturas relativas\n  )\n3. Legendas unificadas:\n(g1 + g2) / (g3 + g4) +\n  plot_layout(guides = \"collect\") &  # & aplica a todos\n  theme(legend.position = \"bottom\")\nDicas de design: - Mantenha escalas consistentes entre gráficos relacionados - Use cores consistentes para mesmas categorias - Não sobrecarregue - máximo 4-6 painéis - Considere se um único gráfico com facetas seria melhor"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#salvando-gráficos-ggsave",
    "href": "materiais/dia3_manipulacao.html#salvando-gráficos-ggsave",
    "title": "Dia 3",
    "section": "2.5 Salvando Gráficos (ggsave)",
    "text": "2.5 Salvando Gráficos (ggsave)\nPor que usar ggsave?\nVocê precisa salvar gráficos para: - Incluir em relatórios, artigos, apresentações - Compartilhar com colegas - Backup de visualizações importantes - Usar em outros softwares\nggsave() é inteligente: - Detecta formato pela extensão (.png, .pdf, .jpg, etc.) - Ajusta resolução automaticamente - Salva o último gráfico por padrão (ou você especifica) - Funciona perfeitamente com here()\nSintaxe básica:\nggsave(\n  filename = \"meu_grafico.png\",  # Nome e formato\n  plot = meu_grafico,            # Qual gráfico (opcional)\n  width = 8,                     # Largura em polegadas\n  height = 6,                    # Altura em polegadas\n  dpi = 300                      # Resolução (pontos por polegada)\n)\nFormatos e quando usar:\n1. PNG (.png) - Raster (pixels) - ✅ Bom para: web, apresentações, compartilhamento rápido - ✅ Suporta transparência - ✅ Tamanho razoável com boa qualidade - ❌ Perde qualidade ao ampliar muito - DPI recomendado: 300 (alta qualidade), 150 (web)\n2. PDF (.pdf) - Vetor (matemático) - ✅ Bom para: publicações acadêmicas, impressão profissional - ✅ Escala infinitamente sem perder qualidade - ✅ Tamanho pequeno para gráficos simples - ❌ Pode ser grande com muitos pontos - Sem DPI (vetor não tem pixels)\n3. SVG (.svg) - Vetor (para web) - ✅ Bom para: web, design, editável em Illustrator - ✅ Escala perfeitamente - ✅ Pode ser editado como código - ❌ Suporte limitado em alguns contextos - Sem DPI (vetor)\n4. JPEG (.jpg) - Raster (pixels) - ✅ Tamanho muito pequeno - ❌ Perde qualidade (compressão) - ❌ Não suporta transparência - Evite para gráficos! (Use PNG)\n5. TIFF (.tiff) - Raster (pixels) - ✅ Alta qualidade sem compressão - ✅ Aceito em publicações - ❌ Arquivos muito grandes - Use apenas se exigido\nConfigurações importantes:\nDPI (Dots Per Inch) - resolução: - 72 dpi: tela de computador (baixa qualidade) - 150 dpi: apresentações, web (qualidade média) - 300 dpi: impressão, publicações (alta qualidade) ✅ - 600 dpi: impressão profissional (raramente necessário)\nTamanho (width e height): - Padrão: polegadas (inches) - 1 polegada = 2.54 cm - Tamanhos comuns: - Apresentação slide: 10 x 7.5 polegadas (16:9) - Artigo coluna única: 3.5 x 3.5 polegadas - Artigo largura total: 7 x 5 polegadas - Poster: 24 x 18 polegadas\nBoas práticas:\n# Use here() para portabilidade\nggsave(\n  here(\"output\", \"figures\", \"massa_especies.png\"),\n  width = 8,\n  height = 6,\n  dpi = 300,\n  bg = \"white\"  # Fundo branco (útil com temas transparentes)\n)\n\n# Salvar em múltiplos formatos\nfor (fmt in c(\"png\", \"pdf\", \"svg\")) {\n  ggsave(\n    here(\"output\", \"figures\", paste0(\"grafico.\", fmt)),\n    plot = meu_grafico,\n    width = 8,\n    height = 6,\n    dpi = 300\n  )\n}\nResolução de problemas:\nTexto muito pequeno/grande: - Ajuste width e height (não dpi) - Ou ajuste tamanhos de fonte no gráfico antes de salvar\nArquivo muito grande: - PNG: reduza DPI para 150 - PDF com muitos pontos: converta para PNG - Simplifique o gráfico (menos pontos, objetos)\nCores diferentes do RStudio: - Especifique bg = \"white\" (ou cor de fundo desejada) - Alguns temas têm fundo transparente por padrão\nEixos cortados: - Adicione scale_y_continuous(expand = expansion(mult = 0.05)) - Ou ajuste margens: theme(plot.margin = margin(1, 1, 1, 1, \"cm\"))\n\nlibrary(patchwork)\n\n# Criar vários gráficos\ng1 &lt;- ggplot(penguins, aes(x = species, fill = species)) +\n  geom_bar() +\n  labs(title = \"Contagem por Espécie\") +\n  theme_minimal()\n\ng2 &lt;- ggplot(penguins, aes(x = body_mass_g, fill = species)) +\n  geom_density(alpha = 0.5) +\n  labs(title = \"Distribuição de Massa\") +\n  theme_minimal()\n\ng3 &lt;- ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n  geom_point() +\n  labs(title = \"Nadadeira vs Massa\") +\n  theme_minimal()\n\ng4 &lt;- ggplot(penguins, aes(x = species, y = bill_length_mm, fill = species)) +\n  geom_boxplot() +\n  labs(title = \"Bico por Espécie\") +\n  theme_minimal()\n\n# Combinar lado a lado\ng1 + g2\n\n# Combinar em cima/embaixo\ng1 / g2\n\n# Layout complexo\n(g1 + g2) / (g3 + g4)\n\n# Com título geral\n(g1 + g2) / (g3 + g4) +\n  plot_annotation(\n    title = \"Análise Exploratória de Pinguins\",\n    subtitle = \"Palmer Archipelago, Antarctica\",\n    caption = \"Dados: palmerpenguins\"\n  )\n\n# Coletar legendas\n(g1 + g2) / (g3 + g4) +\n  plot_layout(guides = \"collect\") &\n  theme(legend.position = \"bottom\")"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#salvando-gráficos-ggsave-1",
    "href": "materiais/dia3_manipulacao.html#salvando-gráficos-ggsave-1",
    "title": "Dia 3",
    "section": "2.5 Salvando Gráficos (ggsave)",
    "text": "2.5 Salvando Gráficos (ggsave)\n\n# Criar gráfico\nmeu_grafico &lt;- ggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) +\n  geom_boxplot() +\n  labs(\n    title = \"Massa Corporal por Espécie de Pinguim\",\n    x = \"Espécie\",\n    y = \"Massa Corporal (g)\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n\n# Salvar como PNG\n# ggsave(\n#   filename = here(\"output\", \"figures\", \"massa_especies.png\"),\n#   plot = meu_grafico,\n#   width = 8,\n#   height = 6,\n#   dpi = 300\n# )\n\n# Salvar como PDF (vetorial)\n# ggsave(\n#   filename = here(\"output\", \"figures\", \"massa_especies.pdf\"),\n#   plot = meu_grafico,\n#   width = 8,\n#   height = 6\n# )\n\n# Salvar último gráfico criado\n# ggsave(here(\"output\", \"figures\", \"ultimo_grafico.png\"), dpi = 300)\n\n# Diferentes formatos\n# ggsave(\"grafico.png\")   # PNG\n# ggsave(\"grafico.pdf\")   # PDF\n# ggsave(\"grafico.svg\")   # SVG (escalável)\n# ggsave(\"grafico.jpg\")   # JPEG"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#exercícios-práticos",
    "href": "materiais/dia3_manipulacao.html#exercícios-práticos",
    "title": "Dia 3",
    "section": "Exercícios Práticos",
    "text": "Exercícios Práticos\n\nExercício 1: Transformação de dados\n\n# Dados de temperatura (wide)\ntemp_wide &lt;- tibble(\n  cidade = c(\"São Paulo\", \"Rio de Janeiro\", \"Belo Horizonte\"),\n  jan = c(25, 28, 24),\n  fev = c(26, 29, 25),\n  mar = c(24, 27, 23),\n  abr = c(22, 25, 21)\n)\n\n# a) Transforme para formato long\n\n\n# b) Calcule temperatura média por cidade\n\n\n# c) Qual cidade teve maior variação?\n\n\n# d) Crie gráfico de linhas mostrando temperatura ao longo dos meses\n\n\n\nExercício 2: Limpeza e I/O\n\n# a) Crie um dataset com nomes de colunas bagunçados e limpe com janitor\n\n\n# b) Adicione algumas linhas com NA e trate-os adequadamente\n\n\n# c) Salve o dataset limpo como CSV usando here()\n\n\n# d) Leia o arquivo de volta e confirme que está correto\n\n\n\nExercício 3: Visualização completa\n\n# Use o dataset penguins para criar:\n\n# a) Um gráfico de dispersão relacionando duas variáveis numéricas\n\n\n# b) Um boxplot comparando espécies\n\n\n# c) Um histograma da distribuição de massa corporal\n\n\n# d) Combine os 3 gráficos usando patchwork\n\n\n# e) Personalize com temas, cores e labels apropriados\n\n\n# f) Salve o resultado final com ggsave()"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#commit-do-dia",
    "href": "materiais/dia3_manipulacao.html#commit-do-dia",
    "title": "Dia 3",
    "section": "Commit do Dia",
    "text": "Commit do Dia\ngit add scripts/03_transformacao_viz.R\ngit commit -m \"Dia 3: transformação, I/O e visualização com ggplot2\"\ngit push origin main"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#checklist-de-encerramento",
    "href": "materiais/dia3_manipulacao.html#checklist-de-encerramento",
    "title": "Dia 3",
    "section": "Checklist de Encerramento",
    "text": "Checklist de Encerramento\n\nDominou pivot_longer e pivot_wider\nEntendeu separate e unite\nSabe tratar valores ausentes\nConsegue ler CSV e Excel\nOrganiza projetos com here()\nConhece janitor e skimr\nCria gráficos básicos com ggplot2\nPersonaliza gráficos (temas, cores, labels)\nCombina gráficos com patchwork\nSalva gráficos com ggsave()\nFez commit no seu fork"
  },
  {
    "objectID": "materiais/dia3_manipulacao.html#referências-rápidas",
    "href": "materiais/dia3_manipulacao.html#referências-rápidas",
    "title": "Dia 3",
    "section": "Referências Rápidas",
    "text": "Referências Rápidas\n\nggplot2 cheatsheet: https://posit.co/resources/cheatsheets/\nR for Data Science - Data Visualization: https://r4ds.hadley.nz/data-visualize\ntidyr documentation: https://tidyr.tidyverse.org/\npatchwork: https://patchwork.data-imaginist.com/\nR Graph Gallery: https://r-graph-gallery.com/\n\n\nAmanhã no Dia 4: Integração do ChatGPT e Claude no RStudio! 🤖"
  },
  {
    "objectID": "materiais/sobre_mim.html",
    "href": "materiais/sobre_mim.html",
    "title": "Sobre o Autor",
    "section": "",
    "text": "Olá! Meu nome é Vinícius Junqueira e será um prazer guiá-lo nesta jornada pelo mundo do R e programação científica básica.\n\n\n\nSou graduado em Medicina Veterinária pela Universidade de Brasília (UnB), com mestrado e doutorado em Genética e Melhoramento pela Universidade Federal de Viçosa (UFV). Minha trajetória acadêmica sempre esteve ligada à compreensão de dados complexos e à resolução de problemas usando ferramentas quantitativas e computacionais.\nEm 2016, tive a oportunidade de atuar como pesquisador convidado no grupo de melhoramento genético animal da University of Georgia, nos Estados Unidos, experiência que ampliou significativamente minha visão sobre metodologias avançadas de análise de dados e programação científica.\n\n\n\nNo Brasil, iniciei minha carreira como pesquisador em genética quantitativa na Monsanto/Bayer, onde contribuí para o desenvolvimento técnico-científico de projetos em programas de melhoramento de milho e soja no Brasil, Argentina, México, Estados Unidos e Europa. Entre 2021 e 2024, liderei os programas de melhoramento de soja no Brasil e Argentina, coordenando a implementação de estratégias inovadoras que incluíram a introdução da biotecnologia INTACTA3, prevista para lançamento comercial no Brasil em 2030.\nDesde 2024, coordeno o desenvolvimento de estratégias genético-quantitativas para otimizar a alocação de fenotipagem a campo nas culturas de milho e soja nos Estados Unidos, trabalhando com grandes volumes de dados e modelos preditivos complexos.\nParalelamente às atividades na Bayer, mantenho colaborações ativas com projetos de pesquisa junto à Embrapa Pecuária Sul, Universidade Federal de Viçosa, Universidade Federal de Goiás, Universidade Federal de Uberlândia, Purdue University e University of Georgia. Integro também a equipe técnica dos programas de melhoramento genético das raças Hereford e Braford (PampaPlus/ABHB) e do Programa de Melhoramento de Bovinos de Carne (PROMEBO/ANC).\n\n\n\nMinha experiência abrange tanto o melhoramento genético de plantas quanto de animais, com foco em:\n\nEstimação de valores genéticos por modelos tradicionais e genômicos\nModelos multicaracterísticos e análise de interação genótipo-ambiente\nÍndices de seleção bioeconômicos\nProgramação científica em Fortran, R e Python\nMétodos de otimização para seleção de parentais e acasalamentos\nAnálise de grandes conjuntos de dados e tomada de decisões baseada em evidências\n\n\n\n\nAo longo da minha trajetória, R se tornou a ferramenta fundamental do meu trabalho diário. Foi através do R que consegui analisar milhões de dados fenotípicos e genotípicos, implementar modelos estatísticos complexos, criar visualizações que comunicam resultados para diferentes públicos, e desenvolver ferramentas computacionais que impactam decisões estratégicas em programas de melhoramento.\nLembro-me perfeitamente de quando comecei a aprender R durante meu mestrado. No início, tudo parecia confuso e intimidador. Passei por frustrações, erros incompreensíveis e momentos em que pensei em desistir. Mas persisti, e posso afirmar sem hesitação: aprender R foi uma das decisões mais transformadoras da minha carreira.\nO R me deu autonomia para resolver problemas, liberdade para explorar dados de formas criativas, e a capacidade de comunicar descobertas científicas com clareza. Ele abriu portas profissionais que eu nem imaginava existirem e me permitiu colaborar com pesquisadores ao redor do mundo.\n\n\n\nDecidi criar este curso porque acredito que todo mundo pode aprender R, independentemente do background. Você não precisa ser um gênio da matemática ou ter nascido programando. O que você precisa é de um caminho bem estruturado, exemplos práticos, e alguém que já passou pelas mesmas dificuldades para guiá-lo.\nMinha abordagem é diferente porque:\n\nAprendi da forma difícil e sei exatamente onde iniciantes tropeçam\nUso R diariamente em problemas reais, então ensino o que realmente funciona\nIntegro ferramentas modernas de IA ao aprendizado, acelerando sua curva de evolução\nValorizo a aplicação prática sobre teoria abstrata\n\nEste curso é resultado de anos ensinando R para colegas, alunos e colaboradores de diferentes áreas. Refinei o conteúdo com base em centenas de dúvidas reais, erros comuns e feedbacks valiosos. Meu objetivo é que você não apenas aprenda R, mas que desenvolva confiança para usá-lo como ferramenta transformadora em sua própria jornada profissional.\n\n\n\nSe você está começando do zero, saiba que já estive exatamente onde você está. Se tem alguma experiência, vamos aprofundar seu conhecimento e apresentar ferramentas modernas que aumentarão sua produtividade. Independentemente do seu ponto de partida, estou aqui para ajudá-lo a ter sucesso.\nBem-vindo ao curso. Vamos transformar dados em conhecimento!\n\nContato:\n\nGitHub: github.com/viniciusjunqueira\nLinkedIn: linkedin.com/in/viniciusjunqueira\nEmail: junqueiravinicius@hotmail.com"
  },
  {
    "objectID": "materiais/sobre_mim.html#vinícius-junqueira",
    "href": "materiais/sobre_mim.html#vinícius-junqueira",
    "title": "Sobre o Autor",
    "section": "",
    "text": "Olá! Meu nome é Vinícius Junqueira e será um prazer guiá-lo nesta jornada pelo mundo do R e programação científica básica."
  },
  {
    "objectID": "materiais/sobre_mim.html#formação-acadêmica",
    "href": "materiais/sobre_mim.html#formação-acadêmica",
    "title": "Sobre o Autor",
    "section": "",
    "text": "Sou graduado em Medicina Veterinária pela Universidade de Brasília (UnB), com mestrado e doutorado em Genética e Melhoramento pela Universidade Federal de Viçosa (UFV). Minha trajetória acadêmica sempre esteve ligada à compreensão de dados complexos e à resolução de problemas usando ferramentas quantitativas e computacionais.\nEm 2016, tive a oportunidade de atuar como pesquisador convidado no grupo de melhoramento genético animal da University of Georgia, nos Estados Unidos, experiência que ampliou significativamente minha visão sobre metodologias avançadas de análise de dados e programação científica."
  },
  {
    "objectID": "materiais/sobre_mim.html#trajetória-profissional",
    "href": "materiais/sobre_mim.html#trajetória-profissional",
    "title": "Sobre o Autor",
    "section": "",
    "text": "No Brasil, iniciei minha carreira como pesquisador em genética quantitativa na Monsanto/Bayer, onde contribuí para o desenvolvimento técnico-científico de projetos em programas de melhoramento de milho e soja no Brasil, Argentina, México, Estados Unidos e Europa. Entre 2021 e 2024, liderei os programas de melhoramento de soja no Brasil e Argentina, coordenando a implementação de estratégias inovadoras que incluíram a introdução da biotecnologia INTACTA3, prevista para lançamento comercial no Brasil em 2030.\nDesde 2024, coordeno o desenvolvimento de estratégias genético-quantitativas para otimizar a alocação de fenotipagem a campo nas culturas de milho e soja nos Estados Unidos, trabalhando com grandes volumes de dados e modelos preditivos complexos.\nParalelamente às atividades na Bayer, mantenho colaborações ativas com projetos de pesquisa junto à Embrapa Pecuária Sul, Universidade Federal de Viçosa, Universidade Federal de Goiás, Universidade Federal de Uberlândia, Purdue University e University of Georgia. Integro também a equipe técnica dos programas de melhoramento genético das raças Hereford e Braford (PampaPlus/ABHB) e do Programa de Melhoramento de Bovinos de Carne (PROMEBO/ANC)."
  },
  {
    "objectID": "materiais/sobre_mim.html#expertise-e-áreas-de-atuação",
    "href": "materiais/sobre_mim.html#expertise-e-áreas-de-atuação",
    "title": "Sobre o Autor",
    "section": "",
    "text": "Minha experiência abrange tanto o melhoramento genético de plantas quanto de animais, com foco em:\n\nEstimação de valores genéticos por modelos tradicionais e genômicos\nModelos multicaracterísticos e análise de interação genótipo-ambiente\nÍndices de seleção bioeconômicos\nProgramação científica em Fortran, R e Python\nMétodos de otimização para seleção de parentais e acasalamentos\nAnálise de grandes conjuntos de dados e tomada de decisões baseada em evidências"
  },
  {
    "objectID": "materiais/sobre_mim.html#por-que-ensino-r",
    "href": "materiais/sobre_mim.html#por-que-ensino-r",
    "title": "Sobre o Autor",
    "section": "",
    "text": "Ao longo da minha trajetória, R se tornou a ferramenta fundamental do meu trabalho diário. Foi através do R que consegui analisar milhões de dados fenotípicos e genotípicos, implementar modelos estatísticos complexos, criar visualizações que comunicam resultados para diferentes públicos, e desenvolver ferramentas computacionais que impactam decisões estratégicas em programas de melhoramento.\nLembro-me perfeitamente de quando comecei a aprender R durante meu mestrado. No início, tudo parecia confuso e intimidador. Passei por frustrações, erros incompreensíveis e momentos em que pensei em desistir. Mas persisti, e posso afirmar sem hesitação: aprender R foi uma das decisões mais transformadoras da minha carreira.\nO R me deu autonomia para resolver problemas, liberdade para explorar dados de formas criativas, e a capacidade de comunicar descobertas científicas com clareza. Ele abriu portas profissionais que eu nem imaginava existirem e me permitiu colaborar com pesquisadores ao redor do mundo."
  },
  {
    "objectID": "materiais/sobre_mim.html#minha-missão-com-este-curso",
    "href": "materiais/sobre_mim.html#minha-missão-com-este-curso",
    "title": "Sobre o Autor",
    "section": "",
    "text": "Decidi criar este curso porque acredito que todo mundo pode aprender R, independentemente do background. Você não precisa ser um gênio da matemática ou ter nascido programando. O que você precisa é de um caminho bem estruturado, exemplos práticos, e alguém que já passou pelas mesmas dificuldades para guiá-lo.\nMinha abordagem é diferente porque:\n\nAprendi da forma difícil e sei exatamente onde iniciantes tropeçam\nUso R diariamente em problemas reais, então ensino o que realmente funciona\nIntegro ferramentas modernas de IA ao aprendizado, acelerando sua curva de evolução\nValorizo a aplicação prática sobre teoria abstrata\n\nEste curso é resultado de anos ensinando R para colegas, alunos e colaboradores de diferentes áreas. Refinei o conteúdo com base em centenas de dúvidas reais, erros comuns e feedbacks valiosos. Meu objetivo é que você não apenas aprenda R, mas que desenvolva confiança para usá-lo como ferramenta transformadora em sua própria jornada profissional."
  },
  {
    "objectID": "materiais/sobre_mim.html#vamos-juntos",
    "href": "materiais/sobre_mim.html#vamos-juntos",
    "title": "Sobre o Autor",
    "section": "",
    "text": "Se você está começando do zero, saiba que já estive exatamente onde você está. Se tem alguma experiência, vamos aprofundar seu conhecimento e apresentar ferramentas modernas que aumentarão sua produtividade. Independentemente do seu ponto de partida, estou aqui para ajudá-lo a ter sucesso.\nBem-vindo ao curso. Vamos transformar dados em conhecimento!\n\nContato:\n\nGitHub: github.com/viniciusjunqueira\nLinkedIn: linkedin.com/in/viniciusjunqueira\nEmail: junqueiravinicius@hotmail.com"
  },
  {
    "objectID": "materiais/dia4_ia.html",
    "href": "materiais/dia4_ia.html",
    "title": "Dia 4",
    "section": "",
    "text": "Objetivo do dia\nCapacitar você a usar ChatGPT (OpenAI) e Claude (Anthropic) diretamente no RStudio para: - Explicar erros e debugar código - Revisar e refatorar código - Gerar código e funções - Criar rascunhos de relatórios e documentação - Automatizar tarefas via API\n\nTempo previsto: 19h00–22h00 (intervalo 20h15–20h30)\n\n\n\n\nlibrary(tidyverse)\n\n# Dia 1: Fundamentos\nvetor &lt;- c(1, 2, 3, 4, 5)\nmean(vetor)\n\n# Dia 2: Funções e tidyverse\ncalcular_media &lt;- function(x) {\n  mean(x, na.rm = TRUE)\n}\n\ndados &lt;- tibble(x = 1:10, y = x^2)\n\n# Dia 3: Transformação e visualização\ndados %&gt;%\n  mutate(z = x + y) %&gt;%\n  ggplot(aes(x, y)) +\n  geom_point()"
  },
  {
    "objectID": "materiais/dia4_ia.html#revisão-rápida-dos-dias-anteriores-10-min",
    "href": "materiais/dia4_ia.html#revisão-rápida-dos-dias-anteriores-10-min",
    "title": "Dia 4",
    "section": "",
    "text": "library(tidyverse)\n\n# Dia 1: Fundamentos\nvetor &lt;- c(1, 2, 3, 4, 5)\nmean(vetor)\n\n# Dia 2: Funções e tidyverse\ncalcular_media &lt;- function(x) {\n  mean(x, na.rm = TRUE)\n}\n\ndados &lt;- tibble(x = 1:10, y = x^2)\n\n# Dia 3: Transformação e visualização\ndados %&gt;%\n  mutate(z = x + y) %&gt;%\n  ggplot(aes(x, y)) +\n  geom_point()"
  },
  {
    "objectID": "materiais/dia4_ia.html#o-que-são-llms-large-language-models",
    "href": "materiais/dia4_ia.html#o-que-são-llms-large-language-models",
    "title": "Dia 4",
    "section": "1.1 O que são LLMs (Large Language Models)?",
    "text": "1.1 O que são LLMs (Large Language Models)?\nLLM = Large Language Model (Modelo de Linguagem Grande)\nO que são: - Modelos de inteligência artificial treinados em volumes massivos de texto - Aprendem padrões da linguagem, conceitos e relações - Capazes de gerar texto, código, explicações e muito mais\nComo funcionam (simplificado): 1. Treinamento: Leem bilhões de páginas de texto da internet, livros, código 2. Aprendizado: Identificam padrões - como palavras se relacionam, estruturas de código 3. Geração: Preveem a próxima palavra/token mais provável dada uma entrada\nNão são: - ❌ Bancos de dados que “buscam” respostas - ❌ Sistemas de busca como Google - ❌ Calculadoras ou compiladores\nSão: - ✅ Sistemas de reconhecimento de padrões estatísticos - ✅ Geradores de texto coerente baseados em probabilidades - ✅ Assistentes que “entendem” contexto\n\nModelos principais que usaremos\n1. ChatGPT (OpenAI)\nFamília GPT-4: - gpt-4o: Mais rápido e barato, multimodal (texto + imagem) - gpt-4o-mini: Ainda mais rápido e barato, excelente custo-benefício - gpt-4-turbo: Balanceado entre velocidade e qualidade\nPontos fortes: - ✅ Explicações didáticas e passo a passo - ✅ Geração rápida de código - ✅ Bom em tarefas criativas - ✅ Interface conversacional natural - ✅ Mais barato que Claude\nQuando usar: - Explicar conceitos de forma simples - Gerar código rapidamente (protótipos) - Criar documentação básica - Responder dúvidas gerais\n2. Claude (Anthropic)\nFamília Claude 3: - claude-3-5-sonnet-latest: Melhor modelo, mais inteligente - claude-3-opus: Mais preciso, melhor para análises complexas - claude-3-sonnet: Balanceado - claude-3-haiku: Mais rápido e barato\nPontos fortes: - ✅ Análise profunda de código - ✅ Respostas mais longas e detalhadas - ✅ Melhor em raciocínio complexo - ✅ Mais cuidadoso e preciso - ✅ Melhor contexto (200k tokens vs 128k do GPT)\nQuando usar: - Revisar código complexo - Análise e refatoração profunda - Explicações técnicas detalhadas - Debugging de problemas difíceis\n\n\nComparação prática\n\n\n\nCritério\nChatGPT\nClaude\n\n\n\n\nVelocidade\nMuito rápido ⚡⚡⚡\nRápido ⚡⚡\n\n\nCusto\nMais barato 💰\nMais caro 💰💰\n\n\nExplicações simples\nExcelente ⭐⭐⭐\nMuito bom ⭐⭐\n\n\nAnálise profunda\nBom ⭐⭐\nExcelente ⭐⭐⭐\n\n\nCódigo complexo\nBom ⭐⭐\nExcelente ⭐⭐⭐\n\n\nContexto (tokens)\n128k\n200k\n\n\nCriatividade\nAlta ⭐⭐⭐\nModerada ⭐⭐\n\n\nPrecisão técnica\nBoa ⭐⭐\nExcelente ⭐⭐⭐"
  },
  {
    "objectID": "materiais/dia4_ia.html#o-que-são-apis",
    "href": "materiais/dia4_ia.html#o-que-são-apis",
    "title": "Dia 4",
    "section": "1.2 O que são APIs?",
    "text": "1.2 O que são APIs?\nAPI = Application Programming Interface (Interface de Programação de Aplicações)\nAnalogia do restaurante: - Você = seu código R - Cozinha = servidor da OpenAI/Anthropic com o modelo de IA - Garçom = API que leva seu pedido e traz a resposta - Cardápio = documentação da API (o que você pode pedir)\nComo funciona:\n\nVocê faz uma requisição (pergunta)\n\"Explique o que este código faz: x &lt;- mean(1:10)\"\nAPI envia para o modelo de IA\n\nViaja pela internet até os servidores\nProcessa sua pergunta\n\nModelo gera resposta\n\nAnalisa contexto\nGera texto/código\n\nAPI retorna resposta\n\"Este código calcula a média dos números de 1 a 10...\"\n\nComponentes de uma API:\n\nEndpoint: URL para onde enviar requisições\n\nOpenAI: https://api.openai.com/v1/chat/completions\nAnthropic: https://api.anthropic.com/v1/messages\n\nMétodo HTTP: Como enviar (GET, POST, etc.)\n\nUsaremos POST (enviar dados)\n\nHeaders: Informações sobre a requisição\n\nAuthorization: sua chave API\nContent-Type: formato dos dados (JSON)\n\nBody: Os dados da requisição\n\nModelo a usar\nSua pergunta/prompt\nParâmetros (temperatura, max_tokens, etc.)\n\nResponse: A resposta do servidor\n\nConteúdo gerado\nMetadados (tokens usados, etc.)"
  },
  {
    "objectID": "materiais/dia4_ia.html#limites-e-custos",
    "href": "materiais/dia4_ia.html#limites-e-custos",
    "title": "Dia 4",
    "section": "1.3 Limites e Custos",
    "text": "1.3 Limites e Custos\n\nCustos por modelo\nOpenAI (GPT-4o-mini) - mais barato: - Input: $0.150 / 1M tokens (~750k palavras) - Output: $0.600 / 1M tokens\nExemplo prático: - 1 conversa típica = ~1000 tokens = $0.0015 (menos de 1 centavo!) - 1000 conversas = ~$1.50\nAnthropic (Claude 3.5 Sonnet) - mais caro mas melhor: - Input: $3.00 / 1M tokens - Output: $15.00 / 1M tokens\nExemplo prático: - 1 conversa típica = ~1000 tokens = $0.03 (3 centavos) - 1000 conversas = ~$30\nO que é um token? - Token ≈ 0.75 palavras em inglês - Token ≈ 0.5 palavras em português (devido aos acentos) - “Olá, como você está?” ≈ 7-8 tokens\n\n\nRate Limits (Limites de taxa)\nPor que existem: - Prevenir abuso e spam - Garantir disponibilidade para todos - Controlar custos\nLimites típicos (conta gratuita/tier 1):\nOpenAI: - ~10,000 tokens/minuto - ~3 requisições/minuto (com GPT-4) - ~200 requisições/dia\nAnthropic: - ~10,000 tokens/minuto - ~5 requisições/minuto - ~1000 requisições/dia\nO que acontece se exceder: - Erro HTTP 429: “Too Many Requests” - Precisa esperar (geralmente 1 minuto)\nComo evitar: - Não faça loops rápidos com chamadas à API - Implemente delays entre requisições - Use um modelo mais barato para testes"
  },
  {
    "objectID": "materiais/dia4_ia.html#boas-práticas-de-uso-responsável-de-ia",
    "href": "materiais/dia4_ia.html#boas-práticas-de-uso-responsável-de-ia",
    "title": "Dia 4",
    "section": "1.4 Boas Práticas de Uso Responsável de IA",
    "text": "1.4 Boas Práticas de Uso Responsável de IA\n\nPrivacidade e Dados Sensíveis\n⚠️ NUNCA envie para APIs de IA: - ❌ Senhas ou credenciais - ❌ Dados pessoais identificáveis (CPF, RG, etc.) - ❌ Informações médicas ou financeiras privadas - ❌ Dados proprietários ou confidenciais da empresa - ❌ Código com chaves de API ou tokens\nO que é seguro enviar: - ✅ Código genérico e exemplos - ✅ Dados públicos ou sintéticos - ✅ Perguntas conceituais - ✅ Erros e stacktraces (sem informação sensível)\nLembre-se: Tudo que você envia pode ser usado para treinar modelos futuros!\n\n\nVersionamento de Código Gerado por IA\nPor que versionar: - Transparência sobre origem do código - Rastreabilidade de mudanças - Facilita debugging futuro - Ética e honestidade acadêmica/profissional\nComo fazer:\n# Bom: documenta que IA gerou\n# Esta função foi gerada por ChatGPT em 2024-11-25\n# Prompt: \"Crie função para calcular z-score\"\nzscore &lt;- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n\n# Commits descritivos\ngit commit -m \"feat: adiciona função zscore (gerada com ChatGPT)\"\n\n\nValidação e Teste\n⚠️ CRÍTICO: NUNCA use código de IA sem entender e testar!\nProcesso recomendado:\n\nEntenda o código gerado\n\nLeia linha por linha\nPergunte à IA se não entender algo\nPesquise funções desconhecidas\n\nTeste extensivamente\n# Sempre teste casos extremos\nzscore(c(1, 2, 3))        # Normal\nzscore(c(1, 1, 1))        # Todos iguais (sd = 0?)\nzscore(c(1, NA, 3))       # Com NA\nzscore(numeric(0))        # Vetor vazio\nValide resultados\n\nCompare com métodos conhecidos\nVerifique casos conhecidos\nUse diferentes inputs\n\nRefatore se necessário\n\nMelhore legibilidade\nAdicione validações\nOtimize performance\n\n\n\n\nUso Ético\nFaça: - ✅ Use IA como assistente, não substituto do aprendizado - ✅ Entenda o que a IA está fazendo - ✅ Cite quando código foi gerado por IA (contextos acadêmicos) - ✅ Revise e melhore código gerado - ✅ Use para aprender conceitos novos\nNão faça: - ❌ Submeta código de IA sem entender (em trabalhos/provas) - ❌ Confie cegamente nas respostas - ❌ Use como substituto de documentação oficial - ❌ Compartilhe chaves de API - ❌ Use para gerar trabalhos acadêmicos inteiros sem transparência"
  },
  {
    "objectID": "materiais/dia4_ia.html#variáveis-de-ambiente-no-r",
    "href": "materiais/dia4_ia.html#variáveis-de-ambiente-no-r",
    "title": "Dia 4",
    "section": "2.1 Variáveis de Ambiente no R",
    "text": "2.1 Variáveis de Ambiente no R\nO que são variáveis de ambiente?\nVariáveis de ambiente são configurações que ficam armazenadas fora do seu código, disponíveis para todos os programas no seu sistema operacional.\nPor que usar para chaves de API?\nSegurança: - ✅ Chaves não ficam no código (evita commit acidental para GitHub) - ✅ Diferentes chaves para diferentes ambientes (dev, prod) - ✅ Fácil rotação de chaves sem mudar código\nComo funcionam no R:\n# Ler variável de ambiente\nSys.getenv(\"NOME_DA_VARIAVEL\")\n\n# Definir variável (apenas na sessão atual)\nSys.setenv(NOME_DA_VARIAVEL = \"valor\")\n\n# Listar todas\nSys.getenv()\n\nO arquivo .Renviron\nO que é .Renviron: - Arquivo de texto simples que define variáveis de ambiente - Carregado automaticamente quando R inicia - Localização: diretório home do usuário (~/.Renviron)\nVantagens: - Variáveis persistem entre sessões - Não precisa redefinir toda vez - Fácil de gerenciar\nComo criar/editar:\n# Abrir .Renviron no RStudio (cria se não existir)\nusethis::edit_r_environ()\n\n# Ou manualmente encontrar localização\npath.expand(\"~/.Renviron\")\nFormato do arquivo:\n# Arquivo .Renviron\n# Linhas começando com # são comentários\n# Formato: VARIAVEL=valor (SEM espaços ao redor do =)\n\nOPENAI_API_KEY=sk-proj-abcdefg123456789\nANTHROPIC_API_KEY=sk-ant-abcdefg123456789\n\n# ERRADO (com espaços):\n# VARIAVEL = valor\n\n# CERTO (sem espaços):\n# VARIAVEL=valor\nDepois de editar: 1. Salve o arquivo 2. Reinicie o R: Session → Restart R ou .rs.restartR() 3. Teste: Sys.getenv(\"OPENAI_API_KEY\")"
  },
  {
    "objectID": "materiais/dia4_ia.html#criando-chaves-de-api",
    "href": "materiais/dia4_ia.html#criando-chaves-de-api",
    "title": "Dia 4",
    "section": "2.2 Criando Chaves de API",
    "text": "2.2 Criando Chaves de API\n\nOpenAI (ChatGPT)\nPasso 1: Criar conta 1. Acesse https://platform.openai.com/ 2. Sign up (criar conta) ou Login 3. Verifique email\nPasso 2: Adicionar método de pagamento 1. Settings → Billing 2. Add payment method 3. Importante: Configure um limite de gastos! - Recommended: $5-10/mês para aprendizado - Evita surpresas na fatura\nPasso 3: Criar API Key 1. Settings → API Keys 2. Create new secret key 3. Dê um nome descritivo: “RStudio - Curso R” 4. ⚠️ COPIE A CHAVE AGORA! (só aparece uma vez) - Formato: sk-proj-... - Guarde em local seguro temporariamente\nPasso 4: Configurar no R\nusethis::edit_r_environ()\n# Adicione: OPENAI_API_KEY=sk-proj-SUA_CHAVE_AQUI\n# Salve e reinicie R\nPasso 5: Testar\nSys.getenv(\"OPENAI_API_KEY\")\n# Deve mostrar: \"sk-proj-...\"\n\n\nAnthropic (Claude)\nPasso 1: Criar conta 1. Acesse https://console.anthropic.com/ 2. Sign up ou Login 3. Verifique email\nPasso 2: Obter créditos - Contas novas ganham alguns créditos gratuitos ($5-10) - Depois precisa adicionar método de pagamento\nPasso 3: Criar API Key 1. Settings → API Keys 2. Create Key 3. Nome: “RStudio - Curso R” 4. ⚠️ COPIE A CHAVE! (só aparece uma vez) - Formato: sk-ant-...\nPasso 4: Configurar no R\nusethis::edit_r_environ()\n# Adicione: ANTHROPIC_API_KEY=sk-ant-SUA_CHAVE_AQUI\n# Salve e reinicie R\nPasso 5: Testar\nSys.getenv(\"ANTHROPIC_API_KEY\")\n# Deve mostrar: \"sk-ant-...\""
  },
  {
    "objectID": "materiais/dia4_ia.html#instalação-de-pacotes",
    "href": "materiais/dia4_ia.html#instalação-de-pacotes",
    "title": "Dia 4",
    "section": "2.3 Instalação de Pacotes",
    "text": "2.3 Instalação de Pacotes\n# Pacotes necessários\ninstall.packages(c(\n  \"gptstudio\",    # Interface para ChatGPT no RStudio\n  \"chattr\",       # Interface para múltiplos LLMs (incluindo Claude)\n  \"httr2\",        # Cliente HTTP moderno (para APIs)\n  \"jsonlite\"      # Trabalhar com JSON\n))\n\n# Verificar instalação\nlibrary(gptstudio)\nlibrary(chattr)\nlibrary(httr2)\nlibrary(jsonlite)\n\nO que cada pacote faz\ngptstudio: - Addins no RStudio para ChatGPT - Chat panel integrado - Seleção de código + análise - Geração de documentação - Correção de erros\nchattr: - Interface unificada para múltiplos LLMs - Suporta OpenAI, Anthropic, Google, outros - Chat interativo no console - Configuração flexível de modelos\nhttr2: - Cliente HTTP moderno para R - Fazer requisições para APIs - Melhor que httr (versão anterior) - Pipe-friendly (|&gt;)\njsonlite: - Converter entre R e JSON - APIs usam JSON para comunicação - Parse de respostas JSON"
  },
  {
    "objectID": "materiais/dia4_ia.html#conhecendo-o-gptstudio",
    "href": "materiais/dia4_ia.html#conhecendo-o-gptstudio",
    "title": "Dia 4",
    "section": "3.1 Conhecendo o gptstudio",
    "text": "3.1 Conhecendo o gptstudio\ngptstudio adiciona superpoderes de IA ao RStudio através de Addins.\nRecursos principais: 1. ChatGPT Chat: Painel de chat lateral 2. Comment Code: Adiciona comentários ao código 3. Explain Code: Explica código selecionado 4. Write Code: Gera código a partir de descrição 5. Edit Code: Refatora/melhora código\n\nAcessando os Addins\nMenu: Addins → GPTSTUDIO → ...\nAtalhos de teclado (configuráveis): - Tools → Modify Keyboard Shortcuts - Busque “GPTSTUDIO” - Configure atalhos personalizados"
  },
  {
    "objectID": "materiais/dia4_ia.html#chat-integrado",
    "href": "materiais/dia4_ia.html#chat-integrado",
    "title": "Dia 4",
    "section": "3.2 Chat Integrado",
    "text": "3.2 Chat Integrado\nComo abrir:\n# No console\ngptstudio::chat()\n\n# Ou: Addins → GPTSTUDIO → ChatGPT Chat\nInterface do Chat: - Painel lateral direito - Campo de input na parte inferior - Histórico de conversa acima - Botões para copiar/limpar\nUso básico:\n# Perguntas gerais\n\"Como criar um vetor em R?\"\n\n# Explicar conceitos\n\"O que é um data.frame?\"\n\n# Gerar código\n\"Crie uma função que calcule média e desvio padrão\"\n\n# Debugging\n\"Por que este código dá erro: mean(NA)\"\nDicas para bons prompts: - Seja específico - Dê contexto quando necessário - Peça explicações passo a passo - Solicite exemplos"
  },
  {
    "objectID": "materiais/dia4_ia.html#explicar-código-selecionado",
    "href": "materiais/dia4_ia.html#explicar-código-selecionado",
    "title": "Dia 4",
    "section": "3.3 Explicar Código Selecionado",
    "text": "3.3 Explicar Código Selecionado\nComo usar: 1. Selecione código no editor 2. Addins → GPTSTUDIO → Explain Code 3. Explicação aparece no console ou chat\nExemplo:\n# Selecione este código e peça explicação\ndados %&gt;%\n  filter(!is.na(valor)) %&gt;%\n  group_by(categoria) %&gt;%\n  summarize(\n    n = n(),\n    media = mean(valor),\n    dp = sd(valor)\n  ) %&gt;%\n  arrange(desc(media))\nO que o ChatGPT explica: - O que cada linha faz - Ordem de execução - Funções usadas - Resultado esperado"
  },
  {
    "objectID": "materiais/dia4_ia.html#comentar-código-automaticamente",
    "href": "materiais/dia4_ia.html#comentar-código-automaticamente",
    "title": "Dia 4",
    "section": "3.4 Comentar Código Automaticamente",
    "text": "3.4 Comentar Código Automaticamente\nComo usar: 1. Selecione código sem comentários 2. Addins → GPTSTUDIO → Comment Code 3. Comentários são inseridos automaticamente\nExemplo:\n\n# ANTES (sem comentários)\ncalcular_estatisticas &lt;- function(x) {\n  x &lt;- x[!is.na(x)]\n  list(\n    n = length(x),\n    media = mean(x),\n    mediana = median(x),\n    dp = sd(x),\n    min = min(x),\n    max = max(x)\n  )\n}\n\n# DEPOIS (com comentários gerados)\n# Calcula estatísticas descritivas de um vetor numérico\ncalcular_estatisticas &lt;- function(x) {\n  # Remove valores NA do vetor\n  x &lt;- x[!is.na(x)]\n  \n  # Retorna lista com estatísticas básicas\n  list(\n    n = length(x),           # Tamanho da amostra\n    media = mean(x),         # Média aritmética\n    mediana = median(x),     # Mediana (valor central)\n    dp = sd(x),             # Desvio padrão\n    min = min(x),           # Valor mínimo\n    max = max(x)            # Valor máximo\n  )\n}"
  },
  {
    "objectID": "materiais/dia4_ia.html#chamadas-via-api-manual-httr2",
    "href": "materiais/dia4_ia.html#chamadas-via-api-manual-httr2",
    "title": "Dia 4",
    "section": "3.5 Chamadas via API Manual (httr2)",
    "text": "3.5 Chamadas via API Manual (httr2)\nPara mais controle e automação, podemos chamar a API diretamente.\nEstrutura básica:\n\nlibrary(httr2)\nlibrary(jsonlite)\n\n# 1. ENDPOINT da API\nendpoint &lt;- \"https://api.openai.com/v1/chat/completions\"\n\n# 2. SEU PROMPT\nprompt &lt;- \"Explique o que este código faz: x &lt;- mean(1:10)\"\n\n# 3. CORPO DA REQUISIÇÃO (body)\nbody &lt;- list(\n  model = \"gpt-4o-mini\",  # Modelo a usar\n  messages = list(\n    list(\n      role = \"user\",       # Quem está falando (user/assistant/system)\n      content = prompt     # O que está dizendo\n    )\n  ),\n  temperature = 0.7,       # Criatividade (0-2, padrão 1)\n  max_tokens = 500         # Máximo de tokens na resposta\n)\n\n# 4. CRIAR REQUISIÇÃO\nreq &lt;- request(endpoint) |&gt;\n  req_method(\"POST\") |&gt;    # Método HTTP\n  req_headers(\n    Authorization = paste(\"Bearer\", Sys.getenv(\"OPENAI_API_KEY\")),\n    \"Content-Type\" = \"application/json\"\n  ) |&gt;\n  req_body_json(body)      # Corpo em JSON\n\n# 5. EXECUTAR REQUISIÇÃO\nresp &lt;- req_perform(req)\n\n# 6. EXTRAIR RESPOSTA\njson &lt;- resp_body_json(resp)\nresposta &lt;- json$choices[[1]]$message$content\n\n# 7. MOSTRAR\ncat(resposta)\n\nParâmetros importantes:\n\nmodel: Qual modelo usar\n\ngpt-4o-mini: Mais barato, rápido\ngpt-4o: Mais inteligente\ngpt-4-turbo: Balanceado\n\ntemperature: Criatividade (0-2)\n\n0: Determinístico, sempre mesma resposta\n1 (padrão): Balanceado\n2: Muito criativo, imprevisível\n\nmax_tokens: Limite de resposta\n\nControla tamanho e custo\n~500 tokens = ~375 palavras"
  },
  {
    "objectID": "materiais/dia4_ia.html#casos-de-uso-práticos-com-chatgpt",
    "href": "materiais/dia4_ia.html#casos-de-uso-práticos-com-chatgpt",
    "title": "Dia 4",
    "section": "3.6 Casos de Uso Práticos com ChatGPT",
    "text": "3.6 Casos de Uso Práticos com ChatGPT\n\nCaso 1: Explicar um erro\n\n# Código com erro\ndados &lt;- data.frame(x = 1:5, y = c(2, 4, NA, 8, 10))\nmean(dados$y)  # Retorna NA\n\n# Prompt para ChatGPT:\n\"Por que mean(dados$y) retorna NA? Como corrigir?\"\n\n# ChatGPT explica:\n# \"mean() retorna NA quando há valores ausentes.\n#  Solução: use na.rm = TRUE\n#  Exemplo: mean(dados$y, na.rm = TRUE)\"\n\n\n\nCaso 2: Refatorar função\n\n# Função verbosa\ncalcular &lt;- function(x, y) {\n  resultado1 &lt;- x + y\n  resultado2 &lt;- x * y\n  resultado3 &lt;- x / y\n  output &lt;- list()\n  output$soma &lt;- resultado1\n  output$produto &lt;- resultado2\n  output$divisao &lt;- resultado3\n  return(output)\n}\n\n# Prompt:\n\"Refatore esta função para ser mais concisa e clara\"\n\n# ChatGPT sugere:\ncalcular &lt;- function(x, y) {\n  list(\n    soma = x + y,\n    produto = x * y,\n    divisao = x / y\n  )\n}\n\n\n\nCaso 3: Gerar testes unitários\n\n# Sua função\nzscore &lt;- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n\n# Prompt:\n\"Gere testes unitários simples para validar esta função zscore\"\n\n# ChatGPT gera:\n# Teste 1: vetor normal\nteste1 &lt;- zscore(c(1, 2, 3, 4, 5))\nstopifnot(abs(mean(teste1)) &lt; 0.0001)  # Média ~0\n\n# Teste 2: vetor com NA\nteste2 &lt;- zscore(c(1, NA, 3))\nstopifnot(!is.na(teste2[1]))  # Remove NA\n\n# Teste 3: vetor constante\nteste3 &lt;- zscore(c(5, 5, 5))\nstopifnot(all(is.nan(teste3)))  # sd=0 → NaN"
  },
  {
    "objectID": "materiais/dia4_ia.html#conhecendo-o-chattr",
    "href": "materiais/dia4_ia.html#conhecendo-o-chattr",
    "title": "Dia 4",
    "section": "4.1 Conhecendo o chattr",
    "text": "4.1 Conhecendo o chattr\nchattr é uma interface unificada para múltiplos modelos de IA, incluindo Claude.\nVantagens: - Suporta Claude, ChatGPT, Google Gemini, outros - Interface simples e consistente - Chat interativo no console - Fácil trocar entre modelos\n\nConfiguração inicial\n\nlibrary(chattr)\n\n# Ver modelos disponíveis\nchattr_models()\n\n# Configurar Claude como padrão\nchattr_defaults(\n  provider = \"anthropic\",\n  model = \"claude-3-5-sonnet-latest\",\n  max_tokens = 1000\n)\n\n# Verificar configuração\nchattr_defaults()"
  },
  {
    "objectID": "materiais/dia4_ia.html#chat-interativo",
    "href": "materiais/dia4_ia.html#chat-interativo",
    "title": "Dia 4",
    "section": "4.2 Chat Interativo",
    "text": "4.2 Chat Interativo\nComo usar:\n\n# Iniciar chat no console\nchattr()\n\n# Interface interativa aparece\n# Digite sua pergunta e Enter\n# \"Como criar um data.frame em R?\"\n\n# Para sair: digite \"exit\" ou \"quit\"\n\nRecursos do chat: - Histórico de conversa mantido na sessão - Contexto preservado (lembra conversa anterior) - Copy/paste de código facilmente"
  },
  {
    "objectID": "materiais/dia4_ia.html#chat-programático",
    "href": "materiais/dia4_ia.html#chat-programático",
    "title": "Dia 4",
    "section": "4.3 Chat Programático",
    "text": "4.3 Chat Programático\n\n# Fazer pergunta diretamente\nresposta &lt;- chattr(\"Como calcular média em R?\")\ncat(resposta)\n\n# Com contexto/código\ncodigo &lt;- \"\ndados &lt;- data.frame(x = 1:5, y = c(2, 4, NA, 8, 10))\nmean(dados$y)\n\"\n\nresposta &lt;- chattr(paste0(\n  \"Explique o que acontece neste código:\\n\",\n  codigo\n))\ncat(resposta)\n\n# Salvar histórico\nhistorico &lt;- chattr_history()\nprint(historico)"
  },
  {
    "objectID": "materiais/dia4_ia.html#chamadas-via-api-manual-claude",
    "href": "materiais/dia4_ia.html#chamadas-via-api-manual-claude",
    "title": "Dia 4",
    "section": "4.4 Chamadas via API Manual (Claude)",
    "text": "4.4 Chamadas via API Manual (Claude)\nPara controle total e automação com Claude:\n\nlibrary(httr2)\nlibrary(jsonlite)\n\n# 1. ENDPOINT\nendpoint &lt;- \"https://api.anthropic.com/v1/messages\"\n\n# 2. PROMPT\nprompt &lt;- \"Revise esta função e torne-a mais robusta a NAs:\n\nsoma_media &lt;- function(x) { \n  sum(x) / length(x) \n}\"\n\n# 3. CORPO DA REQUISIÇÃO\nbody &lt;- list(\n  model = \"claude-3-5-sonnet-latest\",\n  max_tokens = 1000,\n  messages = list(\n    list(\n      role = \"user\",\n      content = prompt\n    )\n  )\n)\n\n# 4. CRIAR REQUISIÇÃO\nreq &lt;- request(endpoint) |&gt;\n  req_method(\"POST\") |&gt;\n  req_headers(\n    Authorization = paste(\"Bearer\", Sys.getenv(\"ANTHROPIC_API_KEY\")),\n    \"anthropic-version\" = \"2023-06-01\",  # Versão da API\n    \"content-type\" = \"application/json\"\n  ) |&gt;\n  req_body_json(body)\n\n# 5. EXECUTAR\nresp &lt;- req_perform(req)\n\n# 6. EXTRAIR RESPOSTA\njson &lt;- resp_body_json(resp)\nresposta &lt;- json$content[[1]]$text\n\n# 7. MOSTRAR\ncat(resposta)\n\nDiferenças da API Claude:\n\nHeader extra: anthropic-version\nEstrutura de resposta diferente: json$content[[1]]$text\nSem parâmetro temperature (usa top_p e top_k)\nmax_tokens é obrigatório"
  },
  {
    "objectID": "materiais/dia4_ia.html#casos-de-uso-práticos-com-claude",
    "href": "materiais/dia4_ia.html#casos-de-uso-práticos-com-claude",
    "title": "Dia 4",
    "section": "4.5 Casos de Uso Práticos com Claude",
    "text": "4.5 Casos de Uso Práticos com Claude\n\nCaso 1: Análise profunda de código\n\n# Código complexo para analisar\npipeline_complexo &lt;- \"\nlibrary(tidyverse)\n\nresultado &lt;- mtcars %&gt;%\n  mutate(\n    eficiencia = mpg / wt,\n    categoria_cyl = case_when(\n      cyl &lt;= 4 ~ 'Pequeno',\n      cyl &lt;= 6 ~ 'Médio',\n      TRUE ~ 'Grande'\n    )\n  ) %&gt;%\n  group_by(categoria_cyl, gear) %&gt;%\n  summarize(\n    n = n(),\n    media_ef = mean(eficiencia),\n    dp_ef = sd(eficiencia),\n    .groups = 'drop'\n  ) %&gt;%\n  filter(n &gt;= 3) %&gt;%\n  arrange(desc(media_ef))\n\"\n\n# Prompt para Claude:\n\"Analise este pipeline tidyverse em detalhes:\n1. O que cada etapa faz?\n2. Há potenciais problemas ou melhorias?\n3. O código está otimizado?\n\nCódigo:\n[cole o código acima]\"\n\n# Claude fornece análise profunda:\n# - Explicação linha por linha\n# - Identificação de possíveis NAs não tratados\n# - Sugestões de otimização\n# - Alertas sobre edge cases\n\n\n\nCaso 2: Gerar função robusta\n\n# Prompt para Claude:\n\"Crie uma função em R que:\n1. Receba um data.frame e nome de coluna numérica\n2. Remova NAs\n3. Retorne lista com média e desvio padrão\n4. Inclua validações de tipo e mensagens de erro claras\n5. Documente com comentários\"\n\n# Claude gera:\n#' Calcula estatísticas descritivas de uma coluna numérica\n#'\n#' @param df Data frame contendo os dados\n#' @param col_name String com nome da coluna numérica\n#' @return Lista com média e desvio padrão\ncalcular_stats &lt;- function(df, col_name) {\n  # Validar entrada: df deve ser data.frame\n  if (!is.data.frame(df)) {\n    stop(\"Erro: 'df' deve ser um data.frame\")\n  }\n  \n  # Validar: coluna existe\n  if (!col_name %in% names(df)) {\n    stop(paste0(\"Erro: coluna '\", col_name, \"' não encontrada\"))\n  }\n  \n  # Extrair coluna\n  coluna &lt;- df[[col_name]]\n  \n  # Validar: coluna é numérica\n  if (!is.numeric(coluna)) {\n    stop(paste0(\"Erro: coluna '\", col_name, \"' não é numérica\"))\n  }\n  \n  # Remover NAs e avisar se houver\n  n_nas &lt;- sum(is.na(coluna))\n  if (n_nas &gt; 0) {\n    message(paste0(\"Aviso: \", n_nas, \" valores NA foram removidos\"))\n  }\n  coluna_limpa &lt;- na.omit(coluna)\n  \n  # Validar: ainda há dados após remover NAs\n  if (length(coluna_limpa) == 0) {\n    stop(\"Erro: nenhum valor válido após remover NAs\")\n  }\n  \n  # Calcular estatísticas\n  list(\n    media = mean(coluna_limpa),\n    desvio_padrao = sd(coluna_limpa),\n    n_observacoes = length(coluna_limpa),\n    n_nas_removidos = n_nas\n  )\n}\n\n# Teste\ndados &lt;- data.frame(x = c(1, 2, NA, 4, 5), y = letters[1:5])\ncalcular_stats(dados, \"x\")\n\n\n\nCaso 3: Explicar traceback complexo\n\n# Erro complexo\nerro &lt;- \"\nError in mutate(., nova_col = antiga_col * 2) : \n  ℹ In argument: `nova_col = antiga_col * 2`.\nCaused by error:\n! object 'antiga_col' not found\nRun `rlang::last_trace()` to see where the error occurred.\n\"\n\n# Prompt para Claude:\n\"Explique este erro do R e como corrigi-lo:\n[cole o erro acima]\"\n\n# Claude explica:\n# - O que significa cada linha do erro\n# - Por que ocorreu (coluna não existe)\n# - Como diagnosticar (verificar names(dados))\n# - Como corrigir (usar nome correto ou criar coluna)\n# - Dicas para evitar no futuro"
  },
  {
    "objectID": "materiais/dia4_ia.html#tarefa-1-revisar-código-com-gptstudio",
    "href": "materiais/dia4_ia.html#tarefa-1-revisar-código-com-gptstudio",
    "title": "Dia 4",
    "section": "5.1 Tarefa 1: Revisar código com gptstudio",
    "text": "5.1 Tarefa 1: Revisar código com gptstudio\nObjetivo: Usar ChatGPT para revisar um script tidyverse e propor melhorias.\nCódigo para revisar:\n\n# Salve este código em: scripts/04_ia_integracao_gptstudio.R\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n# Análise de pinguins\ndados &lt;- penguins\ndados &lt;- dados %&gt;% filter(!is.na(bill_length_mm))\ndados &lt;- dados %&gt;% filter(!is.na(bill_depth_mm))\ndados &lt;- dados %&gt;% filter(!is.na(flipper_length_mm))\ndados &lt;- dados %&gt;% filter(!is.na(body_mass_g))\n\nresultado &lt;- dados %&gt;%\n  mutate(bill_ratio = bill_length_mm / bill_depth_mm) %&gt;%\n  group_by(species) %&gt;%\n  summarize(\n    n = n(),\n    bill_ratio_mean = mean(bill_ratio),\n    bill_ratio_sd = sd(bill_ratio),\n    mass_mean = mean(body_mass_g),\n    mass_sd = sd(body_mass_g)\n  )\n\nprint(resultado)\n\nPassos:\n\nSelecione todo o código\nUse gptstudio → Explain Code\nDepois use gptstudio → Write Code com prompt: “Sugira 2 melhorias para este código”\n\nMelhorias esperadas do ChatGPT:\n\n# VERSÃO MELHORADA\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n# Melhoria 1: Usar drop_na() em vez de múltiplos filter\n# Melhoria 2: Encadear operações em um único pipeline\nresultado &lt;- penguins %&gt;%\n  drop_na(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g) %&gt;%\n  mutate(bill_ratio = bill_length_mm / bill_depth_mm) %&gt;%\n  group_by(species) %&gt;%\n  summarize(\n    n = n(),\n    across(\n      c(bill_ratio, body_mass_g),\n      list(mean = mean, sd = sd),\n      .names = \"{.col}_{.fn}\"\n    )\n  )\n\nprint(resultado)"
  },
  {
    "objectID": "materiais/dia4_ia.html#tarefa-2-gerar-função-com-chattr-claude",
    "href": "materiais/dia4_ia.html#tarefa-2-gerar-função-com-chattr-claude",
    "title": "Dia 4",
    "section": "5.2 Tarefa 2: Gerar função com chattr (Claude)",
    "text": "5.2 Tarefa 2: Gerar função com chattr (Claude)\nObjetivo: Usar Claude para gerar uma função robusta.\nEspecificações: - Receber um data.frame e nome de coluna numérica - Remover NAs - Retornar média e desvio-padrão com nomes claros - Incluir validação de tipos e mensagens de erro úteis\nPrompt para Claude:\n\n# No console R:\nchattr(\"\nCrie uma função em R chamada 'estatisticas_coluna' que:\n\n1. Receba dois argumentos:\n   - df: um data.frame\n   - col_name: string com nome da coluna\n\n2. Valide que:\n   - df é um data.frame (se não, erro claro)\n   - col_name existe em df (se não, erro claro)\n   - A coluna é numérica (se não, erro claro)\n\n3. Remova valores NA e avise quantos foram removidos\n\n4. Retorne uma lista nomeada com:\n   - media: média da coluna\n   - desvio_padrao: desvio padrão da coluna\n   - n_validos: número de observações válidas\n   - n_nas: número de NAs removidos\n\n5. Adicione documentação roxygen2 e comentários\n\n6. Inclua exemplo de uso\n\")\n\nSalve a resposta em: scripts/04_ia_integracao_claude.R"
  },
  {
    "objectID": "materiais/dia4_ia.html#tarefa-3-documento-de-reflexão",
    "href": "materiais/dia4_ia.html#tarefa-3-documento-de-reflexão",
    "title": "Dia 4",
    "section": "5.3 Tarefa 3: Documento de Reflexão",
    "text": "5.3 Tarefa 3: Documento de Reflexão\nObjetivo: Documentar o processo e aprendizados.\nCrie: docs/relatorio_ia.Rmd\n\n# Arquivo: docs/relatorio_ia.Rmd\n---\ntitle: \"Integração de IA no RStudio - Reflexões\"\nauthor: \"Seu Nome\"\ndate: \"`r Sys.Date()`\"\noutput: html_document\n---\n\n## Tarefa 1: Revisão com ChatGPT\n\n**Código Original:**\n[Cole o código original aqui]\n\n**Sugestões do ChatGPT:**\n1. [Descreva a primeira sugestão]\n2. [Descreva a segunda sugestão]\n\n**O que adotei e por quê:**\n[Explique quais sugestões você implementou e sua justificativa]\n\n**O que não adotei e por quê:**\n[Se houver, explique o que não usou e por quê]\n\n## Tarefa 2: Função com Claude\n\n**Especificações solicitadas:**\n- [Liste as especificações]\n\n**Código gerado pelo Claude:**\n\n\n# [Cole a função gerada]\n\nTestes realizados:\n\n# [Cole seus testes]\n\nAvaliação: - Pontos positivos: [O que funcionou bem] - Ajustes necessários: [O que você teve que modificar] - Aprendizados: [O que você aprendeu no processo]"
  },
  {
    "objectID": "materiais/dia4_ia.html#comparação-chatgpt-vs-claude",
    "href": "materiais/dia4_ia.html#comparação-chatgpt-vs-claude",
    "title": "Dia 4",
    "section": "Comparação ChatGPT vs Claude",
    "text": "Comparação ChatGPT vs Claude\nChatGPT: - Velocidade: [sua observação] - Qualidade: [sua observação] - Melhor para: [sua conclusão]\nClaude: - Velocidade: [sua observação] - Qualidade: [sua observação] - Melhor para: [sua conclusão]"
  },
  {
    "objectID": "materiais/dia4_ia.html#reflexão-final",
    "href": "materiais/dia4_ia.html#reflexão-final",
    "title": "Dia 4",
    "section": "Reflexão Final",
    "text": "Reflexão Final\n[Escreva um parágrafo sobre como você pretende usar IA no seu trabalho com R]\n\n---\n\n## 5.4 Checklist Final\n\nAntes de fazer o commit final, verifique:\n\n- [ ] `.Renviron` configurado com ambas as chaves\n  ```r\n  Sys.getenv(\"OPENAI_API_KEY\")  # Deve mostrar sk-proj-...\n  Sys.getenv(\"ANTHROPIC_API_KEY\")  # Deve mostrar sk-ant-...\n\nPacotes instalados\nlibrary(gptstudio)\nlibrary(chattr)\nlibrary(httr2)\nlibrary(jsonlite)\nAddins do gptstudio funcionando\n\nAddins → GPTSTUDIO → ChatGPT Chat abre?\n\nChamada mínima via httr2 para cada API funciona\n# Teste ChatGPT (simplificado)\nreq &lt;- request(\"https://api.openai.com/v1/chat/completions\") |&gt;\n  req_method(\"POST\") |&gt;\n  req_headers(Authorization = paste(\"Bearer\", Sys.getenv(\"OPENAI_API_KEY\"))) |&gt;\n  req_body_json(list(\n    model = \"gpt-4o-mini\",\n    messages = list(list(role = \"user\", content = \"Diga olá\"))\n  ))\nresp &lt;- req_perform(req)\nresp_body_json(resp)$choices[[1]]$message$content\n\n# Teste Claude (simplificado)\nreq &lt;- request(\"https://api.anthropic.com/v1/messages\") |&gt;\n  req_method(\"POST\") |&gt;\n  req_headers(\n    Authorization = paste(\"Bearer\", Sys.getenv(\"ANTHROPIC_API_KEY\")),\n    \"anthropic-version\" = \"2023-06-01\",\n    \"content-type\" = \"application/json\"\n  ) |&gt;\n  req_body_json(list(\n    model = \"claude-3-5-sonnet-latest\",\n    max_tokens = 100,\n    messages = list(list(role = \"user\", content = \"Diga olá\"))\n  ))\nresp &lt;- req_perform(req)\nresp_body_json(resp)$content[[1]]$text\nArquivos criados:\n\nscripts/04_ia_integracao_gptstudio.R\nscripts/04_ia_integracao_claude.R\ndocs/relatorio_ia.Rmd"
  },
  {
    "objectID": "materiais/dia4_ia.html#commit-e-push",
    "href": "materiais/dia4_ia.html#commit-e-push",
    "title": "Dia 4",
    "section": "5.5 Commit e Push",
    "text": "5.5 Commit e Push\n# Adicionar arquivos\ngit add scripts/04_*.R docs/relatorio_ia.Rmd\n\n# Commit descritivo\ngit commit -m \"feat: integração ChatGPT e Claude no RStudio (Dia 4)\n\n- Configura APIs OpenAI e Anthropic\n- Implementa revisão de código com gptstudio\n- Gera função robusta com Claude\n- Documenta processo e aprendizados\"\n\n# Push para seu fork\ngit push origin main\nIMPORTANTE: NÃO faça commit do arquivo .Renviron com suas chaves!"
  },
  {
    "objectID": "materiais/dia4_ia.html#documentação-oficial",
    "href": "materiais/dia4_ia.html#documentação-oficial",
    "title": "Dia 4",
    "section": "Documentação Oficial",
    "text": "Documentação Oficial\nOpenAI: - API Reference: https://platform.openai.com/docs/api-reference - Pricing: https://openai.com/pricing - Best Practices: https://platform.openai.com/docs/guides/prompt-engineering\nAnthropic: - API Reference: https://docs.anthropic.com/claude/reference - Pricing: https://www.anthropic.com/pricing - Prompt Engineering: https://docs.anthropic.com/claude/docs/intro-to-prompting\nPacotes R: - gptstudio: https://github.com/MichelNivard/gptstudio - chattr: https://mlverse.github.io/chattr/ - httr2: https://httr2.r-lib.org/"
  },
  {
    "objectID": "materiais/dia4_ia.html#tutoriais-e-cursos",
    "href": "materiais/dia4_ia.html#tutoriais-e-cursos",
    "title": "Dia 4",
    "section": "Tutoriais e Cursos",
    "text": "Tutoriais e Cursos\n\nPrompt Engineering Guide: https://www.promptingguide.ai/\nLearn Prompting: https://learnprompting.org/\nOpenAI Cookbook: https://cookbook.openai.com/"
  },
  {
    "objectID": "materiais/dia4_ia.html#comunidades",
    "href": "materiais/dia4_ia.html#comunidades",
    "title": "Dia 4",
    "section": "Comunidades",
    "text": "Comunidades\n\nr/ChatGPT: https://reddit.com/r/ChatGPT\nr/ClaudeAI: https://reddit.com/r/ClaudeAI\nRStudio Community: https://community.rstudio.com/"
  },
  {
    "objectID": "materiais/dia4_ia.html#erro-api-key-inválida",
    "href": "materiais/dia4_ia.html#erro-api-key-inválida",
    "title": "Dia 4",
    "section": "Erro: API Key inválida",
    "text": "Erro: API Key inválida\nError: 401 Unauthorized\nCausas: - Chave copiada errada - Chave expirada - Chave não configurada corretamente\nSoluções: 1. Verifique: Sys.getenv(\"OPENAI_API_KEY\") 2. Recrie chave no dashboard 3. Edite .Renviron: usethis::edit_r_environ() 4. Reinicie R"
  },
  {
    "objectID": "materiais/dia4_ia.html#erro-rate-limit-excedido",
    "href": "materiais/dia4_ia.html#erro-rate-limit-excedido",
    "title": "Dia 4",
    "section": "Erro: Rate Limit excedido",
    "text": "Erro: Rate Limit excedido\nError: 429 Too Many Requests\nCausa: Muitas requisições em pouco tempo\nSolução: - Espere 1 minuto - Reduza frequência de chamadas - Use modelo mais barato para testes"
  },
  {
    "objectID": "materiais/dia4_ia.html#erro-insufficient-credits",
    "href": "materiais/dia4_ia.html#erro-insufficient-credits",
    "title": "Dia 4",
    "section": "Erro: Insufficient credits",
    "text": "Erro: Insufficient credits\nError: 402 Payment Required\nCausa: Créditos/limite de gastos esgotado\nSolução: - Adicione créditos (OpenAI/Anthropic dashboard) - Configure limite de gastos - Verifique método de pagamento"
  },
  {
    "objectID": "materiais/dia4_ia.html#gptstudio-não-aparece-nos-addins",
    "href": "materiais/dia4_ia.html#gptstudio-não-aparece-nos-addins",
    "title": "Dia 4",
    "section": "gptstudio não aparece nos Addins",
    "text": "gptstudio não aparece nos Addins\nSoluções: 1. Reinstale: install.packages(\"gptstudio\") 2. Reinicie RStudio 3. Verifique se instalou corretamente: library(gptstudio)"
  },
  {
    "objectID": "materiais/dia4_ia.html#problemas-de-conexão",
    "href": "materiais/dia4_ia.html#problemas-de-conexão",
    "title": "Dia 4",
    "section": "Problemas de conexão",
    "text": "Problemas de conexão\nError: Could not resolve host\nSoluções: - Verifique conexão com internet - Teste: ping api.openai.com - Desative VPN se houver - Configure proxy se necessário"
  },
  {
    "objectID": "materiais/dia4_ia.html#prompts-eficazes",
    "href": "materiais/dia4_ia.html#prompts-eficazes",
    "title": "Dia 4",
    "section": "Prompts Eficazes",
    "text": "Prompts Eficazes\nSeja específico: ❌ “Melhore este código” ✅ “Refatore este código para usar tidyverse em vez de loops for”\nDê contexto: ❌ “Como fazer isso?” ✅ “Tenho um data.frame com colunas x, y, z. Como filtrar linhas onde x &gt; 10 e calcular média de y por z?”\nPeça passo a passo: ✅ “Explique passo a passo como criar um gráfico ggplot2 com facetas”\nSolicite validações: ✅ “Gere esta função e inclua validação de inputs e tratamento de erros”"
  },
  {
    "objectID": "materiais/dia4_ia.html#iteração-com-ia",
    "href": "materiais/dia4_ia.html#iteração-com-ia",
    "title": "Dia 4",
    "section": "Iteração com IA",
    "text": "Iteração com IA\n\nPrimeira tentativa: Prompt simples\nRefinar: Se não satisfatório, refine o prompt\nEspecificar: Adicione detalhes que faltaram\nValidar: Sempre teste o código gerado\nIterar: Peça ajustes específicos"
  },
  {
    "objectID": "materiais/dia4_ia.html#quando-não-usar-ia",
    "href": "materiais/dia4_ia.html#quando-não-usar-ia",
    "title": "Dia 4",
    "section": "Quando NÃO usar IA",
    "text": "Quando NÃO usar IA\n\n❌ Código com dados sensíveis/confidenciais\n❌ Decisões críticas sem validação\n❌ Substituir documentação oficial\n❌ Aprendizado de conceitos fundamentais (use IA como complemento, não substituto)"
  },
  {
    "objectID": "materiais/dia4_ia.html#quando-sim-usar-ia",
    "href": "materiais/dia4_ia.html#quando-sim-usar-ia",
    "title": "Dia 4",
    "section": "Quando SIM usar IA",
    "text": "Quando SIM usar IA\n\n✅ Entender erros complexos\n✅ Gerar boilerplate code\n✅ Refatorar código existente\n✅ Criar testes\n✅ Documentar código\n✅ Aprender novas funções/pacotes\n✅ Brainstorming de soluções"
  },
  {
    "objectID": "materiais/dia4_ia.html#o-que-você-aprendeu",
    "href": "materiais/dia4_ia.html#o-que-você-aprendeu",
    "title": "Dia 4",
    "section": "O que você aprendeu:",
    "text": "O que você aprendeu:\nDia 1: - Fundamentos de R (vetores, data.frames, fatores) - Git e GitHub - Workflow com fork - Organização de projetos\nDia 2: - Operadores e condicionais - Funções personalizadas - Tidyverse e dplyr - Manipulação de datas\nDia 3: - Transformação com tidyr - Tratamento de NAs - I/O de dados - Visualização com ggplot2\nDia 4: - Integração de IA no workflow - APIs OpenAI e Anthropic - gptstudio e chattr - Uso responsável de IA"
  },
  {
    "objectID": "materiais/dia4_ia.html#próximos-passos",
    "href": "materiais/dia4_ia.html#próximos-passos",
    "title": "Dia 4",
    "section": "Próximos passos:",
    "text": "Próximos passos:\n\nPratique regularmente - Consistência &gt; Intensidade\nTrabalhe em projetos reais - Aplique em seus dados\nParticipe da comunidade R - Twitter, Reddit, RStudio Community\nContinue aprendendo:\n\nR for Data Science: https://r4ds.hadley.nz/\nAdvanced R: https://adv-r.hadley.nz/\nTidyTuesday: https://github.com/rfordatascience/tidytuesday\n\nUse IA como assistente - Mas sempre entenda o código!\n\n\nObrigado por participar!\nMantenha contato: - Email: junqueiravinicius@hotmail.com - GitHub: https://github.com/viniciusjunqueira/curso-r-github-ia - LinkedIn: linkedin.com/in/junqueiravinicius\nBons códigos e boas análises! 🚀📊"
  }
]