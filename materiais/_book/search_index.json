[["sobre-o-autor.html", "1 Sobre o Autor 1.1 Vin√≠cius Junqueira 1.2 Forma√ß√£o Acad√™mica 1.3 Trajet√≥ria Profissional 1.4 Expertise e √Åreas de Atua√ß√£o 1.5 Por Que Ensino R? 1.6 Minha Miss√£o com Este Curso 1.7 Vamos Juntos!", " 1 Sobre o Autor 1.1 Vin√≠cius Junqueira Ol√°! Meu nome √© Vin√≠cius Junqueira e ser√° um prazer gui√°-lo nesta jornada pelo mundo do R e programa√ß√£o cient√≠fica b√°sica. 1.2 Forma√ß√£o Acad√™mica Sou graduado em Medicina Veterin√°ria pela Universidade de Bras√≠lia (UnB), com mestrado e doutorado em Gen√©tica e Melhoramento pela Universidade Federal de Vi√ßosa (UFV). Minha trajet√≥ria acad√™mica sempre esteve ligada √† compreens√£o de dados complexos e √† resolu√ß√£o de problemas usando ferramentas quantitativas e computacionais. Em 2016, tive a oportunidade de atuar como pesquisador convidado no grupo de melhoramento gen√©tico animal da University of Georgia, nos Estados Unidos, experi√™ncia que ampliou significativamente minha vis√£o sobre metodologias avan√ßadas de an√°lise de dados e programa√ß√£o cient√≠fica. 1.3 Trajet√≥ria Profissional No Brasil, iniciei minha carreira como pesquisador em gen√©tica quantitativa na Monsanto/Bayer, onde contribu√≠ para o desenvolvimento t√©cnico-cient√≠fico de projetos em programas de melhoramento de milho e soja no Brasil, Argentina, M√©xico, Estados Unidos e Europa. Entre 2021 e 2024, liderei os programas de melhoramento de soja no Brasil e Argentina, coordenando a implementa√ß√£o de estrat√©gias inovadoras que inclu√≠ram a introdu√ß√£o da biotecnologia INTACTA3, prevista para lan√ßamento comercial no Brasil em 2030. Desde 2024, coordeno o desenvolvimento de estrat√©gias gen√©tico-quantitativas para otimizar a aloca√ß√£o de fenotipagem a campo nas culturas de milho e soja nos Estados Unidos, trabalhando com grandes volumes de dados e modelos preditivos complexos. Paralelamente √†s atividades na Bayer, mantenho colabora√ß√µes ativas com projetos de pesquisa junto √† Embrapa Pecu√°ria Sul, Universidade Federal de Vi√ßosa, Universidade Federal de Goi√°s, Universidade Federal de Uberl√¢ndia, Purdue University e University of Georgia. Integro tamb√©m a equipe t√©cnica dos programas de melhoramento gen√©tico das ra√ßas Hereford e Braford (PampaPlus/ABHB) e do Programa de Melhoramento de Bovinos de Carne (PROMEBO/ANC). 1.4 Expertise e √Åreas de Atua√ß√£o Minha experi√™ncia abrange tanto o melhoramento gen√©tico de plantas quanto de animais, com foco em: Estima√ß√£o de valores gen√©ticos por modelos tradicionais e gen√¥micos Modelos multicaracter√≠sticos e an√°lise de intera√ß√£o gen√≥tipo-ambiente √çndices de sele√ß√£o bioecon√¥micos Programa√ß√£o cient√≠fica em Fortran, R e Python M√©todos de otimiza√ß√£o para sele√ß√£o de parentais e acasalamentos An√°lise de grandes conjuntos de dados e tomada de decis√µes baseada em evid√™ncias 1.5 Por Que Ensino R? Ao longo da minha trajet√≥ria, R se tornou a ferramenta fundamental do meu trabalho di√°rio. Foi atrav√©s do R que consegui analisar milh√µes de dados fenot√≠picos e genot√≠picos, implementar modelos estat√≠sticos complexos, criar visualiza√ß√µes que comunicam resultados para diferentes p√∫blicos, e desenvolver ferramentas computacionais que impactam decis√µes estrat√©gicas em programas de melhoramento. Lembro-me perfeitamente de quando comecei a aprender R durante meu mestrado. No in√≠cio, tudo parecia confuso e intimidador. Passei por frustra√ß√µes, erros incompreens√≠veis e momentos em que pensei em desistir. Mas persisti, e posso afirmar sem hesita√ß√£o: aprender linguagens de programa√ß√£o foi uma das decis√µes mais transformadoras da minha carreira. O R me deu autonomia para resolver problemas, liberdade para explorar dados de formas criativas, e a capacidade de comunicar descobertas cient√≠ficas com clareza. Ele abriu portas profissionais que eu nem imaginava existirem e me permitiu colaborar com pesquisadores ao redor do mundo. 1.6 Minha Miss√£o com Este Curso Decidi criar este curso porque acredito que todo mundo pode aprender R, independentemente do background. Voc√™ n√£o precisa ser um g√™nio da matem√°tica ou ter nascido programando. O que voc√™ precisa √© de um caminho bem estruturado, exemplos pr√°ticos, e algu√©m que j√° passou pelas mesmas dificuldades para gui√°-lo. Minha abordagem √© diferente porque: Aprendi da forma dif√≠cil e sei exatamente onde iniciantes trope√ßam Uso R diariamente em problemas reais, ent√£o ensino o que realmente funciona Integro ferramentas modernas de IA ao aprendizado, acelerando sua curva de evolu√ß√£o Valorizo a aplica√ß√£o pr√°tica sobre teoria abstrata Este curso √© resultado de anos utilizando R no melhoramento gen√©tico. Refinei o conte√∫do com base em de d√∫vidas reais, erros comuns e feedbacks valiosos. Meu objetivo √© que voc√™ n√£o apenas aprenda R, mas que desenvolva confian√ßa para us√°-lo como ferramenta transformadora em sua pr√≥pria jornada profissional. 1.7 Vamos Juntos! Se voc√™ est√° come√ßando do zero, saiba que j√° estive exatamente onde voc√™ est√°. Se tem alguma experi√™ncia, vamos aprofundar seu conhecimento e apresentar ferramentas modernas que aumentar√£o sua produtividade. Independentemente do seu ponto de partida, estou aqui para ajud√°-lo a ter sucesso. Bem-vindo ao curso. Vamos transformar dados em conhecimento! Contato: GitHub: github.com/viniciusjunqueira LinkedIn: linkedin.com/junqueiravinicius Email: junqueiravinicius@hotmail.com "],["bem-vindo-ao-curso.html", "2 Bem-vindo ao curso 2.1 Pr√©-requisitos 2.2 Objetivos de Aprendizagem 2.3 Metodologia", " 2 Bem-vindo ao curso Introdu√ß√£o Programa√ß√£o em R com GitHub, ChatGPT e Claude Este curso foi desenvolvido para quem deseja dar os primeiros passos no mundo da an√°lise de dados usando R, uma das linguagens mais poderosas e populares para ci√™ncia de dados. Em 16 horas de conte√∫do pr√°tico e objetivo, voc√™ aprender√° n√£o apenas a programar em R, mas tamb√©m a integrar ferramentas modernas que potencializam seu aprendizado e produtividade. 2.1 Pr√©-requisitos Este curso foi pensado para ser acess√≠vel a todos, independentemente da sua experi√™ncia pr√©via com programa√ß√£o. Os √∫nicos requisitos s√£o: Computador com acesso √† internet (Windows, Mac ou Linux) Curiosidade e vontade de aprender Disposi√ß√£o para praticar e experimentar N√£o √© necess√°rio conhecimento pr√©vio em programa√ß√£o, estat√≠stica ou an√°lise de dados. Se voc√™ nunca escreveu uma linha de c√≥digo, n√£o se preocupe! O curso foi estruturado pensando exatamente em voc√™. Iniciaremos do zero, apresentando cada conceito de forma clara e progressiva. 2.2 Objetivos de Aprendizagem Ao final deste curso, voc√™ ser√° capaz de: Fundamentos de R e An√°lise de Dados: Compreender a sintaxe b√°sica da linguagem R e executar opera√ß√µes fundamentais Importar, manipular e transformar dados de diferentes fontes utilizando o tidyverse Aplicar t√©cnicas de limpeza e prepara√ß√£o de dados para an√°lises robustas Realizar an√°lises explorat√≥rias e extrair insights relevantes de conjuntos de dados Visualiza√ß√£o de Dados: Criar visualiza√ß√µes profissionais e informativas usando ggplot2 Escolher o tipo adequado de gr√°fico para diferentes tipos de dados e mensagens Personalizar cores, temas e elementos visuais para comunicar resultados com clareza Produzir gr√°ficos prontos para apresenta√ß√µes, relat√≥rios e publica√ß√µes Controle de Vers√£o e Colabora√ß√£o: Utilizar Git e GitHub para versionar e documentar seu c√≥digo Colaborar em projetos de dados de forma organizada e profissional Compreender fluxos de trabalho modernos em ci√™ncia de dados Publicar e compartilhar seus projetos com a comunidade Aprendizado Assistido por IA: Utilizar ferramentas de IA (ChatGPT e Claude) como assistentes no aprendizado Formular perguntas eficazes para obter ajuda precisa na resolu√ß√£o de problemas Interpretar e adaptar sugest√µes de c√≥digo geradas por IA Acelerar seu processo de aprendizagem combinando estudo tradicional e ferramentas modernas 2.3 Metodologia O curso adota uma abordagem pr√°tica e hands-on, onde voc√™ aprender√° fazendo. Nossa metodologia se baseia em tr√™s pilares fundamentais: Aprendizagem Ativa: Cada conceito apresentado √© imediatamente seguido de exerc√≠cios pr√°ticos. Acreditamos que a melhor forma de aprender programa√ß√£o √© escrevendo c√≥digo. Voc√™ trabalhar√° com dados reais e enfrentar√° problemas aut√™nticos desde o primeiro dia, construindo confian√ßa e compet√™ncia progressivamente. Estrutura Modular: O conte√∫do est√° organizado em m√≥dulos que se constroem de forma l√≥gica e incremental. Come√ßamos com os fundamentos do R, avan√ßamos para manipula√ß√£o de dados com tidyverse, exploramos visualiza√ß√£o com ggplot2, e integramos controle de vers√£o e ferramentas de IA ao longo do caminho. Cada m√≥dulo √© independente mas conectado, permitindo que voc√™ compreenda tanto os detalhes quanto o panorama geral. Aprendizado Assistido por IA: Uma das caracter√≠sticas mais inovadoras deste curso √© o uso integrado de intelig√™ncia artificial como ferramenta pedag√≥gica. Voc√™ aprender√° n√£o apenas R, mas tamb√©m como usar ChatGPT e Claude para tirar d√∫vidas, debugar c√≥digo, explorar alternativas e acelerar seu aprendizado. Esta √© uma habilidade essencial no cen√°rio atual da programa√ß√£o e ci√™ncia de dados. Projetos Pr√°ticos: Ao inv√©s de exerc√≠cios isolados, voc√™ desenvolver√° pequenos projetos que simulam situa√ß√µes reais de an√°lise de dados. Isso inclui trabalhar com datasets p√∫blicos, criar visualiza√ß√µes para comunicar resultados, e documentar seu trabalho de forma profissional usando GitHub. Suporte e Comunidade: Durante todo o curso, voc√™ ter√° acesso a materiais de refer√™ncia, exemplos comentados e uma comunidade de colegas aprendendo junto com voc√™. Incentivamos a colabora√ß√£o e a troca de experi√™ncias, pois aprendemos muito ao ensinar e compartilhar conhecimento. Prepare-se para uma jornada transformadora! Ao final destas 16 horas, voc√™ n√£o apenas saber√° programar em R, mas ter√° desenvolvido uma mentalidade anal√≠tica e as ferramentas necess√°rias para continuar evoluindo de forma aut√¥noma. Seja bem-vindo ao fascinante mundo da an√°lise de dados! "],["cronograma.html", "3 Cronograma 3.1 Pr√©-requisitos T√©cnicos 3.2 Estrutura Pedag√≥gica e Filosofia 3.3 Pacotes R Necess√°rios 3.4 Dia 1: 17/11 (Segunda) ‚Äî Fundamentos e Ambiente de Trabalho 3.5 Dia 2: 18/11 (Ter√ßa) ‚Äî L√≥gica, Fun√ß√µes e Introdu√ß√£o ao Tidyverse 3.6 Dia 3: 24/11 (Segunda) ‚Äî Transforma√ß√£o, I/O e Visualiza√ß√£o 3.7 Dia 4: 25/11 (Ter√ßa) ‚Äî Integra√ß√£o do ChatGPT e Claude no RStudio", " 3 Cronograma Informa√ß√µes Gerais do Curso Carga hor√°ria total: 16 horas Datas: 17/11, 18/11, 24/11 e 25/11 Hor√°rio: 19h00 √†s 22h00 (com intervalo de 20 minutos √†s 20h30) Tempo l√≠quido por dia: 2h40 de conte√∫do efetivo P√∫blico-alvo: Iniciantes de diversas √°reas (ci√™ncias agr√°rias, sa√∫de, economia, biologia, ci√™ncias sociais) Material: Reposit√≥rio GitHub com datasets, scripts e exerc√≠cios Reposit√≥rio original: https://github.com/viniciusjunqueira/curso-r-github-ia Sistemas Operacionais: Windows, macOS e Linux (curso compat√≠vel com todos) Estrutura do curso (vis√£o geral): - Dia 1: Fundamentos de R + Ambiente reprodut√≠vel (RStudio, Git, GitHub, fork). - Dia 2: L√≥gica, condicionais, fun√ß√µes, tidyverse b√°sico. - Dia 3: Transforma√ß√µes com tidyr/dplyr, I/O e visualiza√ß√£o com ggplot2. - Dia 4: Integra√ß√£o pr√°tica do ChatGPT e do Claude dentro do RStudio. 3.1 Pr√©-requisitos T√©cnicos 3.1.1 Instala√ß√µes obrigat√≥rias (para todos os sistemas) R (vers√£o 4.3 ou superior) Download: https://cran.r-project.org/ RStudio Desktop (2023.09+) Download: https://posit.co/download/rstudio-desktop/ Git Windows: https://git-scm.com/download/win macOS: verifique com git --version (ou use o instalador) Linux (Ubuntu/Debian): sudo apt update sudo apt install git Conta no GitHub https://github.com/signup 3.2 Estrutura Pedag√≥gica e Filosofia Multiplataforma: conte√∫do compat√≠vel com Windows, macOS e Linux RStudio como IDE padr√£o Teoria seguida de pr√°tica guiada Commits di√°rios no fork do aluno IA como ferramenta para explica√ß√£o, depura√ß√£o e gera√ß√£o de material Portabilidade: here::here() e projetos .Rproj 3.3 Pacotes R Necess√°rios 3.3.1 Instala√ß√£o no Dia 1 a 3 (n√∫cleo do curso) install.packages(c( &quot;tidyverse&quot;, &quot;here&quot;, &quot;janitor&quot;, &quot;skimr&quot;, &quot;readxl&quot;, &quot;writexl&quot;, &quot;rmarkdown&quot;, &quot;knitr&quot;, &quot;lubridate&quot;, &quot;scales&quot;, &quot;patchwork&quot;, &quot;broom&quot;, &quot;palmerpenguins&quot; )) 3.3.2 Pacotes de IA (Dia 4) install.packages(c(&quot;gptstudio&quot;, &quot;chattr&quot;, &quot;httr2&quot;, &quot;jsonlite&quot;)) 3.4 Dia 1: 17/11 (Segunda) ‚Äî Fundamentos e Ambiente de Trabalho 3.4.1 19h00 - 20h30 | Ambienta√ß√£o e Setup Completo Apresenta√ß√£o do curso, objetivos e metodologia. Por que R, GitHub e IA. Checklist de instala√ß√µes (R, RStudio, Git). Configura√ß√£o do Git (user.name/user.email). Autentica√ß√£o no GitHub (PAT recomendado). Fazer fork do reposit√≥rio do curso. Clonar o fork no RStudio (Projeto .Rproj). Verificar git remote -v apontando para o fork do aluno. 3.4.2 20h30 - 20h50 | Intervalo 3.4.3 20h50 - 22h00 | Fundamentos do R Objetos e estruturas b√°sicas: vetores, listas, data.frames, fatores. Fun√ß√µes b√°sicas: c(), length(), class(), typeof(). Explora√ß√£o: str(), head(), tail(), names(), dplyr::glimpse(), summary(). Indexa√ß√£o: [], $, subsetting l√≥gico. Pr√°tica guiada: criar vetores e data.frames, manipular objetos. Commit sugerido: git add scripts/01_fundamentos.R git commit -m &quot;Fundamentos do R - Dia 1&quot; git push origin main 3.5 Dia 2: 18/11 (Ter√ßa) ‚Äî L√≥gica, Fun√ß√µes e Introdu√ß√£o ao Tidyverse 3.5.1 19h00 - 20h30 | Programa√ß√£o em R Operadores l√≥gicos e relacionais. Condicionais: if/else, ifelse() (vetorizado), dplyr::case_when(). Loops e fun√ß√µes: for vs.¬†vetoriza√ß√£o, cria√ß√£o de fun√ß√µes, valida√ß√£o de entradas. Boas pr√°ticas e debugging: snake_case, coment√°rios, leitura de traceback. Mini demonstra√ß√£o de como a IA pode explicar um erro simples. 3.5.2 20h30 - 20h50 | Intervalo 3.5.3 20h50 - 22h00 | Introdu√ß√£o ao Tidyverse Filosofia tidyverse e uso de pipes (%&gt;% e |&gt;). Verbos essenciais do dplyr: filter(), select(), mutate(), arrange(), summarize(), group_by(). Datas com lubridate: ymd/dmy/mdy, year/month/wday, today/now. Exemplo integrado com palmerpenguins. Commit sugerido: git commit -m &quot;L√≥gica, fun√ß√µes e tidyverse - Dia 2&quot; 3.6 Dia 3: 24/11 (Segunda) ‚Äî Transforma√ß√£o, I/O e Visualiza√ß√£o 3.6.1 19h00 - 20h30 | Transforma√ß√£o e I/O de Dados Reshape com tidyr: pivot_longer(), pivot_wider(), separate(), unite(). Tratamento de NAs: is.na(), drop_na(), replace_na(), fill(). Leitura/Escrita: readr::read_csv(), read_csv2(), readxl::read_excel(). Portabilidade com here::here() e organiza√ß√£o de projetos. Ferramentas √∫teis: janitor::clean_names(), skimr::skim(). 3.6.2 20h30 - 20h50 | Intervalo 3.6.3 20h50 - 22h00 | Visualiza√ß√£o com ggplot2 Gram√°tica de gr√°ficos: camadas, aesthetics, geoms comuns. Gr√°ficos: dispers√£o, barras, boxplot, linhas, histograma/densidade. Combina√ß√£o com patchwork, formatos com scales. Personaliza√ß√£o e salvamento: theme_*, labs(), ggsave(). Commit sugerido: git commit -m &quot;Transforma√ß√£o, I/O e visualiza√ß√£o - Dia 3&quot; 3.7 Dia 4: 25/11 (Ter√ßa) ‚Äî Integra√ß√£o do ChatGPT e Claude no RStudio Objetivo do dia: capacitar o aluno a usar ChatGPT (OpenAI) e Claude (Anthropic) diretamente no RStudio para explicar erros, revisar e gerar c√≥digo, criar rascunhos de relat√≥rios e automatizar pequenas rotinas via API. 3.7.1 19h00 - 19h30 | Conceitos e modelos Panorama r√°pido sobre LLMs, APIs, limites e custos. Boas pr√°ticas de uso respons√°vel de IA: privacidade, dados sens√≠veis, versionamento de c√≥digo gerado. Compara√ß√£o pr√°tica: quando usar ChatGPT e quando usar Claude. 3.7.2 19h30 - 20h15 | Configura√ß√£o de chaves e ambiente Vari√°veis de ambiente no R: uso de ~/.Renviron e Sys.getenv(). Cria√ß√£o de chaves de API e configura√ß√£o local. Nomes convencionados: - OPENAI_API_KEY para ChatGPT (OpenAI) - ANTHROPIC_API_KEY para Claude (Anthropic) 3.7.3 20h15 - 20h30 | Intervalo 3.7.4 20h30 - 21h00 | RStudio + gptstudio (ChatGPT) Abertura dos Addins do gptstudio no RStudio (chat pane e code assistant). Uso no editor: sele√ß√£o de c√≥digo e prompt de revis√£o. Exemplos t√≠picos: explicar erro, refatorar fun√ß√£o, gerar testes unit√°rios simples. 3.7.5 21h00 - 21h30 | RStudio + chattr (Claude) Fluxo b√°sico com chattr::chat_claude(). Exemplos pr√°ticos: explicar um traceback, sugerir valida√ß√£o de argumentos, gerar esqueleto de RMarkdown. 3.7.6 21h30 - 22h00 | Exerc√≠cio guiado de integra√ß√£o Tarefa 1: usar gptstudio para revisar um script curto de dplyr e propor 2 melhorias. Tarefa 2: usar chattr para gerar uma fun√ß√£o em R que: - receba um data.frame e uma coluna num√©rica - remova NAs, retorne m√©dia e desvio-padr√£o com nomes claros - inclua valida√ß√£o de tipos e mensagens de erro √∫teis Entrega esperada no fork do aluno: - scripts/04_ia_integracao_gptstudio.R - scripts/04_ia_integracao_claude.R - docs/relatorio_ia.Rmd com um par√°grafo descrevendo o que a IA sugeriu, o que foi adotado e por qu√™. Checklist final: - vari√°veis de ambiente lidas com Sys.getenv() - addins do gptstudio funcionando - chamada m√≠nima via httr2 para cada API - commit e push no fork "],["troubleshooting-por-sistema-operacional.html", "4 Troubleshooting por Sistema Operacional 4.1 Windows 4.2 macOS 4.3 Linux (Ubuntu/Debian) 4.4 Problemas comuns (todos os SO)", " 4 Troubleshooting por Sistema Operacional 4.1 Windows Git n√£o encontrado: reinstalar Git (op√ß√£o Git from the command line‚Ä¶). Acentos estranhos: garantir UTF-8 ao salvar, ou usar locale(encoding=‚Äúlatin1‚Äù) quando necess√°rio. Pacotes com erro: tentar instalar na biblioteca do usu√°rio. 4.2 macOS xcrun error com Git: xcode-select --install LaTeX n√£o encontrado: tinytex::install_tinytex() 4.3 Linux (Ubuntu/Debian) Compila√ß√£o de pacotes: sudo apt install build-essential libcurl4-openssl-dev libssl-dev libxml2-dev sudo apt install libfontconfig1-dev libharfbuzz-dev libfribidi-dev 4.4 Problemas comuns (todos os SO) Permission denied ao fazer push: corrigir origin para o fork do aluno: git remote set-url origin https://github.com/SEU-USUARIO/curso-r-github-ia.git API Key n√£o encontrada: configurar no ~/.Renviron e reiniciar o R. "],["recursos-adicionais.html", "5 Recursos Adicionais", " 5 Recursos Adicionais R for Data Science (2e): https://r4ds.hadley.nz/ Happy Git with R: https://happygitwithr.com/ Cheatsheets Posit: https://posit.co/resources/cheatsheets/ palmerpenguins: https://allisonhorst.github.io/palmerpenguins/ Datasets: TidyTuesday, Brasil.io, Kaggle "],["contato.html", "6 Contato", " 6 Contato Instrutor: Vin√≠cius Silva Junqueira Email: junqueiravinicius@hotmail.com GitHub: https://github.com/viniciusjunqueira/curso-r-github-ia Lattes: http://lattes.cnpq.br/4686677580216927 LinkedIn: www.linkedin.com/in/junqueiravinicius √öltima atualiza√ß√£o: 2025-11-26 Vers√£o: 6.0 ‚Äì Dia 4 100% integra√ß√£o com IA no RStudio "],["dia-1-fundamentos-e-ambiente-de-trabalho.html", "7 Dia 1: Fundamentos e Ambiente de Trabalho 7.1 Abertura 7.2 Apresenta√ß√£o do Curso (15 min) 7.3 Por Que R, GitHub e IA? (15 min) 7.4 Ambienta√ß√£o e Setup (40 min) 7.5 Estrutura de projeto e portabilidade 7.6 Fundamentos de R (50 min) 7.7 Explora√ß√£o inicial de dados (40 min) 7.8 Exerc√≠cios guiados (20 min) 7.9 Primeiro commit (5 min) 7.10 Checklist de encerramento 7.11 Refer√™ncias r√°pidas", " 7 Dia 1: Fundamentos e Ambiente de Trabalho 7.1 Abertura Tempo previsto 19h00‚Äì22h00 (intervalo 20h30‚Äì20h50) 7.2 Apresenta√ß√£o do Curso (15 min) 7.2.1 Bem-vindos! Ol√°! Seja muito bem-vindo ao Curso Intensivo de R com GitHub e IA. Esta jornada de 16 horas foi cuidadosamente estruturada para transformar voc√™ de iniciante a algu√©m capaz de realizar an√°lises de dados completas usando ferramentas modernas e profissionais. 7.2.2 Objetivos Gerais do Curso Ao final deste curso, voc√™ ser√° capaz de: Programar em R e descobrir como resolver problemas com o seu c√≥digo Manipular e transformar dados usando o ecossistema tidyverse Criar visualiza√ß√µes profissionais e informativas com ggplot2 Versionar seu c√≥digo com Git e colaborar via GitHub Usar intelig√™ncia artificial (ChatGPT e Claude) para acelerar seu aprendizado e resolver problemas 7.2.3 Metodologia Abordagem 100% pr√°tica e hands-on: Teoria m√≠nima necess√°ria seguida de pr√°tica imediata Datasets reais desde o primeiro dia Commits di√°rios no seu fork do reposit√≥rio IA como assistente para explica√ß√£o, depura√ß√£o e gera√ß√£o de c√≥digo Multiplataforma: todo conte√∫do funciona em Windows, macOS e Linux 7.2.4 Estrutura dos 4 Dias Dia 1 (hoje): Fundamentos de R + Ambiente reprodut√≠vel (RStudio, Git, GitHub, fork) Dia 2: L√≥gica de programa√ß√£o, condicionais, fun√ß√µes e tidyverse b√°sico Dia 3: Transforma√ß√µes com tidyr/dplyr, leitura/escrita de dados e visualiza√ß√£o com ggplot2 Dia 4: Integra√ß√£o pr√°tica do ChatGPT e Claude dentro do RStudio 7.2.5 Materiais e Suporte Reposit√≥rio GitHub: https://github.com/viniciusjunqueira/curso-r-github-ia Datasets: inclu√≠dos no reposit√≥rio + pacote palmerpenguins Contato: junqueiravinicius@hotmail.com 7.3 Por Que R, GitHub e IA? (15 min) 7.3.1 Por Que R? R √© uma linguagem poderosa e gratuita, criada especificamente para an√°lise de dados e estat√≠stica. Algumas raz√µes para aprender R: Ecosistema rico Mais de 20.000 pacotes dispon√≠veis para praticamente qualquer an√°lise tidyverse: conjunto integrado de ferramentas modernas para ci√™ncia de dados ggplot2: sistema de visualiza√ß√£o elegante e profissional Reprodutibilidade Tudo que voc√™ faz fica documentado em c√≥digo F√°cil repetir an√°lises com novos dados R Markdown permite combinar c√≥digo, resultados e narrativa Comunidade ativa Grande comunidade brasileira e internacional Milhares de tutoriais, cursos e f√≥runs de ajuda TidyTuesday: pr√°tica semanal com dados reais Demanda no mercado Usado em empresas, universidades e governos Essencial para ci√™ncia de dados, bioinform√°tica, economia, ci√™ncias sociais Combina bem com Python em pipelines modernos de dados 7.3.2 Por Que GitHub? GitHub n√£o √© apenas para programadores! √â uma plataforma essencial para: Controle de vers√£o Hist√≥rico completo de todas as mudan√ßas no seu c√≥digo Possibilidade de voltar a vers√µes anteriores Nunca mais perder trabalho por acidente Colabora√ß√£o Trabalhe em equipe sem conflitos Contribua para projetos open-source Receba feedback e sugest√µes Portf√≥lio profissional Mostre seus projetos para empregadores Demonstre evolu√ß√£o e consist√™ncia Compartilhe conhecimento com a comunidade Integra√ß√£o moderna Funciona perfeitamente com RStudio Base para deployment de aplica√ß√µes Padr√£o da ind√∫stria para ci√™ncia de dados 7.3.3 Por Que IA (ChatGPT e Claude)? A intelig√™ncia artificial revolucionou o aprendizado de programa√ß√£o. N√£o √© trapa√ßa, √© trabalhar de forma inteligente! Acelera o aprendizado Explica√ß√µes personalizadas para seu n√≠vel Respostas imediatas para d√∫vidas espec√≠ficas Exemplos sob medida para seu contexto Assist√™ncia na depura√ß√£o Interpreta√ß√£o de mensagens de erro Sugest√µes de corre√ß√£o Identifica√ß√£o de problemas de l√≥gica Aumenta produtividade Gera√ß√£o de c√≥digo boilerplate Refatora√ß√£o e otimiza√ß√£o Cria√ß√£o de documenta√ß√£o Ferramentas do curso ChatGPT (OpenAI): excelente para explica√ß√µes did√°ticas e gera√ß√£o r√°pida de c√≥digo Claude (Anthropic): √≥timo para an√°lises mais profundas e revis√£o de c√≥digo complexo Importante: IA √© uma ferramenta, n√£o uma substitui√ß√£o do aprendizado. Use-a para entender conceitos, n√£o apenas copiar c√≥digo! 7.4 Ambienta√ß√£o e Setup (40 min) Objetivos desta se√ß√£o Verificar instala√ß√µes (R, RStudio, Git) Configurar Git e autenticar no GitHub Entender e aplicar o workflow com fork Preparar ambiente reprodut√≠vel com projetos .Rproj e here() 7.4.1 Verifica√ß√µes r√°pidas R.version.string # Vers√£o do R RStudio.Version()$version # Vers√£o do RStudio system(&quot;git --version&quot;) # Confirma Git dispon√≠vel 7.4.2 Instalar Git (se n√£o estiver dispon√≠vel) Antes de come√ßar a trabalhar com controle de vers√£o no RStudio, voc√™ precisa ter o Git instalado no seu computador. Siga as instru√ß√µes espec√≠ficas para o seu sistema operacional. 7.4.3 Configurar Git (uma vez s√≥) No Terminal do RStudio (funciona em Windows/macOS/Linux): git config --global user.name &quot;Seu Nome&quot; git config --global user.email &quot;seu@email.com&quot; # Verificar git config --global --list 7.4.4 Autenticar no GitHub (PAT recomendado) O que √© um PAT? Um Personal Access Token (PAT) √© como uma ‚Äúsenha especial‚Äù que permite ao RStudio se comunicar com o GitHub de forma segura. O GitHub n√£o aceita mais senhas normais para opera√ß√µes via linha de comando, ent√£o o PAT √© obrigat√≥rio. Passo a passo para criar e configurar o PAT: 7.4.5 Instalar pacotes necess√°rios install.packages(&quot;usethis&quot;) install.packages(&quot;gitcreds&quot;) 7.4.6 Criar o token no GitHub usethis::create_github_token() Este comando abrir√° seu navegador automaticamente na p√°gina de cria√ß√£o de tokens do GitHub. Voc√™ ver√° uma p√°gina pr√©-configurada com as permiss√µes necess√°rias. No navegador: Fa√ßa login no GitHub (se ainda n√£o estiver logado) Note (New personal access token - classic): O campo ‚ÄúNote‚Äù j√° vir√° preenchido com algo como ‚ÄúDESCRIBE THE TOKEN‚ÄôS USE CASE‚Äù Renomeie para algo descritivo como: RStudio-Curso-R-2024 Expiration: escolha a dura√ß√£o do token Para o curso: 90 days √© suficiente Para uso cont√≠nuo: No expiration (menos seguro, mas mais pr√°tico) Permiss√µes (Scopes): o usethis j√° marca as principais ‚úÖ repo (controle total de reposit√≥rios privados) ‚úÖ workflow (atualizar workflows do GitHub Actions) ‚úÖ gist (criar gists) ‚úÖ user (atualizar dados do usu√°rio) N√£o altere nada, as permiss√µes pr√©-selecionadas s√£o ideais Clique em ‚ÄúGenerate token‚Äù no final da p√°gina ATEN√á√ÉO: copie o token que aparece (come√ßa com ghp_...) ‚ö†Ô∏è VOC√ä S√ì VER√Å ESTE TOKEN UMA VEZ! Cole em um lugar seguro temporariamente (bloco de notas) 7.4.7 Salvar o token no RStudio gitcreds::gitcreds_set() Quando executar este comando, voc√™ ver√° algo assim no Console: ? Enter password or token: Cole o token que voc√™ copiou do GitHub e pressione Enter. Voc√™ ver√° uma mensagem de confirma√ß√£o: -&gt; Adding new credentials... -&gt; Removing credentials from cache... -&gt; Done. 7.4.8 Verificar se funcionou usethis::git_sitrep() Este comando mostra o status da sua configura√ß√£o Git/GitHub. Procure por: ‚úî GitHub user: &#39;seu-usuario&#39; ‚úî Token: &#39;&lt;discovered&gt;&#39; Se voc√™ ver isso, est√° tudo configurado! ‚úÖ Alternativas ao PAT: GitHub Desktop (aplicativo com interface gr√°fica - mais simples para iniciantes) SSH (m√©todo avan√ßado, requer configura√ß√£o de chaves p√∫blicas/privadas) 7.4.9 Workflow com Fork (obrigat√≥rio para a turma) Original (instrutor) ‚Üí FORK (sua conta) ‚Üí CLONE (seu PC) ‚Üí PUSH (para seu fork) Abra: https://github.com/viniciusjunqueira/curso-r-github-ia Clique Fork ‚Üí escolha sua conta ‚Üí Create fork. Clone SEU fork: git clone https://github.com/SEU-USUARIO/curso-r-github-ia.git cd curso-r-github-ia Abra o projeto .Rproj no RStudio. Cheque o remote: git remote -v # Deve mostrar seu usu√°rio em origin Por que fork? Voc√™ controla seu reposit√≥rio, faz commits/push √† vontade e n√£o altera o repo do instrutor. 7.5 Estrutura de projeto e portabilidade curso-r-github-ia/ ‚îú‚îÄ‚îÄ curso-r-github-ia.Rproj ‚îú‚îÄ‚îÄ data/ ‚îÇ ‚îú‚îÄ‚îÄ raw/ ‚îÇ ‚îî‚îÄ‚îÄ processed/ ‚îú‚îÄ‚îÄ scripts/ ‚îú‚îÄ‚îÄ output/ ‚îÇ ‚îú‚îÄ‚îÄ figures/ ‚îÇ ‚îî‚îÄ‚îÄ tables/ ‚îî‚îÄ‚îÄ docs/ # Caminhos: sempre prefira here::here() if (!requireNamespace(&quot;here&quot;, quietly = TRUE)) { install.packages(&quot;here&quot;) } library(here) caminho &lt;- here(&quot;data&quot;, &quot;raw&quot;, &quot;dados.csv&quot;) caminho UTF-8: salve arquivos com File ‚Üí Save with Encoding ‚Üí UTF-8 (evita problemas de acentua√ß√£o em todos os SOs). 7.6 Fundamentos de R (50 min) 7.6.1 Objetos b√°sicos e opera√ß√µes O que s√£o objetos em R? Em R, tudo √© um objeto! Quando voc√™ cria uma vari√°vel, voc√™ est√° criando um objeto que armazena informa√ß√£o na mem√≥ria do computador. Os tipos b√°sicos mais importantes s√£o: Num√©rico (numeric): n√∫meros decimais como 3.14, 10.5, -2.7 Inteiro (integer): n√∫meros inteiros como 1L, 100L (o L indica inteiro) L√≥gico (logical): valores verdadeiro/falso - TRUE ou FALSE Caractere (character): texto entre aspas como \"Ol√°\", \"R\", \"2024\" Voc√™ cria objetos usando o operador de atribui√ß√£o &lt;- (preferido) ou =. # N√∫meros, l√≥gicos, strings x_num &lt;- 3.14 x_log &lt;- TRUE x_chr &lt;- &quot;Ol√°, R!&quot; class(x_num) typeof(x_num) class(x_log) typeof(x_log) class(x_chr) typeof(x_chr) # Aritm√©tica 10 + 2 # somat√≥rio 10 - 2 # subtra√ß√£o 10 * 2 # multiplica√ß√£o 10 / 3 # divis√£o 2 ^ 3 # exponecial # Infinito positivo. Significa que o valor tende ao infinito positivo. a &lt;- 1 / 0 a # Infinito negativo. Significa que o valor tende ao infinito negativo. b &lt;- -1 / 0 b # Not a Number (NaN). Indica uma opera√ß√£o indefinida matematicamente. c &lt;- 0 / 0 c # Valor ausente (NA). Representa um valor desconhecido ou faltante. d &lt;- c(2, 4, NA, 8) d # ------------------------------------------------------------- # Testando os tipos de valores # ------------------------------------------------------------- is.infinite(a) # TRUE is.nan(c) # TRUE is.na(d) # TRUE para o elemento ausente is.na(NaN) # TRUE ‚Äî NaN √© considerado um tipo especial de NA is.finite(a) # FALSE ‚Äî porque Inf n√£o √© finito is.finite(10) # TRUE ‚Äî n√∫mero normal √© finito # ------------------------------------------------------------- # Opera√ß√µes que produzem resultados especiais # ------------------------------------------------------------- Inf + (-Inf) # NaN (infinito positivo menos infinito negativo √© indefinido) Inf / Inf # NaN 0 * Inf # NaN NA + 1 # NA 7.6.2 Vetores e indexa√ß√£o O que s√£o vetores? Vetores s√£o a estrutura de dados mais fundamental do R. Um vetor √© uma cole√ß√£o de elementos do mesmo tipo (todos n√∫meros, ou todos textos, ou todos l√≥gicos). Voc√™ pode pensar em um vetor como uma linha de dados em uma planilha. Caracter√≠sticas importantes: - Criados com a fun√ß√£o c() (de ‚Äúcombine‚Äù ou ‚Äúconcatenar‚Äù) - Todos os elementos devem ser do mesmo tipo - R √© 1-indexed (o primeiro elemento est√° na posi√ß√£o 1, n√£o 0) - Opera√ß√µes s√£o vetorizadas (aplicadas a todos elementos automaticamente) Indexa√ß√£o √© o processo de acessar elementos espec√≠ficos de um vetor usando colchetes []. v &lt;- c(10, 20, 30, 40, 50) length(v); mean(v); sum(v) v[1]; v[2:4]; v[-1] sel &lt;- v &gt; 25; sel; v[sel] Utilizando a fun√ß√£o names(): Essa fun√ß√£o serve para dar nomes (ou cabe√ßalhos) aos elementos de um vetor, lista ou outro objeto em R. Esses nomes tornam os dados mais organizados e permitem acessar valores pelo nome, em vez de usar apenas posi√ß√µes num√©ricas. √â √∫til quando voc√™ quer que cada elemento tenha um r√≥tulo identificador, como nomes de amostras, vari√°veis, tratamentos ou categorias ‚Äî o que deixa o c√≥digo mais leg√≠vel e f√°cil de interpretar. names(v) &lt;- letters[1:5] # Mostrando o vetor com nomes v # Acessando um elemento pelo nome v[&quot;c&quot;] Type coercion. Em R, um vetor √© uma estrutura homog√™nea, ou seja, todos os seus elementos precisam ser do mesmo tipo. Quando voc√™ cria um vetor com elementos de tipos diferentes, o R automaticamente converte (ou ‚Äúcoage‚Äù) todos os valores para um tipo comum que consiga representar todos eles. Esse processo √© chamado de coer√ß√£o de tipos (type coercion). Regras b√°sicas de coer√ß√£o: O R segue uma hierarquia de tipos, do mais simples para o mais geral: logical ‚Üí integer ‚Üí double ‚Üí character Isso significa: Se voc√™ misturar l√≥gicos (TRUE, FALSE) com n√∫meros, eles viram n√∫meros (TRUE = 1, FALSE = 0). Se misturar n√∫meros com texto, tudo vira texto. O tipo character tem sempre prioridade, porque √© o √∫nico que pode representar qualquer coisa como texto. x &lt;- c(1, &quot;a&quot;) x class(x) 7.6.3 Listas e data.frames 7.6.3.1 Listas: estruturas flex√≠veis Uma lista (list) √© uma estrutura que pode conter elementos de diferentes tipos ‚Äî ao contr√°rio dos vetores, que s√£o homog√™neos. Listas s√£o extremamente vers√°teis e podem armazenar n√∫meros, textos, vetores, outras listas e at√© data.frames! 7.6.3.2 Uso t√≠pico de listas: Armazenar resultados complexos de an√°lises Combinar diferentes tipos de informa√ß√£o Retornar m√∫ltiplos valores de uma fun√ß√£o 7.6.3.3 Exemplo 1 ‚Äì Criando uma lista simples # Criando uma lista com diferentes tipos de objetos info &lt;- list( nome = &quot;Ana&quot;, idade = 25, notas = c(8.5, 9.0, 7.5), aprovado = TRUE ) # Visualizando a lista completa info A fun√ß√£o str() (de structure) exibe um resumo compacto da estrutura de qualquer objeto em R. √â muito √∫til para entender rapidamente o conte√∫do de listas e data.frames, mostrando: O tipo de cada elemento (num√©rico, l√≥gico, texto, etc.) O tamanho dos vetores internos Uma pr√©via dos valores armazenados str(info) Data.frames: a estrutura tabular Um data.frame (data.frame) √© a estrutura mais importante para an√°lise de dados em R. √â similar a uma planilha do Excel ou uma tabela de banco de dados: tem linhas (observa√ß√µes) e colunas (vari√°veis). Caracter√≠sticas do data.frame: Cada coluna pode ser de um tipo diferente (uma coluna num√©rica, outra texto) Cada coluna √© um vetor e deve ter o mesmo comprimento √â como uma lista especial onde todos os elementos t√™m o mesmo tamanho Ideal para dados tabulares (como datasets de pesquisa) # Lista: tipos mistos lst &lt;- list(id = 1, nome = &quot;Ana&quot;, aprovado = TRUE) lst$nome # Data frame alunos &lt;- data.frame( id = 1:4, nome = c(&quot;Ana&quot;, &quot;Bruno&quot;, &quot;Caio&quot;, &quot;Dani&quot;), nota = c(8.5, 7.2, 9.1, 6.8), ativo = c(TRUE, TRUE, FALSE, TRUE), stringsAsFactors = FALSE ) str(alunos) nrow(alunos) ncol(alunos) names(alunos) head(alunos, 2) tail(alunos, 2) # Acesso e novas colunas alunos$nome alunos$aprov &lt;- ifelse(alunos$nota &gt;= 7, &quot;Aprovado&quot;, &quot;Recupera√ß√£o&quot;) 7.6.3.4 Diferen√ßa entre lista e data.frame Aspecto Lista Data.frame Estrutura Cole√ß√£o gen√©rica de objetos Lista especial com vetores de mesmo comprimento Tipos de elementos Pode misturar tipos livremente Cada coluna pode ter tipo diferente, mas mesmo tamanho Acesso Por nome, √≠ndice ou $ Por nome de coluna ou √≠ndice de coluna Tamanho dos elementos Pode variar Todos t√™m o mesmo n√∫mero de linhas Uso t√≠pico Armazenar resultados complexos Manipular dados tabulares 7.6.3.5 Convers√£o entre listas e data.frames # Converter data.frame em lista as.list(alunos) # Converter lista em data.frame nova_lista &lt;- list( id = 1:3, nome = c(&quot;Eva&quot;, &quot;F√°bio&quot;, &quot;Gabi&quot;), nota = c(9.0, 8.7, 7.5) ) as.data.frame(nova_lista) Resumo: Todo data.frame √© uma lista, mas nem toda lista √© um data.frame. Um data.frame √© basicamente uma lista disciplinada, ideal para armazenar dados organizados em linhas e colunas. 7.6.4 Fatores O que s√£o fatores? Fatores (factor) s√£o a forma do R representar vari√°veis categ√≥ricas (tamb√©m chamadas de qualitativas). S√£o usados para dados que podem assumir um n√∫mero limitado de valores distintos, chamados de ‚Äún√≠veis‚Äù (levels). Quando usar fatores: Vari√°veis categ√≥ricas: sexo (M/F), regi√£o (Norte/Sul/Leste/Oeste), tratamento (Controle/Teste) Vari√°veis ordinais: n√≠vel de escolaridade, grau de satisfa√ß√£o (Baixo/M√©dio/Alto) Respostas de question√°rios com op√ß√µes fixas Vantagens dos fatores: Economizam mem√≥ria (armazenam c√≥digos internos, n√£o strings repetidas) Permitem ordena√ß√£o l√≥gica (ex: Baixo &lt; M√©dio &lt; Alto) Facilitam an√°lises estat√≠sticas e gr√°ficos Controlam quais valores s√£o v√°lidos Tipos de fatores: Nominais (sem ordem): cores, categorias Ordinais (com ordem): n√≠veis de satisfa√ß√£o, graus acad√™micos sexo &lt;- factor(c(&quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;), levels = c(&quot;F&quot;, &quot;M&quot;)) levels(sexo) conceito &lt;- factor(c(&quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;A&quot;), levels = c(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;), ordered = TRUE) summary(conceito) 7.7 Explora√ß√£o inicial de dados (40 min) Vamos usar um dataset real (palmerpenguins) para praticar inspe√ß√£o e resumo com diferentes fun√ß√µes, incluindo dplyr::glimpse(). if (!requireNamespace(&quot;palmerpenguins&quot;, quietly = TRUE)) { install.packages(&quot;palmerpenguins&quot;) } library(palmerpenguins) library(dplyr) # Informa√ß√µes b√°sicas names(penguins) # nomes das colunas nrow(penguins) # n√∫mero de linhas ncol(penguins) # n√∫mero de colunas dim(penguins) # dimens√µes (linhas x colunas) class(penguins) Tibble vs data.frame O objeto penguins do pacote palmerpenguins n√£o √© um data.frame tradicional: ele √© uma tibble. Uma tibble √© uma vers√£o mais moderna e segura de um data.frame, usada no tidyverse. Principais diferen√ßas: Impress√£o: data.frame imprime tudo (todas as linhas e todas as colunas, √†s vezes vira uma parede de texto). tibble imprime s√≥ as primeiras linhas e corta na largura da tela, mostrando tamb√©m o tipo de cada coluna. Tipos na impress√£o: tibbles sempre mostram o tipo de dado de cada coluna (&lt;dbl&gt;, &lt;int&gt;, &lt;chr&gt;, &lt;fct&gt;, etc.). data.frames n√£o mostram isso. Subsetting: Em um data.frame, df[, \"coluna\"] pode virar vetor. Em uma tibble, tb[ , \"coluna\"] ainda √© tibble (mais previs√≠vel). Para vetor puro, usa-se tb[[\"coluna\"]] ou tb$coluna. Nomes estranhos: tibbles aceitam nomes de colunas n√£o sint√°ticos (por exemplo \"2024 (%)\"), e voc√™ acessa com crase: tb$2024 (%)``. data.frames costumam tentar corrigir/alterar o nome automaticamente. Nunca converte string automaticamente para factor. data.frame(...) antigamente convertia texto em fator (dependia de stringsAsFactors). tibbles N√ÉO fazem convers√£o autom√°tica de texto para fator. Texto fica texto. # Vis√£o geral do dataset str(penguins) # estrutura detalhada dplyr::glimpse(penguins) # vis√£o compacta e moderna (tidyverse style) # Primeiras e √∫ltimas observa√ß√µes head(penguins) # 6 primeiras linhas tail(penguins, 3) # 3 √∫ltimas linhas # Resumo estat√≠stico summary(penguins) # resumo de cada coluna colSums(is.na(penguins)) # contagem de NAs por coluna # Selecionar colunas principais (R base) peng_min &lt;- penguins[, c(&quot;species&quot;,&quot;bill_length_mm&quot;,&quot;bill_depth_mm&quot;, &quot;flipper_length_mm&quot;,&quot;body_mass_g&quot;)] head(peng_min) # Criar nova vari√°vel: raz√£o do bico penguins$raz_bico &lt;- with(penguins, bill_length_mm / bill_depth_mm) head(penguins$raz_bico) # Estat√≠sticas descritivas mean(penguins$flipper_length_mm, na.rm = TRUE) sd(penguins$body_mass_g, na.rm = TRUE) range(penguins$bill_length_mm, na.rm = TRUE) # Estat√≠sticas por grupo tapply(penguins$flipper_length_mm, penguins$species, mean, na.rm = TRUE) tapply(penguins$body_mass_g, penguins$species, median, na.rm = TRUE) # Tabelas de frequ√™ncia table(penguins$species) # table(penguins$species, penguins$island) 7.7.1 Comparando str() vs glimpse() Ambas mostram a estrutura dos dados, mas com estilos diferentes: # str(): estilo tradicional do R, mais verboso str(penguins) # glimpse(): estilo tidyverse, mais compacto e leg√≠vel dplyr::glimpse(penguins) Vantagens do glimpse(): Mostra tipo de cada coluna de forma clara Apresenta primeiros valores de forma compacta Melhor para datasets com muitas colunas Estilo moderno e consistente com tidyverse Dica: quando houver NAs, sempre use na.rm = TRUE nas fun√ß√µes de resumo estat√≠stico. 7.8 Exerc√≠cios guiados (20 min) 7.8.1 Exerc√≠cio 1 ‚Äî Vetores Crie um vetor num√©rico com 8 valores quaisquer. Calcule m√©dia, mediana e desvio-padr√£o. Filtre apenas os valores acima da m√©dia. # Seu c√≥digo aqui 7.8.2 Exerc√≠cio 2 ‚Äî Data frame Crie um data.frame com colunas: id, nome, nota, ativo. Crie uma nova coluna situacao usando ifelse(nota &gt;= 7, \"Aprovado\", \"Recupera√ß√£o\"). Mostre apenas as colunas nome e situacao das 2 primeiras linhas. # Seu c√≥digo aqui 7.8.3 Exerc√≠cio 3 ‚Äî Explora√ß√£o palmerpenguins Use glimpse() para ter uma vis√£o geral dos dados. Conte quantos NAs existem em cada coluna. Crie uma nova coluna massa_kg convertendo body_mass_g para quilogramas. Calcule a m√©dia de flipper_length_mm por esp√©cie usando tapply(). # Seu c√≥digo aqui 7.9 Primeiro commit (5 min) No Terminal do RStudio: git add scripts/01_fundamentos.R git commit -m &quot;Dia 1: fundamentos de R e setup&quot; git push origin main Confirme no seu reposit√≥rio forkado no GitHub se o commit apareceu. 7.10 Checklist de encerramento R, RStudio e Git instalados e funcionando. Git configurado com user.name e user.email. Fork criado no GitHub e clone realizado do SEU fork. Projeto .Rproj aberto; fun√ß√£o here() testada. Entendeu a diferen√ßa entre str() e glimpse(). Script 01_fundamentos.R criado e salvo em UTF-8. Commit e push realizados com sucesso para SEU fork. 7.11 Refer√™ncias r√°pidas R for Data Science (2e): https://r4ds.hadley.nz/ Happy Git with R: https://happygitwithr.com/ Cheatsheets Posit: https://posit.co/resources/cheatsheets/ palmerpenguins: https://allisonhorst.github.io/palmerpenguins/ dplyr documentation: https://dplyr.tidyverse.org/ Nos vemos no Dia 2 para explorarmos l√≥gica de programa√ß√£o e tidyverse! üöÄ "],["dia-2-l√≥gica-fun√ß√µes-e-introdu√ß√£o-ao-tidyverse.html", "8 Dia 2: L√≥gica, Fun√ß√µes e Introdu√ß√£o ao Tidyverse 8.1 Operadores e Condicionais (30 min) 8.2 Loops, Vetoriza√ß√£o e Fun√ß√µes (25 min) 8.3 Introdu√ß√£o ao Tidyverse (45 min) 8.4 Pipe: %&gt;% vs.¬†|&gt; 8.5 Datas com lubridate (10 min) 8.6 Exerc√≠cios Pr√°ticos (20‚Äì25 min) 8.7 Boas Pr√°ticas e Debugging (20 min) 8.8 Ferramentas √∫teis 8.9 Commit do Dia 8.10 Checklist de encerramento 8.11 Refer√™ncias r√°pidas", " 8 Dia 2: L√≥gica, Fun√ß√µes e Introdu√ß√£o ao Tidyverse Objetivos do dia Dominar operadores l√≥gicos/relacionais e condicionais (if, ifelse, case_when). Entender loops vs.¬†vetoriza√ß√£o e criar fun√ß√µes pr√≥prias. Aplicar um pipeline b√°sico com dplyr e introduzir datas com lubridate. Registrar o aprendizado com um commit no seu fork no GitHub. Tempo previsto 19h00‚Äì22h00 (intervalo 20h30‚Äì20h50) 8.1 Operadores e Condicionais (30 min) 8.1.1 O que s√£o operadores? Operadores s√£o s√≠mbolos especiais que realizam opera√ß√µes entre valores. Eles s√£o fundamentais para tomar decis√µes no c√≥digo e controlar o fluxo de execu√ß√£o. 8.1.2 Operadores l√≥gicos e relacionais Operadores relacionais comparam dois valores e retornam TRUE ou FALSE: == : igual a != : diferente de &gt; : maior que &lt; : menor que &gt;= : maior ou igual &lt;= : menor ou igual Operadores l√≥gicos combinam condi√ß√µes: &amp; : E (AND) - ambas condi√ß√µes devem ser verdadeiras | : OU (OR) - pelo menos uma condi√ß√£o deve ser verdadeira ! : N√ÉO (NOT) - inverte o valor l√≥gico xor() : OU EXCLUSIVO - apenas uma condi√ß√£o pode ser verdadeira # ============================================ # OPERADORES RELACIONAIS EM MELHORAMENTO # ============================================ # Avalia√ß√£o de um reprodutor dep_leite &lt;- 850 # DEP (Diferen√ßa Esperada na Prog√™nie) para leite em kg acuracia &lt;- 0.85 # Acur√°cia da avalia√ß√£o gen√©tica idade_meses &lt;- 36 # Verifica√ß√µes b√°sicas dep_leite &gt; 500 # TRUE - DEP positiva e alta? acuracia &gt;= 0.70 # TRUE - avalia√ß√£o confi√°vel? idade_meses &lt;= 48 # TRUE - ainda jovem? dep_leite == 850 # TRUE - exatamente 850 kg? acuracia != 1.0 # TRUE - n√£o tem acur√°cia perfeita # Avaliando m√∫ltiplos animais deps_peso &lt;- c(15, 22, 8, 30, 18) # DEPs para peso ao desmame (kg) deps_peso &gt;= 20 # FALSE FALSE FALSE TRUE FALSE sum(deps_peso &gt;= 20) # 2 animais atingem o crit√©rio # ============================================ # OPERADORES L√ìGICOS - SELE√á√ÉO DE ANIMAIS # ============================================ # Crit√©rios para touro elite dep_leite &lt;- 950 dep_gordura &lt;- 35 dep_proteina &lt;- 28 confiabilidade &lt;- 0.88 consanguinidade &lt;- 0.03 # Touro elite: DEP leite &gt; 800 E gordura &gt; 30 E prote√≠na &gt; 25 touro_elite &lt;- dep_leite &gt; 800 &amp; dep_gordura &gt; 30 &amp; dep_proteina &gt; 25 print(touro_elite) # TRUE # Touro elite CONFI√ÅVEL: crit√©rios acima E confiabilidade alta E baixa consanguinidade touro_elite_confiavel &lt;- touro_elite &amp; confiabilidade &gt;= 0.80 &amp; consanguinidade &lt; 0.05 print(touro_elite_confiavel) # TRUE # Crit√©rios para descarte de f√™mea idade_anos &lt;- 8 producao_ultima_lactacao &lt;- 4500 # kg de leite intervalo_partos &lt;- 450 # dias problemas_reprodutivos &lt;- TRUE # Descartar se: idade &gt; 7 OU produ√ß√£o &lt; 5000 OU problemas reprodutivos descartar &lt;- idade_anos &gt; 7 | producao_ultima_lactacao &lt; 5000 | problemas_reprodutivos print(descartar) # TRUE (atende m√∫ltiplos crit√©rios) # Sele√ß√£o para insemina√ß√£o artificial fertilidade_campo &lt;- 0.65 libido &lt;- &quot;alta&quot; saude_androl√≥gica &lt;- TRUE dep_habilidade_materna &lt;- 5 # Apto para IA se: fertilidade &gt; 0.60 E libido adequada E sa√∫de OK apto_ia &lt;- fertilidade_campo &gt; 0.60 &amp; (libido == &quot;alta&quot; | libido == &quot;m√©dia&quot;) &amp; saude_androl√≥gica print(apto_ia) # TRUE # XOR - Apenas uma caracter√≠stica excepcional dep_crescimento_excepcional &lt;- TRUE # DEP &gt; 30 kg dep_qualidade_carcaca_excepcional &lt;- FALSE # DEP carne &lt; 2 # Animal especializado (apenas uma caracter√≠stica excepcional) especializado &lt;- xor(dep_crescimento_excepcional, dep_qualidade_carcaca_excepcional) print(especializado) # TRUE - √© especializado em crescimento # Nega√ß√£o (NOT) tem_defeito_genetico &lt;- FALSE !tem_defeito_genetico # TRUE - n√£o tem defeito, pode reproduzir # ============================================ # EXEMPLO PR√ÅTICO: DATABASE DE REBANHO # ============================================ # Plantel de vacas leiteiras rebanho &lt;- data.frame( animal_id = c(&quot;V001&quot;, &quot;V002&quot;, &quot;V003&quot;, &quot;V004&quot;, &quot;V005&quot;), dep_leite = c(850, 650, 920, 550, 780), dep_gordura = c(32, 28, 38, 25, 30), acuracia = c(0.85, 0.75, 0.90, 0.60, 0.80), idade_anos = c(4, 6, 3, 8, 5), consanguinidade = c(0.02, 0.06, 0.01, 0.08, 0.03), n_partos = c(2, 4, 1, 6, 3) ) print(rebanho) # 1. VACAS SUPERIORES para m√£es de touros # Crit√©rios: DEP leite &gt; 800, DEP gordura &gt; 30, acur√°cia &gt; 0.80 maes_touros &lt;- rebanho$dep_leite &gt; 800 &amp; rebanho$dep_gordura &gt; 30 &amp; rebanho$acuracia &gt; 0.80 print(&quot;Candidatas a m√£es de touros:&quot;) print(rebanho[maes_touros, ]) # 2. VACAS EM RISCO de descarte # Crit√©rios: idade &gt; 7 OU consanguinidade &gt; 0.07 OU DEP leite &lt; 600 risco_descarte &lt;- rebanho$idade_anos &gt; 7 | rebanho$consanguinidade &gt; 0.07 | rebanho$dep_leite &lt; 600 print(&quot;\\nAnimais em risco de descarte:&quot;) print(rebanho[risco_descarte, ]) # 3. VACAS JOVENS COM ALTO POTENCIAL # Crit√©rios: idade &lt;= 4 E DEP leite &gt; 750 E acur√°cia &gt; 0.75 jovens_potencial &lt;- rebanho$idade_anos &lt;= 4 &amp; rebanho$dep_leite &gt; 750 &amp; rebanho$acuracia &gt; 0.75 print(&quot;\\nVacas jovens de alto potencial:&quot;) print(rebanho[jovens_potencial, ]) # 4. CONTROLE DE CONSANGUINIDADE # Animais N√ÉO consangu√≠neos (para acasalamentos) nao_consanguineos &lt;- rebanho$consanguinidade &lt; 0.05 print(&quot;\\nAnimais n√£o consangu√≠neos:&quot;) print(rebanho[nao_consanguineos, c(&quot;animal_id&quot;, &quot;consanguinidade&quot;)]) # ============================================ # EXEMPLO: DECIS√ïES DE ACASALAMENTO # ============================================ # Caracter√≠sticas do touro touro_dep_leite &lt;- 900 touro_dep_gordura &lt;- 35 touro_consanguinidade &lt;- 0.02 # Caracter√≠sticas da vaca vaca_dep_leite &lt;- 700 vaca_dep_gordura &lt;- 28 vaca_consanguinidade &lt;- 0.03 # Compatibilidade gen√©tica # Ambos devem ter DEPs positivas E consanguinidade combinada &lt; 0.06 deps_complementares &lt;- touro_dep_leite &gt; 600 &amp; vaca_dep_leite &gt; 600 &amp; touro_dep_gordura &gt; 25 &amp; vaca_dep_gordura &gt; 25 consanguinidade_aceitavel &lt;- (touro_consanguinidade + vaca_consanguinidade) &lt; 0.06 acasalamento_recomendado &lt;- deps_complementares &amp; consanguinidade_aceitavel print(paste(&quot;Acasalamento recomendado?&quot;, acasalamento_recomendado)) # TRUE # ============================================ # √çNDICE DE SELE√á√ÉO COMPOSTO # ============================================ # C√°lculo de √≠ndice para gado de corte dep_peso_desmame &lt;- 25 # kg dep_ganho_pos_desmame &lt;- 18 # kg dep_aol &lt;- 2.5 # √°rea de olho de lombo (cm¬≤) dep_eg &lt;- -1.2 # espessura de gordura (mm) - negativo √© bom! # Pesos econ√¥micos (exemplo) peso_pd &lt;- 2.0 peso_gpd &lt;- 1.5 peso_aol &lt;- 3.0 peso_eg &lt;- -1.0 # C√°lculo do √≠ndice indice &lt;- (dep_peso_desmame * peso_pd) + (dep_ganho_pos_desmame * peso_gpd) + (dep_aol * peso_aol) + (dep_eg * peso_eg) print(paste(&quot;√çndice de sele√ß√£o:&quot;, round(indice, 2))) # Animal √© TOP 10% se √≠ndice &gt; 80 top_10_pct &lt;- indice &gt; 80 print(paste(&quot;Animal top 10%?&quot;, top_10_pct)) # ============================================ # EXERC√çCIO PR√ÅTICO # ============================================ # Voc√™ tem 5 touros para classificar: touros &lt;- data.frame( id = c(&quot;T001&quot;, &quot;T002&quot;, &quot;T003&quot;, &quot;T004&quot;, &quot;T005&quot;), dep_leite = c(920, 780, 650, 850, 1050), dep_proteina = c(30, 25, 22, 28, 35), acuracia = c(0.88, 0.72, 0.65, 0.85, 0.92), filhas_avaliadas = c(85, 45, 30, 70, 120), consanguinidade = c(0.02, 0.05, 0.08, 0.03, 0.01) ) # DESAFIO 1: Selecione touros ELITE # Crit√©rios: DEP leite &gt; 900, prote√≠na &gt; 28, acur√°cia &gt; 0.85, consanguinidade &lt; 0.04 touros_elite &lt;- touros$dep_leite &gt; 900 &amp; touros$dep_proteina &gt; 28 &amp; touros$acuracia &gt; 0.85 &amp; touros$consanguinidade &lt; 0.04 print(&quot;TOUROS ELITE:&quot;) print(touros[touros_elite, ]) # DESAFIO 2: Touros com avalia√ß√£o CONFI√ÅVEL # Crit√©rios: acur√°cia &gt; 0.80 OU filhas avaliadas &gt;= 80 touros_confiaveis &lt;- touros$acuracia &gt; 0.80 | touros$filhas_avaliadas &gt;= 80 print(&quot;\\nTOUROS COM AVALIA√á√ÉO CONFI√ÅVEL:&quot;) print(touros[touros_confiaveis, ]) # DESAFIO 3: Touros para DESCARTE # Crit√©rios: consanguinidade &gt; 0.06 OU (DEP leite &lt; 700 E acur√°cia &lt; 0.70) touros_descarte &lt;- touros$consanguinidade &gt; 0.06 | (touros$dep_leite &lt; 700 &amp; touros$acuracia &lt; 0.70) print(&quot;\\nTOUROS PARA DESCARTE:&quot;) print(touros[touros_descarte, ]) Operador especial: - %in% : verifica se um valor est√° presente em um vetor # L√≥gicos: &amp; | ! xor() TRUE &amp; FALSE # FALSE (ambos precisam ser TRUE) TRUE | FALSE # TRUE (pelo menos um √© TRUE) !TRUE # FALSE (inverte) xor(TRUE, FALSE) # TRUE (apenas um √© TRUE) # Relacionais: == != &gt; &lt; &gt;= &lt;= 3 == 3 # TRUE (igual) 5 != 2 # TRUE (diferente) 5 &gt; 2; 1 &lt; 0 # TRUE; FALSE 2 &gt;= 2; 3 &lt;= 10 # TRUE; TRUE # %in% (avalia se est√° contido) 2 %in% c(1, 2, 3) # TRUE &quot;Adelie&quot; %in% c(&quot;Chinstrap&quot;, &quot;Gentoo&quot;) # FALSE 8.1.3 Condicionais: tomando decis√µes no c√≥digo Condicionais permitem que seu c√≥digo tome decis√µes baseadas em condi√ß√µes. S√£o como perguntas ‚Äúse‚Ä¶ ent√£o‚Ä¶ sen√£o‚Ä¶‚Äù. Tr√™s formas principais: if/else - Estrutura cl√°ssica para um √∫nico valor Avalia uma condi√ß√£o e executa diferentes blocos de c√≥digo √ötil para controle de fluxo em fun√ß√µes ifelse() - Vers√£o vetorizada para m√∫ltiplos valores Aplica a condi√ß√£o a cada elemento de um vetor Retorna um vetor de resultados Ideal para criar novas colunas em data.frames case_when() - Para m√∫ltiplas condi√ß√µes complexas Fun√ß√£o do pacote dplyr (requer library(dplyr)) Avalia v√°rias regras em sequ√™ncia Para na primeira regra verdadeira Mais leg√≠vel que ifelse() aninhados Integra-se perfeitamente com o pipe %&gt;% e mutate() # ============================================ # 1. IF/ELSE - DECIS√ïES √öNICAS # ============================================ # Exemplo 1: Classificar um reprodutor dep_leite &lt;- 920 acuracia &lt;- 0.88 if (dep_leite &gt; 800 &amp; acuracia &gt;= 0.80) { categoria &lt;- &quot;Elite&quot; print(paste(&quot;Touro classificado como:&quot;, categoria)) print(&quot;Recomendado para IA em todo o rebanho&quot;) } else { categoria &lt;- &quot;Padr√£o&quot; print(paste(&quot;Touro classificado como:&quot;, categoria)) print(&quot;Uso restrito no rebanho&quot;) } # Exemplo 2: Decis√£o de acasalamento com m√∫ltiplas op√ß√µes consanguinidade_combinada &lt;- 0.07 if (consanguinidade_combinada &lt; 0.05) { print(&quot;‚úì Acasalamento RECOMENDADO - baixo risco&quot;) } else if (consanguinidade_combinada &gt;= 0.05 &amp; consanguinidade_combinada &lt; 0.10) { print(&quot;‚ö† Acasalamento com CAUTELA - risco moderado&quot;) } else { print(&quot;‚úó Acasalamento N√ÉO RECOMENDADO - alto risco&quot;) } # Exemplo 3: Fun√ß√£o para avaliar touros avaliar_touro &lt;- function(dep_leite, dep_gordura, acuracia) { if (acuracia &lt; 0.60) { return(&quot;Avalia√ß√£o n√£o confi√°vel - aguardar mais filhas&quot;) } if (dep_leite &gt; 900 &amp; dep_gordura &gt; 35 &amp; acuracia &gt;= 0.85) { return(&quot;ELITE - Top 1%&quot;) } else if (dep_leite &gt; 700 &amp; dep_gordura &gt; 28 &amp; acuracia &gt;= 0.75) { return(&quot;SUPERIOR - Top 10%&quot;) } else if (dep_leite &gt; 500 &amp; dep_gordura &gt; 22) { return(&quot;BOM - Acima da m√©dia&quot;) } else { return(&quot;REGULAR - Abaixo da m√©dia&quot;) } } # Testando a fun√ß√£o print(avaliar_touro(920, 38, 0.88)) # ELITE print(avaliar_touro(750, 30, 0.80)) # SUPERIOR print(avaliar_touro(450, 20, 0.55)) # Avalia√ß√£o n√£o confi√°vel # ============================================ # 2. IFELSE() - VETORIZADO PARA M√öLTIPLOS VALORES # ============================================ # Exemplo 1: Classificar m√∫ltiplas DEPs deps_peso &lt;- c(25, 18, 32, 15, 28, 22, 8, 30) # Classificar cada DEP classificacao &lt;- ifelse(deps_peso &gt;= 25, &quot;Superior&quot;, &quot;Padr√£o&quot;) print(classificacao) # &quot;Superior&quot; &quot;Padr√£o&quot; &quot;Superior&quot; &quot;Padr√£o&quot; &quot;Superior&quot; &quot;Padr√£o&quot; &quot;Padr√£o&quot; &quot;Superior&quot; # Exemplo 2: Criar coluna de classifica√ß√£o em dataframe rebanho &lt;- data.frame( animal_id = c(&quot;V001&quot;, &quot;V002&quot;, &quot;V003&quot;, &quot;V004&quot;, &quot;V005&quot;), dep_leite = c(850, 650, 920, 550, 780), acuracia = c(0.85, 0.75, 0.90, 0.60, 0.80) ) # Adicionar classifica√ß√£o gen√©tica rebanho$categoria_genetica &lt;- ifelse( rebanho$dep_leite &gt; 800, &quot;Elite&quot;, &quot;Padr√£o&quot; ) print(rebanho) # Exemplo 3: ifelse aninhado (cuidado - pode ficar confuso!) rebanho$status &lt;- ifelse( rebanho$dep_leite &gt; 850, &quot;Excelente&quot;, ifelse( rebanho$dep_leite &gt; 700, &quot;Bom&quot;, &quot;Regular&quot; ) ) print(rebanho[, c(&quot;animal_id&quot;, &quot;dep_leite&quot;, &quot;status&quot;)]) # Exemplo 4: Decis√£o de sele√ß√£o rebanho$selecionar &lt;- ifelse( rebanho$dep_leite &gt; 750 &amp; rebanho$acuracia &gt;= 0.75, &quot;SIM&quot;, &quot;N√ÉO&quot; ) print(rebanho[, c(&quot;animal_id&quot;, &quot;dep_leite&quot;, &quot;acuracia&quot;, &quot;selecionar&quot;)]) # ============================================ # 3. CASE_WHEN() - M√öLTIPLAS CONDI√á√ïES COMPLEXAS # ============================================ library(dplyr) # Exemplo 1: Sistema de classifica√ß√£o completo touros &lt;- data.frame( id = c(&quot;T001&quot;, &quot;T002&quot;, &quot;T003&quot;, &quot;T004&quot;, &quot;T005&quot;, &quot;T006&quot;), dep_leite = c(950, 780, 650, 850, 450, 1100), dep_gordura = c(38, 30, 25, 32, 20, 42), dep_proteina = c(32, 28, 22, 30, 18, 38), acuracia = c(0.90, 0.78, 0.65, 0.85, 0.55, 0.92), consanguinidade = c(0.02, 0.05, 0.08, 0.03, 0.10, 0.01) ) # Classifica√ß√£o com case_when (MUITO MAIS LEG√çVEL!) touros &lt;- touros %&gt;% mutate( classificacao = case_when( # Primeiro verifica problemas acuracia &lt; 0.60 ~ &quot;N√£o confi√°vel - aguardar&quot;, consanguinidade &gt; 0.08 ~ &quot;Descarte - alta consanguinidade&quot;, # Depois classifica por m√©rito gen√©tico dep_leite &gt; 1000 &amp; dep_gordura &gt; 40 &amp; dep_proteina &gt; 35 ~ &quot;Elite AAA&quot;, dep_leite &gt; 900 &amp; dep_gordura &gt; 35 &amp; dep_proteina &gt; 30 ~ &quot;Elite AA&quot;, dep_leite &gt; 800 &amp; dep_gordura &gt; 30 &amp; dep_proteina &gt; 28 ~ &quot;Elite A&quot;, dep_leite &gt; 700 &amp; dep_gordura &gt; 25 ~ &quot;Superior&quot;, dep_leite &gt; 600 ~ &quot;Bom&quot;, # Caso contr√°rio TRUE ~ &quot;Regular&quot; ) ) print(touros[, c(&quot;id&quot;, &quot;dep_leite&quot;, &quot;classificacao&quot;)]) # Exemplo 2: Recomenda√ß√£o de uso do touro touros &lt;- touros %&gt;% mutate( recomendacao = case_when( classificacao %in% c(&quot;Elite AAA&quot;, &quot;Elite AA&quot;) ~ &quot;IA comercial + FIV&quot;, classificacao == &quot;Elite A&quot; ~ &quot;IA comercial&quot;, classificacao == &quot;Superior&quot; ~ &quot;IA no pr√≥prio rebanho&quot;, classificacao == &quot;Bom&quot; ~ &quot;Monta natural&quot;, classificacao == &quot;Regular&quot; ~ &quot;N√£o usar&quot;, TRUE ~ &quot;Avaliar novamente&quot; ) ) print(touros[, c(&quot;id&quot;, &quot;classificacao&quot;, &quot;recomendacao&quot;)]) # Exemplo 3: √çndice de sele√ß√£o com m√∫ltiplos crit√©rios vacas &lt;- data.frame( id = paste0(&quot;V&quot;, sprintf(&quot;%03d&quot;, 1:10)), dep_leite = c(850, 750, 920, 650, 780, 500, 880, 720, 950, 600), dep_gordura = c(32, 28, 38, 24, 30, 20, 34, 26, 40, 22), dep_proteina = c(28, 25, 32, 20, 27, 18, 30, 24, 35, 21), fertilidade = c(0.65, 0.58, 0.70, 0.45, 0.62, 0.40, 0.68, 0.55, 0.72, 0.48), idade = c(4, 6, 3, 8, 5, 9, 4, 7, 3, 8) ) # Decis√£o complexa de sele√ß√£o vacas &lt;- vacas %&gt;% mutate( decisao = case_when( # Descarte por idade ou fertilidade idade &gt; 8 ~ &quot;Descarte - idade avan√ßada&quot;, fertilidade &lt; 0.50 ~ &quot;Descarte - baixa fertilidade&quot;, # M√£es de touros (melhor gen√©tica) dep_leite &gt; 900 &amp; dep_gordura &gt; 35 &amp; dep_proteina &gt; 30 &amp; fertilidade &gt; 0.65 ~ &quot;M√£e de touro - FIV&quot;, # Doadoras de embri√£o dep_leite &gt; 800 &amp; dep_gordura &gt; 30 &amp; dep_proteina &gt; 27 &amp; fertilidade &gt; 0.60 &amp; idade &lt;= 6 ~ &quot;Doadora - TE&quot;, # Matrizes superiores dep_leite &gt; 750 &amp; dep_gordura &gt; 28 &amp; fertilidade &gt; 0.58 ~ &quot;Matriz elite&quot;, # Matrizes padr√£o dep_leite &gt; 600 &amp; dep_gordura &gt; 22 ~ &quot;Matriz padr√£o&quot;, # Outros casos TRUE ~ &quot;Avaliar individualmente&quot; ) ) print(vacas[, c(&quot;id&quot;, &quot;dep_leite&quot;, &quot;fertilidade&quot;, &quot;idade&quot;, &quot;decisao&quot;)]) # ============================================ # EXEMPLO 4: C√ÅLCULO DE √çNDICE ECON√îMICO # ============================================ # Gado de corte - m√∫ltiplas caracter√≠sticas bovinos_corte &lt;- data.frame( id = paste0(&quot;B&quot;, 1:8), dep_peso_desmame = c(25, 18, 32, 15, 28, 22, 8, 30), dep_ganho_pos = c(20, 15, 25, 12, 22, 18, 10, 28), dep_aol = c(3.2, 2.1, 3.8, 1.5, 3.0, 2.5, 1.2, 4.0), # √°rea olho lombo dep_eg = c(-1.5, -0.8, -2.0, 0.5, -1.2, -0.5, 1.0, -2.5), # esp. gordura temperamento = c(&quot;√ìtimo&quot;, &quot;Bom&quot;, &quot;√ìtimo&quot;, &quot;Regular&quot;, &quot;Bom&quot;, &quot;Regular&quot;, &quot;Ruim&quot;, &quot;√ìtimo&quot;) ) # Calcular √≠ndice e classificar bovinos_corte &lt;- bovinos_corte %&gt;% mutate( # √çndice composto (pesos econ√¥micos simplificados) indice = (dep_peso_desmame * 2) + (dep_ganho_pos * 1.5) + (dep_aol * 5) - (dep_eg * 2), # gordura negativa √© boa # Classifica√ß√£o final categoria = case_when( temperamento == &quot;Ruim&quot; ~ &quot;Descarte - temperamento&quot;, indice &gt; 100 ~ &quot;Elite - Top 1%&quot;, indice &gt; 80 ~ &quot;Superior - Top 10%&quot;, indice &gt; 60 ~ &quot;Bom - Top 25%&quot;, indice &gt; 40 ~ &quot;M√©dio&quot;, TRUE ~ &quot;Abaixo da m√©dia&quot; ) ) print(bovinos_corte[, c(&quot;id&quot;, &quot;indice&quot;, &quot;temperamento&quot;, &quot;categoria&quot;)]) # ============================================ # COMPARA√á√ÉO: ifelse() vs case_when() # ============================================ # DIF√çCIL DE LER com ifelse aninhado: vacas$classe_ruim &lt;- ifelse( vacas$dep_leite &gt; 900, &quot;Elite&quot;, ifelse( vacas$dep_leite &gt; 800, &quot;Superior&quot;, ifelse( vacas$dep_leite &gt; 700, &quot;Boa&quot;, ifelse( vacas$dep_leite &gt; 600, &quot;Regular&quot;, &quot;Ruim&quot; ) ) ) ) # F√ÅCIL DE LER com case_when: vacas &lt;- vacas %&gt;% mutate( classe_boa = case_when( dep_leite &gt; 900 ~ &quot;Elite&quot;, dep_leite &gt; 800 ~ &quot;Superior&quot;, dep_leite &gt; 700 ~ &quot;Boa&quot;, dep_leite &gt; 600 ~ &quot;Regular&quot;, TRUE ~ &quot;Ruim&quot; ) ) # ============================================ # EXERC√çCIO PR√ÅTICO # ============================================ # Base de dados completa plantel &lt;- data.frame( animal = paste0(&quot;A&quot;, sprintf(&quot;%03d&quot;, 1:15)), dep_leite = c(950, 780, 650, 850, 450, 920, 720, 550, 880, 600, 1050, 700, 820, 580, 960), dep_gordura = c(38, 30, 25, 32, 20, 36, 28, 22, 34, 24, 42, 26, 33, 21, 39), acuracia = c(0.90, 0.78, 0.65, 0.85, 0.55, 0.88, 0.72, 0.60, 0.82, 0.68, 0.92, 0.70, 0.80, 0.58, 0.89), idade = c(4, 6, 8, 5, 9, 3, 7, 8, 4, 9, 3, 6, 5, 10, 4), n_partos = c(2, 4, 6, 3, 7, 1, 5, 6, 2, 7, 1, 4, 3, 8, 2), consanguinidade = c(0.02, 0.05, 0.08, 0.03, 0.10, 0.01, 0.06, 0.09, 0.03, 0.12, 0.01, 0.05, 0.04, 0.11, 0.02) ) # Criar sistema completo de classifica√ß√£o e decis√£o plantel &lt;- plantel %&gt;% mutate( # 1. Confiabilidade da avalia√ß√£o confiabilidade = case_when( acuracia &gt;= 0.85 ~ &quot;Alta&quot;, acuracia &gt;= 0.70 ~ &quot;M√©dia&quot;, TRUE ~ &quot;Baixa&quot; ), # 2. M√©rito gen√©tico merito = case_when( dep_leite &gt; 900 &amp; dep_gordura &gt; 35 ~ &quot;Excepcional&quot;, dep_leite &gt; 800 &amp; dep_gordura &gt; 30 ~ &quot;Superior&quot;, dep_leite &gt; 700 &amp; dep_gordura &gt; 25 ~ &quot;Bom&quot;, dep_leite &gt; 600 ~ &quot;Regular&quot;, TRUE ~ &quot;Inferior&quot; ), # 3. Status reprodutivo status_reprodutivo = case_when( idade &gt; 9 | n_partos &gt; 7 ~ &quot;Final de vida produtiva&quot;, idade &gt;= 7 | n_partos &gt;= 5 ~ &quot;Madura&quot;, idade &lt;= 4 &amp; n_partos &lt;= 2 ~ &quot;Jovem&quot;, TRUE ~ &quot;Adulta&quot; ), # 4. Decis√£o final de manejo decisao_final = case_when( # Problemas graves consanguinidade &gt; 0.10 ~ &quot;DESCARTE - alta consanguinidade&quot;, idade &gt; 9 &amp; dep_leite &lt; 700 ~ &quot;DESCARTE - idade e baixa produ√ß√£o&quot;, confiabilidade == &quot;Baixa&quot; &amp; merito %in% c(&quot;Regular&quot;, &quot;Inferior&quot;) ~ &quot;AVALIAR NOVAMENTE - dados insuficientes&quot;, # Animais elite merito == &quot;Excepcional&quot; &amp; confiabilidade == &quot;Alta&quot; &amp; idade &lt;= 6 ~ &quot;M√ÉE DE TOURO - programa FIV&quot;, merito %in% c(&quot;Excepcional&quot;, &quot;Superior&quot;) &amp; confiabilidade %in% c(&quot;Alta&quot;, &quot;M√©dia&quot;) ~ &quot;DOADORA - programa TE&quot;, # Animais bons merito %in% c(&quot;Superior&quot;, &quot;Bom&quot;) &amp; consanguinidade &lt; 0.05 ~ &quot;MATRIZ ELITE - manter no rebanho&quot;, merito == &quot;Bom&quot; ~ &quot;MATRIZ PADR√ÉO - manter&quot;, # Outros merito == &quot;Regular&quot; &amp; idade &lt; 6 ~ &quot;MONITORAR - dar mais oportunidade&quot;, TRUE ~ &quot;AVALIAR CASO A CASO&quot; ) ) # Visualizar resultado print(plantel[, c(&quot;animal&quot;, &quot;merito&quot;, &quot;confiabilidade&quot;, &quot;decisao_final&quot;)]) # Resumo por decis√£o table(plantel$decisao_final) Dica did√°tica: use ifelse() quando quiser vetorizar; case_when() quando houver v√°rias regras. 8.2 Loops, Vetoriza√ß√£o e Fun√ß√µes (25 min) 8.2.1 O que s√£o loops? Um loop (la√ßo) √© uma estrutura que repete um bloco de c√≥digo v√°rias vezes. S√£o fundamentais para automatizar tarefas repetitivas em programas de melhoramento gen√©tico. 8.2.2 Tipos de loops no R 8.2.2.1 Op√ß√µes Nativas (R Base) Loop for - N√∫mero Definido de Itera√ß√µes O loop for √© o mais comum e executa c√≥digo uma vez para cada elemento de uma sequ√™ncia. Sintaxe: for (vari√°vel in sequ√™ncia) { c√≥digo } # ============================================ # LOOP FOR - EXEMPLOS B√ÅSICOS # ============================================ # Exemplo 1: Calcular DEPs padronizadas deps_peso &lt;- c(25, 18, 32, 15, 28, 22, 8, 30) animal_ids &lt;- paste0(&quot;A&quot;, sprintf(&quot;%03d&quot;, 1:length(deps_peso))) media &lt;- mean(deps_peso) dp &lt;- sd(deps_peso) cat(&quot;DEPs PADRONIZADAS\\n&quot;) cat(&quot;=================\\n\\n&quot;) for (i in 1:length(deps_peso)) { dep_padronizada &lt;- (deps_peso[i] - media) / dp cat(&quot;Animal&quot;, animal_ids[i], &quot;- DEP:&quot;, deps_peso[i], &quot;| Padronizada:&quot;, round(dep_padronizada, 2), &quot;\\n&quot;) } # Exemplo 2: Simular ganho gen√©tico por gera√ß√£o n_geracoes &lt;- 10 dep_inicial &lt;- 500 intensidade_selecao &lt;- 1.5 # i herdabilidade &lt;- 0.30 # h¬≤ desvio_padrao &lt;- 100 # œÉ # Resposta √† sele√ß√£o: R = i √ó h¬≤ √ó œÉ resposta &lt;- intensidade_selecao * herdabilidade * desvio_padrao deps_geracao &lt;- numeric(n_geracoes) deps_geracao[1] &lt;- dep_inicial cat(&quot;\\n\\nSIMULA√á√ÉO DE GANHO GEN√âTICO\\n&quot;) cat(&quot;============================\\n\\n&quot;) for (geracao in 2:n_geracoes) { deps_geracao[geracao] &lt;- deps_geracao[geracao - 1] + resposta cat(&quot;Gera√ß√£o&quot;, geracao, &quot;- DEP m√©dia:&quot;, round(deps_geracao[geracao], 1), &quot;kg\\n&quot;) } ganho_total &lt;- deps_geracao[n_geracoes] - deps_geracao[1] cat(&quot;\\nGanho total:&quot;, round(ganho_total, 1), &quot;kg&quot;) Loop while - Baseado em Condi√ß√£o O while repete enquanto uma condi√ß√£o for verdadeira. Usado quando voc√™ n√£o sabe quantas itera√ß√µes ser√£o necess√°rias. Sintaxe: while (condi√ß√£o) { c√≥digo } Cuidado: pode criar loops infinitos se a condi√ß√£o nunca ficar FALSE! # ============================================ # LOOP WHILE - CONVERG√äNCIA # ============================================ # Algoritmo de converg√™ncia (exemplo simplificado de EM) variancia_genetica &lt;- 100 variancia_residual &lt;- 200 criterio_convergencia &lt;- 0.01 max_iteracoes &lt;- 100 iteracao &lt;- 0 convergiu &lt;- FALSE cat(&quot;ALGORITMO DE CONVERG√äNCIA\\n&quot;) cat(&quot;=========================\\n\\n&quot;) while (!convergiu &amp; iteracao &lt; max_iteracoes) { iteracao &lt;- iteracao + 1 vg_anterior &lt;- variancia_genetica vr_anterior &lt;- variancia_residual # Atualiza√ß√£o simulada variancia_genetica &lt;- vg_anterior * 1.05 variancia_residual &lt;- vr_anterior * 0.98 # Verificar converg√™ncia mudanca_vg &lt;- abs(variancia_genetica - vg_anterior) mudanca_vr &lt;- abs(variancia_residual - vr_anterior) if (mudanca_vg &lt; criterio_convergencia &amp; mudanca_vr &lt; criterio_convergencia) { convergiu &lt;- TRUE } if (iteracao %% 10 == 0) { cat(&quot;Itera√ß√£o&quot;, iteracao, &quot;- VG:&quot;, round(variancia_genetica, 2), &quot;VR:&quot;, round(variancia_residual, 2), &quot;\\n&quot;) } } cat(&quot;\\nConvergiu em&quot;, iteracao, &quot;itera√ß√µes&quot;) cat(&quot;\\nHerdabilidade final:&quot;, round(variancia_genetica / (variancia_genetica + variancia_residual), 3)) Loop repeat - Loop Infinito com Controle Manual O repeat repete indefinidamente at√© encontrar um break. Sempre precisa de condi√ß√£o de parada. Sintaxe: repeat { c√≥digo; if (condi√ß√£o) break } # ============================================ # LOOP REPEAT - M√öLTIPLOS CRIT√âRIOS DE PARADA # ============================================ set.seed(123) populacao_size &lt;- 100 dep_media &lt;- 500 geracao &lt;- 0 max_geracoes &lt;- 50 meta_dep &lt;- 700 sem_melhoria &lt;- 0 max_sem_melhoria &lt;- 10 cat(&quot;ALGORITMO GEN√âTICO\\n&quot;) cat(&quot;==================\\n\\n&quot;) repeat { geracao &lt;- geracao + 1 deps_populacao &lt;- rnorm(populacao_size, mean = dep_media, sd = 50) deps_selecionados &lt;- sort(deps_populacao, decreasing = TRUE)[1:20] nova_media &lt;- mean(deps_selecionados) if (abs(nova_media - dep_media) &lt; 1) { sem_melhoria &lt;- sem_melhoria + 1 } else { sem_melhoria &lt;- 0 } dep_media &lt;- nova_media if (geracao %% 5 == 0) { cat(&quot;Gera√ß√£o&quot;, geracao, &quot;- DEP:&quot;, round(dep_media, 1), &quot;kg\\n&quot;) } # M√∫ltiplos crit√©rios de parada if (dep_media &gt;= meta_dep) { cat(&quot;\\n‚úì META ATINGIDA!\\n&quot;) break } if (geracao &gt;= max_geracoes) { cat(&quot;\\n‚ö† M√°ximo de gera√ß√µes\\n&quot;) break } if (sem_melhoria &gt;= max_sem_melhoria) { cat(&quot;\\n‚ö† Sem melhoria h√°&quot;, max_sem_melhoria, &quot;gera√ß√µes\\n&quot;) break } } Fam√≠lia apply() - Alternativa Funcional As fun√ß√µes da fam√≠lia apply s√£o alternativas mais elegantes e geralmente mais r√°pidas que loops tradicionais. # ============================================ # FAM√çLIA APPLY - R BASE # ============================================ # apply() - Para matrizes/arrays deps_matriz &lt;- matrix( c(25, 32, 1.8, 18, 28, 1.5, 32, 38, 2.2, 15, 22, 1.2, 28, 35, 2.0), nrow = 5, byrow = TRUE, dimnames = list( paste0(&quot;Animal_&quot;, 1:5), c(&quot;DEP_Peso&quot;, &quot;DEP_Ganho&quot;, &quot;DEP_AOL&quot;) ) ) cat(&quot;Matriz de DEPs:\\n&quot;) print(deps_matriz) # M√©dia por animal (linha) - MARGIN = 1 cat(&quot;\\nM√©dia por animal:\\n&quot;) medias_animais &lt;- apply(deps_matriz, 1, mean) print(round(medias_animais, 2)) # M√©dia por caracter√≠stica (coluna) - MARGIN = 2 cat(&quot;\\nM√©dia por caracter√≠stica:\\n&quot;) medias_caracteristicas &lt;- apply(deps_matriz, 2, mean) print(round(medias_caracteristicas, 2)) # lapply() - Retorna lista rebanhos &lt;- list( Rebanho_A = c(850, 780, 920, 750, 880), Rebanho_B = c(720, 650, 800, 680, 760), Rebanho_C = c(950, 880, 1020, 870, 930) ) cat(&quot;\\n\\nEstat√≠sticas por rebanho (lapply):\\n&quot;) estatisticas &lt;- lapply(rebanhos, function(deps) { list( media = mean(deps), dp = sd(deps), n = length(deps), cv = sd(deps)/mean(deps)*100 ) }) print(estatisticas) # sapply() - Simplifica para vetor/matriz cat(&quot;\\n\\nM√©dias dos rebanhos (sapply):\\n&quot;) medias_rebanhos &lt;- sapply(rebanhos, mean) print(round(medias_rebanhos, 1)) # tapply() - Aplicar por grupos animais &lt;- data.frame( dep_leite = c(850, 750, 920, 680, 820, 650, 880, 700), raca = c(&quot;Holand√™s&quot;, &quot;Jersey&quot;, &quot;Holand√™s&quot;, &quot;Jersey&quot;, &quot;Holand√™s&quot;, &quot;Jersey&quot;, &quot;Holand√™s&quot;, &quot;Jersey&quot;) ) cat(&quot;\\n\\nM√©dia de DEP por ra√ßa (tapply):\\n&quot;) media_raca &lt;- tapply(animais$dep_leite, animais$raca, mean) print(round(media_raca, 1)) 8.2.2.2 Op√ß√µes de Pacotes (purrr/tidyverse) Fam√≠lia map() - Sintaxe Moderna e Consistente A fam√≠lia map() do pacote purrr oferece sintaxe mais consistente e previs√≠vel que apply(). library(purrr) # ============================================ # FAM√çLIA MAP - PURRR # ============================================ # map() - Retorna lista cat(&quot;M√©dias dos rebanhos (map):\\n&quot;) medias_map &lt;- map(rebanhos, mean) print(medias_map) # map_dbl() - Retorna vetor num√©rico cat(&quot;\\n\\nM√©dias dos rebanhos como vetor (map_dbl):\\n&quot;) medias_fazendas &lt;- map_dbl(rebanhos, mean) print(round(medias_fazendas, 1)) # map_chr() - Retorna vetor de caracteres cat(&quot;\\n\\nClassifica√ß√£o dos rebanhos (map_chr):\\n&quot;) classificacao &lt;- map_chr(rebanhos, ~{ media &lt;- mean(.x) case_when( media &gt; 900 ~ &quot;Excelente&quot;, media &gt; 850 ~ &quot;√ìtimo&quot;, media &gt; 800 ~ &quot;Bom&quot;, TRUE ~ &quot;Regular&quot; ) }) print(classificacao) # map_df() - Retorna data frame cat(&quot;\\n\\nEstat√≠sticas completas (map_df):\\n&quot;) estatisticas_df &lt;- map_df(rebanhos, ~{ tibble( n = length(.x), media = mean(.x), dp = sd(.x), min = min(.x), max = max(.x) ) }, .id = &quot;rebanho&quot;) print(estatisticas_df) 8.2.3 Loops vs.¬†Vetoriza√ß√£o Vetoriza√ß√£o √© quando opera√ß√µes s√£o aplicadas automaticamente a todos os elementos sem loop expl√≠cito. Por que evitar loops em R? R √© uma linguagem vetorizada, o que significa que muitas opera√ß√µes funcionam automaticamente em vetores inteiros. Opera√ß√µes vetorizadas s√£o: Mais r√°pidas (otimizadas internamente em C/Fortran) Mais leg√≠veis (menos linhas de c√≥digo) Mais idiom√°ticas (o ‚Äújeito R‚Äù de fazer) Quando usar loops: Quando n√£o existe alternativa vetorizada Para opera√ß√µes que dependem de itera√ß√µes anteriores Em simula√ß√µes e processos iterativos # ============================================ # COMPARA√á√ÉO: LOOP vs VETORIZA√á√ÉO # ============================================ deps &lt;- c(850, 750, 920, 680, 820) # COM LOOP (lento, verboso) deps_padronizadas_loop &lt;- numeric(length(deps)) for (i in 1:length(deps)) { deps_padronizadas_loop[i] &lt;- (deps[i] - mean(deps)) / sd(deps) } cat(&quot;Com loop:\\n&quot;) print(round(deps_padronizadas_loop, 2)) # VETORIZADO (r√°pido, limpo) deps_padronizadas_vet &lt;- (deps - mean(deps)) / sd(deps) cat(&quot;\\nVetorizado:\\n&quot;) print(round(deps_padronizadas_vet, 2)) # Resultados id√™nticos cat(&quot;\\nResultados iguais?&quot;, all.equal(deps_padronizadas_loop, deps_padronizadas_vet)) Hierarquia de prefer√™ncia no R: Vetoriza√ß√£o (quando poss√≠vel) - deps * 2 Fam√≠lia apply/map - sapply(), map_dbl() Loop for - quando n√£o h√° alternativa while/repeat - apenas quando necess√°rio Regra de ouro: Se voc√™ pode vetorizar, vetorize! valores &lt;- 1:5 # Loop for (did√°tico, mas n√£o idiom√°tico) soma &lt;- 0 for (v in valores) { soma &lt;- soma + v } cat(&quot;Soma com loop:&quot;, soma, &quot;\\n&quot;) # Vetorizado (preferido em R!) cat(&quot;Soma vetorizada:&quot;, sum(valores), &quot;\\n&quot;) 8.2.4 Fun√ß√µes: empacotando l√≥gica reutiliz√°vel O que s√£o fun√ß√µes? Fun√ß√µes s√£o blocos de c√≥digo que realizam uma tarefa espec√≠fica e podem ser reutilizados. S√£o fundamentais para: - Organizar c√≥digo em partes l√≥gicas - Reutilizar l√≥gica sem repetir c√≥digo - Documentar inten√ß√µes atrav√©s de nomes descritivos - Facilitar manuten√ß√£o e debugging Estrutura de uma fun√ß√£o: nome_funcao &lt;- function(argumento1, argumento2 = valor_padrao) { # corpo da fun√ß√£o resultado &lt;- alguma_operacao return(resultado) # return √© opcional (retorna √∫ltima express√£o) } Boas pr√°ticas: - Use nomes descritivos que indiquem o que a fun√ß√£o faz - Valide entradas com stop(), stopifnot() ou if - Documente com coment√°rios o que a fun√ß√£o faz e quais s√£o os argumentos - Retorne sempre o mesmo tipo de objeto Exemplo pr√°tico: calculadora de IMC # F√≥rmula: IMC = peso(kg) / altura(m)^2 imc &lt;- function(peso, altura) { # Valida√ß√£o: altura n√£o pode ser zero ou negativa if (any(altura &lt;= 0)) stop(&quot;Altura deve ser &gt; 0&quot;) # C√°lculo vetorizado (funciona com um ou v√°rios valores) peso / (altura ^ 2) } # Testando com m√∫ltiplos valores imc(c(70, 80), c(1.70, 1.80)) # Fun√ß√£o para classificar IMC usando case_when() classificar_imc &lt;- function(imc) { dplyr::case_when( imc &lt; 18.5 ~ &quot;Abaixo do peso&quot;, imc &gt;= 18.5 &amp; imc &lt; 25 ~ &quot;Normal&quot;, imc &gt;= 25 &amp; imc &lt; 30 ~ &quot;Sobrepeso&quot;, imc &gt;= 30 ~ &quot;Obesidade&quot; ) } # Combinando as duas fun√ß√µes val &lt;- imc(80, 1.75) classificar_imc(val) Princ√≠pio DRY (Don‚Äôt Repeat Yourself): se voc√™ copiou e colou c√≥digo mais de 2 vezes, provavelmente deveria criar uma fun√ß√£o! 8.3 Introdu√ß√£o ao Tidyverse (45 min) Vamos aplicar dplyr no dataset palmerpenguins e criar um pequeno pipeline. library(dplyr) library(palmerpenguins) # Remover linhas com NAs nas colunas essenciais peng &lt;- penguins |&gt; filter(!is.na(species), !is.na(bill_length_mm), !is.na(bill_depth_mm), !is.na(flipper_length_mm), !is.na(body_mass_g)) # Selecionar s√≥ o que precisamos peng_sel &lt;- peng |&gt; select(species, island, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g) # Criar nova vari√°vel (raz√£o do bico) e reordenar peng_feat &lt;- peng_sel |&gt; mutate(raz_bico = bill_length_mm / bill_depth_mm) |&gt; arrange(species, desc(raz_bico)) # Resumo por esp√©cie resumo &lt;- peng_feat |&gt; group_by(species) |&gt; summarize( n = n(), media_flipper = mean(flipper_length_mm), sd_flipper = sd(flipper_length_mm), media_massa = mean(body_mass_g) ) resumo 8.4 Pipe: %&gt;% vs.¬†|&gt; # Ambos funcionam; escolha um padr√£o para a turma. # Exemplo com |&gt; (pipe nativo do R &gt;= 4.1): penguins |&gt; tidyr::drop_na(bill_length_mm) |&gt; dplyr::summarize(media = mean(bill_length_mm)) 8.5 Datas com lubridate (10 min) Datas aparecem em quase todos os projetos. Vamos ilustrar rapidamente. library(lubridate) # Cria√ß√£o e parsing ymd(&quot;2025-11-18&quot;) dmy(&quot;18/11/2025&quot;) mdy(&quot;11-18-2025&quot;) # Componentes hoje &lt;- today() year(hoje) month(hoje) wday(hoje, label = TRUE, abbr = FALSE) # Opera√ß√µes simples hoje + days(14) interval(ymd(&quot;2025-11-01&quot;), ymd(&quot;2025-11-18&quot;)) Integrando no pipeline: quando houver colunas de data, transforme-as e derive m√™s/ano para agrega√ß√µes. 8.6 Exerc√≠cios Pr√°ticos (20‚Äì25 min) Dataset: palmerpenguins::penguins 8.6.1 Exerc√≠cio 1 ‚Äî Condicionais Crie um vetor de 8 notas qualquer. Classifique com ifelse() como Aprovado/Recupera√ß√£o (corte em 7). Depois, crie uma classifica√ß√£o mais rica usando case_when() com 4 faixas. # Seu c√≥digo aqui 8.6.2 Exerc√≠cio 2 ‚Äî Fun√ß√µes Escreva uma fun√ß√£o zscore(x) que centraliza e escala (m√©dia 0, desvio 1). Aplique em bill_length_mm removendo NAs antes. Fa√ßa um segundo argumento opcional na_rm = TRUE dentro da fun√ß√£o. # Seu c√≥digo aqui 8.6.3 Exerc√≠cio 3 ‚Äî Pipeline dplyr Crie peng3 filtrando linhas completas nas 4 medidas principais. Calcule, por esp√©cie, m√©dia e desvio da nadadeira (flipper_length_mm). Ordene do maior para o menor e mostre as 5 primeiras linhas. # Seu c√≥digo aqui 8.6.4 Exerc√≠cio 4 ‚Äî Datas com lubridate Crie um vetor com 5 datas em formato ‚Äúdd/mm/aaaa‚Äù. Converta com dmy() e extraia month() (com r√≥tulo). Some 30 dias √† primeira data e compute o intervalo at√© a √∫ltima. # Seu c√≥digo aqui 8.7 Boas Pr√°ticas e Debugging (20 min) Use nomes descritivos em snake_case. Comente o porqu√™ (n√£o s√≥ o que) no c√≥digo. Valide entradas em fun√ß√µes (stop() para erros previs√≠veis). Leia mensagens de erro de baixo para cima (stack trace). Mantenha scripts curtos e reutiliz√°veis. 8.8 Ferramentas √∫teis # message(), warning(), stop() para sinalizar eventos # browser() para inspecionar dentro de uma fun√ß√£o (quando eval=TRUE) # traceback() ap√≥s um erro IA como apoio (respons√°vel): use ChatGPT/Claude para explicar erros e sugerir melhorias, mas sempre entenda e teste o c√≥digo. 8.9 Commit do Dia Salve como scripts/02_logica_funcoes.R ou materiais/dia2_logica_funcoes.Rmd (este arquivo). No Terminal do RStudio: git add scripts/02_logica_funcoes.R git commit -m &quot;Dia 2: l√≥gica, fun√ß√µes e tidyverse (com lubridate)&quot; git push origin main Lembre-se: voc√™ est√° trabalhando no SEU fork. O reposit√≥rio original permanece protegido. 8.10 Checklist de encerramento Dominou operadores l√≥gicos e relacionais Entendeu diferen√ßas entre if/else, ifelse() e case_when() Compreendeu por que vetoriza√ß√£o √© prefer√≠vel a loops Criou suas primeiras fun√ß√µes com valida√ß√£o Aplicou pipeline b√°sico com dplyr Explorou manipula√ß√£o de datas com lubridate Realizou commit e push no seu fork 8.11 Refer√™ncias r√°pidas dplyr cheatsheet: https://posit.co/resources/cheatsheets/ R for Data Science (2e): https://r4ds.hadley.nz/ Happy Git with R: https://happygitwithr.com/ palmerpenguins: https://allisonhorst.github.io/palmerpenguins/ lubridate: https://lubridate.tidyverse.org/ Nos vemos no Dia 3 para transforma√ß√£o de dados e visualiza√ß√£o com ggplot2! "],["dia-3-transforma√ß√£o-io-e-visualiza√ß√£o.html", "9 Dia 3: Transforma√ß√£o, I/O e Visualiza√ß√£o 9.1 Transforma√ß√£o e I/O de Dados (19h00 - 20h30) 9.2 INTERVALO (20h30 - 20h50) 9.3 Visualiza√ß√£o com ggplot2 (20h50 - 22h00) 9.4 Personaliza√ß√£o 9.5 Combinando Gr√°ficos (patchwork) 9.6 Salvando Gr√°ficos (ggsave) 9.7 Exerc√≠cios Pr√°ticos 9.8 Commit do Dia 9.9 Checklist de Encerramento 9.10 Refer√™ncias R√°pidas", " 9 Dia 3: Transforma√ß√£o, I/O e Visualiza√ß√£o Objetivos do dia Transformar dados com tidyr (pivot, separate, unite) Tratar valores ausentes adequadamente Ler e escrever dados de diferentes formatos (CSV, Excel) Organizar projetos com here::here() Criar visualiza√ß√µes profissionais com ggplot2 Combinar gr√°ficos e personalizar temas Tempo previsto: 19h00‚Äì22h00 (intervalo 20h30‚Äì20h50) 9.1 Transforma√ß√£o e I/O de Dados (19h00 - 20h30) 9.1.1 Tidyr: Transformando estruturas de dados 9.1.1.1 O que √© Tidyr? tidyr √© o pacote para reorganizar a estrutura dos seus dados. √â essencial porque muitas vezes recebemos dados em formatos ‚Äúbagun√ßados‚Äù (como planilhas do Excel) e precisamos transform√°-los em formato ‚Äútidy‚Äù para an√°lise. Principais fun√ß√µes: pivot_longer() / pivot_wider(): converter entre formatos wide ‚ÜîÔ∏é long separate() / unite(): dividir ou unir colunas drop_na(), replace_na(), fill(): tratar valores ausentes 9.1.1.2 pivot_longer(): Wide para Long O que faz: Transforma m√∫ltiplas colunas em duas novas colunas: uma com os nomes das colunas originais e outra com seus valores. Quando usar: Quando voc√™ tem m√∫ltiplas colunas que na verdade representam valores de uma mesma vari√°vel. Por exemplo, se voc√™ tem colunas ‚Äújan_2024‚Äù, ‚Äúfev_2024‚Äù, ‚Äúmar_2024‚Äù, elas na verdade representam valores de uma vari√°vel ‚Äúm√™s‚Äù. Por que usar: Dados no formato long (tidy) facilitam muito an√°lises com dplyr e visualiza√ß√µes com ggplot2. library(tidyverse) library(palmerpenguins) # Dados em formato WIDE (comum em planilhas) vendas_wide &lt;- tibble( produto = c(&quot;Notebook&quot;, &quot;Mouse&quot;, &quot;Teclado&quot;), jan_2024 = c(150, 320, 180), fev_2024 = c(180, 350, 200), mar_2024 = c(160, 380, 190) ) vendas_wide # Transformar para LONG (formato tidy) vendas_long &lt;- vendas_wide %&gt;% pivot_longer( cols = jan_2024:mar_2024, # Colunas para transformar names_to = &quot;mes_ano&quot;, # Nome da nova coluna de categorias values_to = &quot;quantidade&quot; # Nome da nova coluna de valores ) vendas_long # Limpar a coluna mes_ano vendas_long &lt;- vendas_long %&gt;% separate(mes_ano, into = c(&quot;mes&quot;, &quot;ano&quot;), sep = &quot;_&quot;) %&gt;% mutate( mes = case_when( mes == &quot;jan&quot; ~ &quot;Janeiro&quot;, mes == &quot;fev&quot; ~ &quot;Fevereiro&quot;, mes == &quot;mar&quot; ~ &quot;Mar√ßo&quot; ), ano = as.numeric(ano) ) vendas_long # Agora an√°lises ficam f√°ceis! vendas_long %&gt;% group_by(produto) %&gt;% summarize( total = sum(quantidade), media = mean(quantidade) ) 9.1.1.3 pivot_wider(): Long para Wide O que faz: Transforma duas colunas (uma de categorias e outra de valores) em m√∫ltiplas colunas, onde cada categoria vira uma coluna. Quando usar: - Para criar tabelas de resumo mais leg√≠veis (formato ‚Äúplanilha‚Äù) - Quando voc√™ precisa de uma coluna separada para cada categoria - Para preparar dados para certas an√°lises ou relat√≥rios √â o inverso do pivot_longer()! # Reverter para wide vendas_long %&gt;% unite(&quot;periodo&quot;, mes, ano, sep = &quot;_&quot;) %&gt;% # Unir m√™s e ano pivot_wider( names_from = periodo, values_from = quantidade ) # Exemplo pr√°tico: notas de alunos notas_long &lt;- tibble( aluno = rep(c(&quot;Ana&quot;, &quot;Bruno&quot;, &quot;Carla&quot;), each = 3), disciplina = rep(c(&quot;Matem√°tica&quot;, &quot;Portugu√™s&quot;, &quot;Hist√≥ria&quot;), 3), nota = c(8.5, 9.0, 7.5, 7.0, 8.0, 8.5, 9.5, 8.5, 9.0) ) notas_long # Transformar: disciplinas viram colunas notas_wide &lt;- notas_long %&gt;% pivot_wider( names_from = disciplina, values_from = nota ) notas_wide 9.1.1.4 separate() e unite() separate(): Divide uma coluna em m√∫ltiplas colunas usando um separador. Quando usar separate(): - Quando voc√™ tem informa√ß√µes combinadas em uma √∫nica coluna (ex: ‚ÄúS√£o Paulo-SP‚Äù) - Para extrair partes espec√≠ficas de um texto (ex: dia, m√™s, ano de uma data) - Para limpar dados mal formatados Argumentos principais: - col: coluna a ser dividida - into: vetor com nomes das novas colunas - sep: separador (pode ser um caractere ou regex) - extra: o que fazer com peda√ßos extras (‚Äúwarn‚Äù, ‚Äúdrop‚Äù, ‚Äúmerge‚Äù) unite(): Combina m√∫ltiplas colunas em uma √∫nica coluna. Quando usar unite(): - Para criar identificadores √∫nicos combinando campos (ex: ‚ÄúSP_001‚Äù) - Para formatar datas ou textos de maneira espec√≠fica - Para reverter um separate() anterior Argumentos principais: - col: nome da nova coluna - ...: colunas a combinar - sep: separador para usar na uni√£o # Dados com informa√ß√£o combinada dados &lt;- tibble( nome_completo = c(&quot;Ana Silva&quot;, &quot;Bruno Costa&quot;, &quot;Carla Dias&quot;), data_nasc = c(&quot;15/03/1995&quot;, &quot;22/07/1998&quot;, &quot;10/11/1993&quot;), cidade_estado = c(&quot;S√£o Paulo-SP&quot;, &quot;Rio de Janeiro-RJ&quot;, &quot;Belo Horizonte-MG&quot;) ) dados # SEPARATE: dividir colunas dados_separados &lt;- dados %&gt;% separate(nome_completo, into = c(&quot;nome&quot;, &quot;sobrenome&quot;), sep = &quot; &quot;) %&gt;% separate(data_nasc, into = c(&quot;dia&quot;, &quot;mes&quot;, &quot;ano&quot;), sep = &quot;/&quot;) %&gt;% separate(cidade_estado, into = c(&quot;cidade&quot;, &quot;estado&quot;), sep = &quot;-&quot;) dados_separados # UNITE: combinar colunas dados_unidos &lt;- dados_separados %&gt;% unite(&quot;nome_completo&quot;, nome, sobrenome, sep = &quot; &quot;) %&gt;% unite(&quot;data_nascimento&quot;, dia, mes, ano, sep = &quot;/&quot;) dados_unidos # Exemplo pr√°tico: limpar dados de telefone telefones &lt;- tibble( cliente = c(&quot;Jo√£o&quot;, &quot;Maria&quot;, &quot;Pedro&quot;), telefone = c(&quot;11-98765-4321&quot;, &quot;21-99876-5432&quot;, &quot;31-97654-3210&quot;) ) telefones %&gt;% separate(telefone, into = c(&quot;ddd&quot;, &quot;numero&quot;), sep = &quot;-&quot;, extra = &quot;merge&quot;) 9.1.2 Tratamento de Valores Ausentes (NA) O que s√£o NAs? NA (Not Available) representa valores ausentes ou desconhecidos em R. Eles aparecem por diversos motivos: - Dados n√£o coletados - Informa√ß√£o n√£o dispon√≠vel - Erros na coleta - Jun√ß√£o de tabelas sem correspond√™ncia Por que tratar NAs √© importante? Muitas fun√ß√µes retornam NA se houver qualquer NA nos dados NAs podem distorcer an√°lises estat√≠sticas Alguns modelos n√£o aceitam NAs √â importante decidir conscientemente o que fazer com dados ausentes Tr√™s estrat√©gias principais: 1. Identificar: entender onde e quantos NAs existem 2. Remover: excluir linhas/colunas com NAs (quando apropriado) 3. Imputar: substituir NAs por valores estimados 9.1.2.1 Identificar NAs Fun√ß√µes √∫teis: - is.na(): retorna TRUE/FALSE para cada elemento - sum(is.na()): conta quantos NAs existem - mean(is.na()): propor√ß√£o de NAs - complete.cases(): identifica linhas sem nenhum NA # Criar dados com NA para exemplo dados_na &lt;- tibble( id = 1:10, nome = c(&quot;Ana&quot;, &quot;Bruno&quot;, NA, &quot;Diego&quot;, &quot;Elena&quot;, &quot;Felipe&quot;, NA, &quot;Hugo&quot;, &quot;Iris&quot;, &quot;Jo√£o&quot;), idade = c(25, NA, 30, 28, NA, 35, 22, NA, 27, 29), salario = c(3000, 4500, NA, 5000, 3500, NA, 4000, 4800, NA, 5200) ) dados_na # Contar NAs por coluna dados_na %&gt;% summarize(across(everything(), ~sum(is.na(.)))) # Propor√ß√£o de NAs dados_na %&gt;% summarize(across(everything(), ~mean(is.na(.)) * 100)) # Identificar linhas com qualquer NA dados_na %&gt;% filter(if_any(everything(), is.na)) # Identificar linhas completas (sem NA) dados_na %&gt;% filter(if_all(everything(), ~!is.na(.))) 9.1.2.2 Remover NAs Quando remover NAs: - Quando representam uma por√ß√£o pequena dos dados (&lt; 5%) - Quando s√£o aleat√≥rios (n√£o h√° padr√£o sistem√°tico) - Quando voc√™ tem dados suficientes mesmo ap√≥s remo√ß√£o Cuidado: Remover NAs pode introduzir vi√©s se eles n√£o forem aleat√≥rios! Fun√ß√µes: - drop_na(): remove linhas com qualquer NA (ou em colunas espec√≠ficas) - na.omit(): similar ao drop_na (base R) - filter(!is.na()): remove NAs de colunas espec√≠ficas # Remover linhas com QUALQUER NA dados_na %&gt;% drop_na() # Remover linhas com NA em colunas espec√≠ficas dados_na %&gt;% drop_na(idade, salario) # Manter apenas linhas completas dados_na %&gt;% na.omit() # base R 9.1.2.3 Substituir NAs M√©todos de imputa√ß√£o (substitui√ß√£o): Valor fixo: substituir por 0, ‚ÄúDesconhecido‚Äù, etc. Use quando o NA tem significado espec√≠fico (ex: aus√™ncia = zero) Medida central: substituir por m√©dia, mediana ou moda Use para vari√°veis num√©ricas quando NAs s√£o poucos e aleat√≥rios Mediana √© mais robusta a outliers que m√©dia Forward/Backward fill: usar valor anterior ou posterior Use para s√©ries temporais ou dados sequenciais fill(.direction = \"down\"): preenche para baixo fill(.direction = \"up\"): preenche para cima Interpola√ß√£o: estimar baseado em valores pr√≥ximos Use para s√©ries temporais quando h√° padr√£o Mais sofisticado que fill Fun√ß√µes: - replace_na(): substitui por valor espec√≠fico - ifelse() + mean()/median(): substitui por estat√≠stica - fill(): preenche com valores adjacentes # Substituir por valor espec√≠fico dados_na %&gt;% mutate( nome = replace_na(nome, &quot;Desconhecido&quot;), idade = replace_na(idade, 0) ) # Substituir por medida central dados_na %&gt;% mutate( idade = ifelse(is.na(idade), median(idade, na.rm = TRUE), idade), salario = ifelse(is.na(salario), mean(salario, na.rm = TRUE), salario) ) # Preencher com valor anterior/posterior (fill) dados_sequencial &lt;- tibble( mes = 1:12, vendas = c(100, 120, NA, NA, 150, NA, 170, 180, NA, 200, 210, NA) ) dados_sequencial # Preencher para baixo (forward fill) dados_sequencial %&gt;% fill(vendas, .direction = &quot;down&quot;) # Preencher para cima (backward fill) dados_sequencial %&gt;% fill(vendas, .direction = &quot;up&quot;) # Interpola√ß√£o linear (mais sofisticado) dados_sequencial %&gt;% mutate(vendas = zoo::na.approx(vendas, na.rm = FALSE)) 9.1.3 Leitura e Escrita de Dados (I/O) I/O = Input/Output (Entrada/Sa√≠da) A capacidade de ler e escrever arquivos √© fundamental para qualquer an√°lise de dados. Voc√™ precisar√°: - Importar dados de diversas fontes (CSV, Excel, bancos de dados) - Exportar resultados para compartilhar ou usar em outras ferramentas 9.1.3.1 Por que usar readr em vez de fun√ß√µes base do R? readr (parte do tidyverse) √© melhor porque: - ‚úÖ Mais r√°pido (at√© 10x) - ‚úÖ Produz tibbles em vez de data.frames - ‚úÖ N√£o converte strings em fatores automaticamente - ‚úÖ Melhor tratamento de encoding (acentos!) - ‚úÖ Mensagens mais claras sobre tipos de colunas - ‚úÖ Sintaxe consistente e intuitiva 9.1.3.2 Leitura de arquivos CSV CSV = Comma-Separated Values (Valores Separados por V√≠rgula) √â o formato mais comum para dados tabulares. Mas aten√ß√£o: existem varia√ß√µes! read_csv(): Para arquivos com separador v√≠rgula (padr√£o internacional) - Exemplo: 1,2,3 - Decimal com ponto: 3.14 read_csv2(): Para arquivos com separador ponto-e-v√≠rgula (padr√£o brasileiro) - Exemplo: 1;2;3 - Decimal com v√≠rgula: 3,14 Par√¢metros importantes: - col_types: especificar tipos das colunas (evita surpresas) - locale: controlar encoding e formatos regionais - skip: pular linhas iniciais (cabe√ßalhos, notas) - n_max: ler apenas primeiras linhas (para testar) - na: definir quais valores representam NA library(readr) library(here) # Ler CSV com separador v√≠rgula (padr√£o internacional) # dados &lt;- read_csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;dados.csv&quot;)) # Ler CSV com separador ponto-e-v√≠rgula (padr√£o brasileiro) # dados &lt;- read_csv2(here(&quot;data&quot;, &quot;raw&quot;, &quot;dados.csv&quot;)) # Especificar encoding (importante para acentos!) # dados &lt;- read_csv( # here(&quot;data&quot;, &quot;raw&quot;, &quot;dados.csv&quot;), # locale = locale(encoding = &quot;UTF-8&quot;) # ) # Para arquivos com encoding Windows (latin1) # dados &lt;- read_csv( # here(&quot;data&quot;, &quot;raw&quot;, &quot;dados.csv&quot;), # locale = locale(encoding = &quot;latin1&quot;) # ) # Especificar tipos de colunas # dados &lt;- read_csv( # here(&quot;data&quot;, &quot;raw&quot;, &quot;dados.csv&quot;), # col_types = cols( # id = col_integer(), # nome = col_character(), # data = col_date(format = &quot;%d/%m/%Y&quot;), # valor = col_double() # ) # ) # Pular linhas iniciais # dados &lt;- read_csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;dados.csv&quot;), skip = 2) # Ler apenas primeiras linhas (para testar) # dados_preview &lt;- read_csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;dados.csv&quot;), n_max = 100) 9.1.3.3 O problema do encoding (acentua√ß√£o) Encoding define como caracteres especiais (acentos, √ß, etc.) s√£o armazenados. Problemas comuns: - Arquivo criado no Windows ‚Üí ler no Mac/Linux ‚Üí acentos aparecem como ÔøΩ - Excel salva em encoding diferente ‚Üí R l√™ errado ‚Üí ‚ÄúS√£o Paulo‚Äù vira ‚ÄúS√É¬£o Paulo‚Äù Solu√ß√µes: - UTF-8: padr√£o universal moderno - SEMPRE use para novos arquivos - latin1 (ISO-8859-1): comum em arquivos Windows antigos - Use locale(encoding = \"...\") para especificar Como descobrir o encoding? 1. Abra o arquivo no RStudio e veja se acentos est√£o corretos 2. Teste UTF-8 primeiro, depois latin1 3. Use guess_encoding() do readr para ajudar 9.1.3.4 Leitura de arquivos Excel Por que ler Excel? - Formato muito usado em empresas e pesquisas - Pode conter m√∫ltiplas planilhas - Formata√ß√£o e f√≥rmulas (que precisamos extrair) readxl vs writexl: - readxl: LER arquivos Excel (.xlsx, .xls) - writexl: ESCREVER arquivos Excel Vantagens do readxl: - ‚úÖ N√£o precisa de Java ou Excel instalado - ‚úÖ Funciona em Windows, Mac e Linux - ‚úÖ L√™ .xlsx (novo) e .xls (antigo) - ‚úÖ Preserva tipos de dados Par√¢metros √∫teis: - sheet: qual planilha ler (por nome ou n√∫mero) - range: ler apenas parte da planilha (ex: ‚ÄúA1:E100‚Äù) - skip: pular linhas iniciais - col_names: se primeira linha tem nomes das colunas - na: valores que devem ser tratados como NA library(readxl) # Ler primeira planilha # dados &lt;- read_excel(here(&quot;data&quot;, &quot;raw&quot;, &quot;planilha.xlsx&quot;)) # Especificar planilha por nome ou n√∫mero # dados &lt;- read_excel(here(&quot;data&quot;, &quot;raw&quot;, &quot;planilha.xlsx&quot;), sheet = &quot;Vendas&quot;) # dados &lt;- read_excel(here(&quot;data&quot;, &quot;raw&quot;, &quot;planilha.xlsx&quot;), sheet = 2) # Especificar intervalo de c√©lulas # dados &lt;- read_excel( # here(&quot;data&quot;, &quot;raw&quot;, &quot;planilha.xlsx&quot;), # range = &quot;A1:E100&quot; # ) # Pular linhas # dados &lt;- read_excel(here(&quot;data&quot;, &quot;raw&quot;, &quot;planilha.xlsx&quot;), skip = 3) # Ver nomes das planilhas # excel_sheets(here(&quot;data&quot;, &quot;raw&quot;, &quot;planilha.xlsx&quot;)) 9.1.3.5 Escrita de dados Por que exportar dados? Compartilhar resultados com colegas Backup de dados processados Usar em outras ferramentas (Excel, Power BI, Python) Guardar resultados intermedi√°rios de an√°lises longas Formatos e quando usar: CSV (write_csv, write_csv2): ‚úÖ Universal - abre em qualquer programa ‚úÖ Tamanho pequeno (texto simples) ‚ùå N√£o preserva formata√ß√£o ‚ùå Problemas com encoding Use para: compartilhar dados simples Excel (write_xlsx): ‚úÖ F√°cil para n√£o-programadores abrirem ‚úÖ Mant√©m formata√ß√£o b√°sica ‚ùå Tamanho maior que CSV Use para: relat√≥rios para stakeholders RDS (saveRDS, readRDS): ‚úÖ Preserva tipos de dados perfeitamente ‚úÖ Comprimido (tamanho pequeno) ‚úÖ R√°pido para ler/escrever ‚ùå S√≥ abre no R Use para: dados intermedi√°rios, objetos R complexos Dica: Sempre salve dados originais em data/raw/ e processados em data/processed/ 9.1.3.6 Organiza√ß√£o de Projetos com here() O problema dos caminhos: Caminho absoluto (‚ùå N√ÉO USAR): dados &lt;- read_csv(&quot;C:/Users/vinicius/Documents/projeto/data/dados.csv&quot;) Problema: S√≥ funciona no SEU computador! Caminho relativo com setwd() (‚ùå EVITAR): setwd(&quot;C:/Users/vinicius/Documents/projeto&quot;) dados &lt;- read_csv(&quot;data/dados.csv&quot;) Problema: Fr√°gil, n√£o funciona em scripts executados de outros lugares A solu√ß√£o: here() (‚úÖ SEMPRE USAR) dados &lt;- read_csv(here(&quot;data&quot;, &quot;dados.csv&quot;)) Vantagens do here(): ‚úÖ Funciona em Windows, Mac e Linux ‚úÖ Funciona independente de onde voc√™ executa o script ‚úÖ Colabora√ß√£o: c√≥digo funciona para todos ‚úÖ Raiz do projeto √© detectada automaticamente (.Rproj) Como funciona: here() encontra a raiz do projeto (onde est√° o .Rproj) Constr√≥i caminhos a partir dessa raiz Usa separadores corretos para cada sistema operacional Estrutura recomendada de projeto: meu-projeto/ ‚îú‚îÄ‚îÄ meu-projeto.Rproj ‚Üê here() usa isso como raiz ‚îú‚îÄ‚îÄ data/ ‚îÇ ‚îú‚îÄ‚îÄ raw/ ‚Üê Dados originais (NUNCA modificar!) ‚îÇ ‚îî‚îÄ‚îÄ processed/ ‚Üê Dados processados/limpos ‚îú‚îÄ‚îÄ scripts/ ‚Üê Scripts de an√°lise ‚îú‚îÄ‚îÄ output/ ‚îÇ ‚îú‚îÄ‚îÄ figures/ ‚Üê Gr√°ficos salvos ‚îÇ ‚îî‚îÄ‚îÄ tables/ ‚Üê Tabelas exportadas ‚îú‚îÄ‚îÄ docs/ ‚Üê Relat√≥rios e documenta√ß√£o ‚îî‚îÄ‚îÄ README.md ‚Üê Descri√ß√£o do projeto Boas pr√°ticas: Sempre use projetos .Rproj Sempre use here() para caminhos Nunca modifique dados em data/raw/ Documente estrutura no README.md # Criar dados de exemplo dados_exemplo &lt;- tibble( id = 1:5, nome = c(&quot;Ana&quot;, &quot;Bruno&quot;, &quot;Carla&quot;, &quot;Diego&quot;, &quot;Elena&quot;), nota = c(8.5, 7.0, 9.0, 6.5, 8.0) ) # Salvar como CSV (UTF-8) dir.create(here(&#39;output&#39;,&#39;tables&#39;), recursive = TRUE) # Cria todas as pastas write_csv(dados_exemplo, here(&quot;output&quot;, &quot;tables&quot;, &quot;notas.csv&quot;)) # Salvar como CSV com separador ponto-e-v√≠rgula write_csv2(dados_exemplo, here(&quot;output&quot;, &quot;tables&quot;, &quot;notas.csv&quot;)) # Salvar como Excel (requer writexl) library(writexl) write_xlsx(dados_exemplo, here(&quot;output&quot;, &quot;tables&quot;, &quot;notas.xlsx&quot;)) # Salvar como RDS (formato nativo R - preserva tipos) saveRDS(dados_exemplo, here(&quot;output&quot;, &quot;tables&quot;, &quot;notas.rds&quot;)) # Ler RDS dados &lt;- readRDS(here(&quot;output&quot;, &quot;tables&quot;, &quot;notas.rds&quot;)) 9.1.3.7 Organiza√ß√£o de Projetos com here() Por que usar here()? O pacote here resolve caminhos relativos de forma port√°vel, funcionando em qualquer sistema operacional e evitando problemas com diret√≥rios de trabalho. library(here) # Estrutura recomendada de projeto: # meu-projeto/ # ‚îú‚îÄ‚îÄ meu-projeto.Rproj # ‚îú‚îÄ‚îÄ data/ # ‚îÇ ‚îú‚îÄ‚îÄ raw/ # Dados originais (nunca modificar!) # ‚îÇ ‚îî‚îÄ‚îÄ processed/ # Dados processados # ‚îú‚îÄ‚îÄ scripts/ # Scripts R # ‚îú‚îÄ‚îÄ output/ # ‚îÇ ‚îú‚îÄ‚îÄ figures/ # Gr√°ficos # ‚îÇ ‚îî‚îÄ‚îÄ tables/ # Tabelas # ‚îú‚îÄ‚îÄ docs/ # Documenta√ß√£o e relat√≥rios # ‚îî‚îÄ‚îÄ README.md # Ver raiz do projeto here() # Construir caminhos port√°veis here(&quot;data&quot;, &quot;raw&quot;, &quot;dados.csv&quot;) here(&quot;output&quot;, &quot;figures&quot;, &quot;grafico1.png&quot;) here(&quot;scripts&quot;, &quot;01_analise.R&quot;) # Exemplo de uso completo dados &lt;- read_csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;vendas.csv&quot;)) # Criar o diret√≥rio se n√£o existir dir.create(here(&quot;data&quot;, &quot;raw&quot;), recursive = TRUE, showWarnings = FALSE) # Criar dados de vendas de exemplo set.seed(123) # Para reprodutibilidade # Primeiro criar a sequ√™ncia de datas datas &lt;- seq.Date(from = as.Date(&quot;2024-01-01&quot;), to = as.Date(&quot;2024-12-31&quot;), by = &quot;day&quot;) n_dias &lt;- length(datas) # 366 dias em 2024 vendas &lt;- tibble( data = datas, produto = sample(c(&quot;Produto A&quot;, &quot;Produto B&quot;, &quot;Produto C&quot;, &quot;Produto D&quot;), n_dias, replace = TRUE), regiao = sample(c(&quot;Norte&quot;, &quot;Sul&quot;, &quot;Leste&quot;, &quot;Oeste&quot;), n_dias, replace = TRUE), vendedor = sample(c(&quot;Jo√£o&quot;, &quot;Maria&quot;, &quot;Pedro&quot;, &quot;Jo√£o&quot;, &quot;Carlos&quot;), n_dias, replace = TRUE), quantidade = sample(1:50, n_dias, replace = TRUE), preco_unitario = round(runif(n_dias, min = 10, max = 500), 2), desconto_perc = sample(c(0, 5, 10, 15, 20), n_dias, replace = TRUE, prob = c(0.4, 0.3, 0.2, 0.05, 0.05)) ) %&gt;% mutate( valor_bruto = quantidade * preco_unitario, valor_desconto = valor_bruto * (desconto_perc / 100), valor_liquido = valor_bruto - valor_desconto ) # Visualizar primeiras linhas head(vendas) # Salvar o arquivo write_csv(vendas, here(&quot;data&quot;, &quot;raw&quot;, &quot;vendas.csv&quot;)) # Confirmar que foi salvo cat(&quot;Arquivo salvo em:&quot;, here(&quot;data&quot;, &quot;raw&quot;, &quot;vendas.csv&quot;), &quot;\\n&quot;) # Filtrar dados dados_processados &lt;- vendas %&gt;% filter(vendedor == &#39;Jo√£o&#39;) %&gt;% mutate(vendas_milhares = quantidade / 1000) dir.create(here(&#39;data&#39;,&#39;processed&#39;), recursive = TRUE) write_csv(dados_processados, here(&quot;data&quot;, &quot;processed&quot;, &quot;vendas_2024.csv&quot;)) 9.1.4 Ferramentas √öteis 9.1.4.1 janitor: Limpeza de dados O que √© janitor? janitor √© um pacote focado em limpar dados bagun√ßados - especialmente aqueles que v√™m de planilhas Excel criadas por humanos (n√£o por programas). Problemas comuns que janitor resolve: Nomes de colunas com espa√ßos, acentos, caracteres especiais Linhas e colunas completamente vazias Linhas duplicadas Formata√ß√£o inconsistente Principais fun√ß√µes: 1. clean_names(): Limpa nomes de colunas automaticamente Remove espa√ßos ‚Üí substitui por _ Remove acentos e caracteres especiais Converte tudo para min√∫sculas Formato snake_case Use sempre que importar dados de Excel! 2. tabyl(): Tabelas de frequ√™ncia melhoradas Mais informativa que table() do R base Funciona bem com pipes F√°cil adicionar percentuais e totais 3. adorn_*: Fun√ß√µes para embelezar tabelas adorn_percentages(): adiciona percentuais adorn_pct_formatting(): formata percentuais adorn_ns(): mostra contagens junto com percentuais adorn_totals(): adiciona linha/coluna de totais 4. remove_empty(): Remove linhas/colunas vazias Comum em dados de Excel com c√©lulas vazias fantasmas remove_empty(\"rows\"): remove linhas vazias remove_empty(\"cols\"): remove colunas vazias remove_empty(c(\"rows\", \"cols\")): remove ambos 5. get_dupes(): Encontra linhas duplicadas Mostra quais linhas est√£o duplicadas Mais informativo que duplicated() 9.1.4.2 skimr: Explora√ß√£o r√°pida O que √© skimr? skimr fornece resumos estat√≠sticos completos de forma r√°pida e visual - muito melhor que summary() do R base. Vantagens do skim(): ‚úÖ Um resumo por tipo de vari√°vel (num√©rico, texto, data, etc.) ‚úÖ Mostra quantidade de dados ausentes ‚úÖ Histogramas inline (mini-histogramas na tabela!) ‚úÖ Estat√≠sticas relevantes automaticamente ‚úÖ Funciona com group_by() para resumos por grupo ‚úÖ Output limpo e organizado O que skim() mostra: Para vari√°veis num√©ricas: n_missing: quantos NAs complete_rate: % de valores completos mean, sd: m√©dia e desvio padr√£o p0, p25, p50, p75, p100: percentis (min, Q1, mediana, Q3, max) hist: mini-histograma visual! Para vari√°veis de texto: n_missing, complete_rate min, max: comprimento m√≠nimo/m√°ximo empty: quantas strings vazias n_unique: quantos valores √∫nicos Para vari√°veis l√≥gicas: mean: propor√ß√£o de TRUEs count: contagem de TRUE/FALSE Uso t√≠pico: # Explora√ß√£o inicial r√°pida dados %&gt;% skim() # Por grupo dados %&gt;% group_by(categoria) %&gt;% skim() # Apenas num√©ricos dados %&gt;% skim() %&gt;% filter(skim_type == &quot;numeric&quot;) Quando usar: Primeira explora√ß√£o de um dataset novo Checagem r√°pida de qualidade dos dados Identifica√ß√£o de outliers e problemas Documenta√ß√£o de caracter√≠sticas dos dados library(janitor) # Dados bagun√ßados (comum em planilhas) dados_sujos &lt;- tibble( `Nome Completo` = c(&quot;Ana Silva&quot;, &quot;Bruno Costa&quot;), `Idade (anos)` = c(25, 30), `Sal√°rio Mensal (R$)` = c(5000, 6000), `E-mail!!!` = c(&quot;ana@email.com&quot;, &quot;bruno@email.com&quot;) ) dados_sujos # Limpar nomes de colunas automaticamente dados_limpos &lt;- dados_sujos %&gt;% clean_names() dados_limpos names(dados_limpos) # Tabula√ß√£o cruzada melhorada penguins %&gt;% tabyl(species, island) %&gt;% adorn_percentages(&quot;row&quot;) %&gt;% adorn_pct_formatting() %&gt;% adorn_ns() # Remover linhas/colunas completamente vazias dados_com_vazios &lt;- tibble( a = c(1, 2, NA, 4), b = c(NA, NA, NA, NA), # Coluna vazia c = c(5, 6, 7, 8) ) dados_com_vazios %&gt;% remove_empty(c(&quot;rows&quot;, &quot;cols&quot;)) 9.1.4.3 skimr: Explora√ß√£o r√°pida library(skimr) # Resumo estat√≠stico completo penguins %&gt;% skim() # Por grupo penguins %&gt;% group_by(species) %&gt;% skim() # Customizar sa√≠da penguins %&gt;% skim() %&gt;% filter(skim_type == &quot;numeric&quot;) %&gt;% select(skim_variable, n_missing, numeric.mean, numeric.sd) 9.2 INTERVALO (20h30 - 20h50) Aproveite para: Revisar conceitos de transforma√ß√£o Experimentar com seus dados Preparar para ggplot2! 9.3 Visualiza√ß√£o com ggplot2 (20h50 - 22h00) 9.3.1 Gram√°tica de Gr√°ficos 9.3.1.1 O que √© ggplot2? ggplot2 √© um sistema de visualiza√ß√£o baseado na ‚ÄúGrammar of Graphics‚Äù (Gram√°tica de Gr√°ficos) - uma filosofia que trata gr√°ficos como senten√ßas constru√≠das por camadas. Por que ggplot2 √© revolucion√°rio? Voc√™ descreve o que quer ver, n√£o como desenhar Gr√°ficos complexos s√£o combina√ß√µes de camadas simples Consist√™ncia: mesma l√≥gica para todos os tipos de gr√°ficos Flexibilidade: f√°cil personalizar qualquer aspecto Analogia: √â como escrever uma frase: Sujeito (data): seus dados Verbo (geom): o que mostrar (pontos, linhas, barras) Adv√©rbios (aes): como mapear vari√°veis (x, y, cor, tamanho) Adjetivos (themes, scales): apar√™ncia e estilo 9.3.1.2 Componentes essenciais: 1. Data (dados): O dataset que voc√™ quer visualizar ggplot(data = penguins) # Apenas especifica os dados 2. Aesthetics (aes): Mapeamento de vari√°veis para propriedades visuais x, y: posi√ß√£o nos eixos color: cor de pontos/linhas fill: cor de preenchimento size: tamanho shape: forma (c√≠rculo, tri√¢ngulo, etc.) alpha: transpar√™ncia (0 = invis√≠vel, 1 = opaco) linetype: tipo de linha (s√≥lida, tracejada, etc.) # Exemplo de aesthetics aes(x = flipper_length_mm, # eixo x y = body_mass_g, # eixo y color = species, # cor por esp√©cie size = bill_length_mm) # tamanho por comprimento do bico 3. Geometries (geom): Tipo de representa√ß√£o visual geom_point(): pontos (gr√°fico de dispers√£o) geom_line(): linhas geom_bar(): barras geom_boxplot(): boxplots geom_histogram(): histogramas E muitos outros‚Ä¶ 4. Scales: Controle fino de como os dados s√£o mapeados scale_x_continuous(): escala do eixo x scale_color_manual(): cores personalizadas scale_y_log10(): escala logar√≠tmica 5. Themes: Apar√™ncia geral (n√£o afeta os dados) theme_minimal(): minimalista theme_bw(): preto e branco theme_classic(): cl√°ssico theme(): personaliza√ß√£o completa 9.3.1.3 A l√≥gica do + (soma de camadas) Em ggplot2, voc√™ adiciona camadas com +: ggplot(data = dados, aes(x = var1, y = var2)) + # Base geom_point() + # Camada 1: pontos geom_smooth() + # Camada 2: linha de tend√™ncia labs(title = &quot;Meu gr√°fico&quot;) + # Camada 3: t√≠tulos theme_minimal() # Camada 4: tema Importante: Use + no final da linha, n√£o no in√≠cio! 9.3.1.4 Aesthetics globais vs locais Global (no ggplot()): aplica-se a todas as camadas ggplot(dados, aes(x = var1, y = var2, color = grupo)) + geom_point() + # Usa cor geom_smooth() # Tamb√©m usa cor Local (dentro do geom_*()): aplica-se apenas √†quela camada ggplot(dados, aes(x = var1, y = var2)) + geom_point(aes(color = grupo)) + # Apenas pontos coloridos geom_smooth() # Linha sem cor library(ggplot2) # Estrutura b√°sica # ggplot(data = dados, aes(x = var1, y = var2)) + # geom_point() # Exemplo com palmerpenguins ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() # Adicionar cor por esp√©cie ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) + geom_point() # Adicionar forma por ilha ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species, shape = island)) + geom_point(size = 3, alpha = 0.7) 9.3.2 Tipos de Gr√°ficos (geoms) 9.3.2.1 Escolhendo o tipo certo de gr√°fico Pergunte-se: Quantas vari√°veis quero mostrar? (1, 2, 3+) Que tipo de vari√°veis? (categ√≥rica vs num√©rica) Qual hist√≥ria quero contar? (distribui√ß√£o, rela√ß√£o, compara√ß√£o, evolu√ß√£o) Guia r√°pido: Rela√ß√£o entre 2 num√©ricas ‚Üí Dispers√£o (geom_point) Comparar categorias ‚Üí Barras (geom_bar/geom_col) Distribui√ß√£o de 1 num√©rica ‚Üí Histograma ou Densidade Comparar distribui√ß√µes ‚Üí Boxplot ou Violin Evolu√ß√£o temporal ‚Üí Linhas (geom_line) Parte do todo ‚Üí Pizza (evite!) ou Barras empilhadas 9.3.2.2 Gr√°fico de Dispers√£o (geom_point) Quando usar: Mostrar rela√ß√£o entre duas vari√°veis num√©ricas Identificar correla√ß√µes, tend√™ncias ou padr√µes Visualizar clusters ou outliers Par√¢metros √∫teis: size: tamanho dos pontos (n√∫mero ou mapeado a vari√°vel) alpha: transpar√™ncia (√∫til quando h√° sobreposi√ß√£o) shape: forma dos pontos (c√≠rculo, tri√¢ngulo, quadrado, etc.) color: cor (fixa ou mapeada a vari√°vel categ√≥rica) Dica: Use geom_smooth() junto para adicionar linha de tend√™ncia! Tipos de rela√ß√£o que voc√™ pode identificar: Positiva: x aumenta, y aumenta Negativa: x aumenta, y diminui N√£o-linear: curva ou padr√£o complexo Sem rela√ß√£o: pontos dispersos aleatoriamente # Dispers√£o b√°sica ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + geom_point() # Com cores e tamanhos ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species, size = bill_length_mm)) + geom_point(alpha = 0.6) # Adicionar linha de tend√™ncia ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + geom_point(aes(color = species), alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = TRUE) 9.3.2.3 Gr√°fico de Barras (geom_bar / geom_col) Diferen√ßa importante: geom_bar(): conta automaticamente (para dados brutos) Use quando: quer contar quantas vezes cada categoria aparece Exemplo: quantos alunos de cada curso geom_col(): usa valores que j√° est√£o calculados Use quando: j√° tem os valores agregados Exemplo: vendas totais por m√™s (j√° somadas) Quando usar barras: Comparar quantidades entre categorias Mostrar rankings Visualizar composi√ß√£o (barras empilhadas) Dados temporais discretos (meses, anos) Par√¢metros importantes: position: Como organizar m√∫ltiplas barras \"stack\" (padr√£o): empilhadas uma sobre a outra \"dodge\": lado a lado \"fill\": empilhadas proporcionalmente (100%) width: Largura das barras (0-1) Menor = barras mais finas com mais espa√ßo fill vs color: fill: cor de preenchimento da barra color: cor da borda da barra Dicas de design: Ordene categorias por valor (n√£o alfabeticamente) Use cores apenas quando necess√°rio (n√£o decore por decorar) Evite 3D (distorce percep√ß√£o) Comece eixo y em zero (n√£o engane visualmente) Considere barras horizontais se nomes de categorias forem longos # Contagem (geom_bar) ggplot(penguins, aes(x = species)) + geom_bar() # Com preenchimento por outra vari√°vel ggplot(penguins, aes(x = species, fill = island)) + geom_bar() # Barras lado a lado ggplot(penguins, aes(x = species, fill = island)) + geom_bar(position = &quot;dodge&quot;) # Propor√ß√£o (100%) ggplot(penguins, aes(x = species, fill = island)) + geom_bar(position = &quot;fill&quot;) + labs(y = &quot;Propor√ß√£o&quot;) # Barras horizontais ggplot(penguins, aes(y = species)) + geom_bar() # geom_col (quando voc√™ tem valores agregados) resumo &lt;- penguins %&gt;% group_by(species) %&gt;% summarize(massa_media = mean(body_mass_g, na.rm = TRUE)) ggplot(resumo, aes(x = species, y = massa_media)) + geom_col(fill = &quot;steelblue&quot;) 9.3.2.4 Boxplot (geom_boxplot) O que √© um boxplot? Um boxplot (ou diagrama de caixa) mostra a distribui√ß√£o de dados atrav√©s de quartis. √â uma forma compacta de ver: - A mediana (linha central) - A dispers√£o (tamanho da caixa) - Outliers (pontos isolados) Anatomia do boxplot: m√°ximo (ou Q3 + 1.5*IQR) ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Q3 ‚îÇ ‚Üê 75% dos dados est√£o abaixo ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ ‚Üê mediana (Q2) ‚îÇ Q1 ‚îÇ ‚Üê 25% dos dados est√£o abaixo ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò ‚îÇ m√≠nimo (ou Q1 - 1.5*IQR) ‚óè ‚Üê outliers (pontos fora do padr√£o) Quando usar: Comparar distribui√ß√µes entre grupos Identificar outliers Ver simetria/assimetria dos dados Quando tem muitas categorias (mais eficiente que m√∫ltiplos histogramas) Vantagens: Mostra 5 estat√≠sticas de uma vez (min, Q1, mediana, Q3, max) Identifica outliers automaticamente Compacto - f√°cil comparar muitos grupos Desvantagens: N√£o mostra a forma exata da distribui√ß√£o Pode esconder bimodalidade (duas ‚Äúmontanhas‚Äù) Menos intuitivo para p√∫blico n√£o-t√©cnico Alternativas: Violin plot (geom_violin): mostra a forma completa da distribui√ß√£o Jitter plot (geom_jitter): mostra todos os pontos individuais Combina√ß√£o: boxplot + jitter = melhor dos dois mundos Dicas: Use geom_jitter() junto para mostrar pontos individuais Ordene grupos por mediana para facilitar compara√ß√£o Use cores para distinguir grupos, mas n√£o exagere # Boxplot b√°sico ggplot(penguins, aes(x = species, y = body_mass_g)) + geom_boxplot() # Com cores ggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) + geom_boxplot() # Adicionar pontos individuais ggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) + geom_boxplot(alpha = 0.7) + geom_jitter(width = 0.2, alpha = 0.3, size = 1) # Violin plot (alternativa) ggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) + geom_violin() 9.3.2.5 Gr√°fico de Linhas (geom_line) Quando usar: Dados temporais (s√©ries temporais) Mostrar tend√™ncias ou evolu√ß√£o Dados com ordem natural (temperatura ao longo do dia) Conectar pontos sequenciais CUIDADO: N√£o use linhas para: Dados categ√≥ricos sem ordem (esp√©cies, nomes) Quando n√£o h√° continuidade entre pontos Por que usar linhas em vez de barras para s√©ries temporais? Linhas enfatizam tend√™ncia e fluxo Mais f√°cil ver mudan√ßas ao longo do tempo Menos ‚Äúpeso visual‚Äù quando h√° muitos pontos Facilita compara√ß√£o de m√∫ltiplas s√©ries Par√¢metros √∫teis: size: espessura da linha linetype: tipo de linha (s√≥lida, tracejada, pontilhada) color: cor da linha group: quando tem m√∫ltiplas linhas Dica: Combine geom_line() + geom_point() para destacar valores individuais 9.3.2.6 Histograma e Densidade (geom_histogram / geom_density) Histograma (geom_histogram) O que mostra: A distribui√ß√£o de uma vari√°vel num√©rica dividida em ‚Äúbins‚Äù (intervalos). Quando usar: Entender a forma da distribui√ß√£o (sim√©trica, assim√©trica, bimodal) Identificar moda (valor mais frequente) Ver dispers√£o dos dados Detectar outliers Par√¢metro cr√≠tico: bins (ou binwidth) bins: n√∫mero de barras (padr√£o = 30) binwidth: largura de cada barra Importante: N√∫mero de bins muda a interpreta√ß√£o! Poucos bins ‚Üí padr√µes grosseiros, perde detalhes Muitos bins ‚Üí muito detalhado, dif√≠cil ver padr√£o geral Teste diferentes valores! Tipos de distribui√ß√£o que voc√™ pode identificar: Normal (sino): sim√©trica, maioria no centro Assim√©trica positiva: cauda longa √† direita Assim√©trica negativa: cauda longa √† esquerda Bimodal: duas ‚Äúmontanhas‚Äù (dois grupos distintos) Uniforme: todas as barras similares (raro em dados reais) Densidade (geom_density) O que mostra: Uma vers√£o ‚Äúsuavizada‚Äù do histograma - uma curva cont√≠nua. Vantagens sobre histograma: N√£o depende de escolha arbitr√°ria de bins Mais suave e f√°cil de interpretar Melhor para comparar m√∫ltiplas distribui√ß√µes sobrepostas Mais ‚Äúbonito‚Äù visualmente Desvantagens: Pode ser menos intuitivo para p√∫blico n√£o-t√©cnico Pode suavizar demais e esconder detalhes Quando usar cada um: Histograma: primeira explora√ß√£o, apresenta√ß√£o para n√£o-t√©cnicos Densidade: comparar grupos, an√°lise mais refinada, publica√ß√µes Dica: Use alpha (transpar√™ncia) quando sobrepor m√∫ltiplas distribui√ß√µes! # Criar dados temporais vendas_tempo &lt;- tibble( mes = 1:12, vendas = c(100, 120, 150, 140, 170, 190, 200, 210, 195, 220, 240, 250), custos = c(80, 90, 100, 95, 110, 120, 125, 130, 120, 135, 145, 150) ) # Linha simples ggplot(vendas_tempo, aes(x = mes, y = vendas)) + geom_line() # Com pontos ggplot(vendas_tempo, aes(x = mes, y = vendas)) + geom_line(color = &quot;blue&quot;, size = 1) + geom_point(color = &quot;blue&quot;, size = 3) # M√∫ltiplas linhas (precisa pivotear) vendas_long &lt;- vendas_tempo %&gt;% pivot_longer(cols = c(vendas, custos), names_to = &quot;tipo&quot;, values_to = &quot;valor&quot;) ggplot(vendas_long, aes(x = mes, y = valor, color = tipo)) + geom_line(size = 1) + geom_point(size = 2) 9.3.2.7 Histograma e Densidade (geom_histogram / geom_density) # Histograma ggplot(penguins, aes(x = body_mass_g)) + geom_histogram(bins = 30, fill = &quot;steelblue&quot;, color = &quot;white&quot;) # Ajustar n√∫mero de bins ggplot(penguins, aes(x = body_mass_g)) + geom_histogram(bins = 15, fill = &quot;steelblue&quot;, alpha = 0.7) # Por grupo ggplot(penguins, aes(x = body_mass_g, fill = species)) + geom_histogram(bins = 30, alpha = 0.6, position = &quot;identity&quot;) # Densidade ggplot(penguins, aes(x = body_mass_g)) + geom_density(fill = &quot;steelblue&quot;, alpha = 0.5) # Densidade por grupo ggplot(penguins, aes(x = body_mass_g, fill = species)) + geom_density(alpha = 0.5) 9.4 Personaliza√ß√£o 9.4.1 Labels (labs) - Comunicando claramente Por que labels s√£o importantes? Um gr√°fico sem bons labels √© como um livro sem capa - ningu√©m sabe do que se trata! Labels transformam um gr√°fico t√©cnico em uma ferramenta de comunica√ß√£o. Elementos de labs(): title: T√≠tulo principal - O QUE o gr√°fico mostra Seja descritivo: ‚ÄúRela√ß√£o entre‚Ä¶‚Äù n√£o apenas ‚ÄúGr√°fico 1‚Äù M√°ximo 1-2 linhas subtitle: Subt√≠tulo - Contexto adicional ou detalhes Informa√ß√£o complementar sobre per√≠odo, amostra, etc. x / y: R√≥tulos dos eixos - SEMPRE inclua unidades! ‚ùå ‚ÄúMassa‚Äù ‚úÖ ‚ÄúMassa Corporal (g)‚Äù color / fill / size / etc.: Legendas Renomeie para termos claros: ‚ÄúEsp√©cie‚Äù em vez de ‚Äúspecies‚Äù caption: Nota de rodap√© - Fonte dos dados, cr√©ditos Exemplo: ‚ÄúFonte: Palmer Archipelago LTER‚Äù Regra de ouro: Seu gr√°fico deve se explicar sozinho. Uma pessoa que nunca viu seus dados deveria entender o que est√° sendo mostrado apenas olhando o gr√°fico. 9.4.2 Temas (themes) - Definindo a apar√™ncia O que s√£o temas? Temas controlam a apar√™ncia n√£o-dados do gr√°fico: cor de fundo, linhas de grade, fontes, etc. N√£o afetam os dados em si, apenas como s√£o apresentados. Temas prontos (built-in): theme_gray() (padr√£o): fundo cinza, grade branca Uso: padr√£o, nada especial theme_bw(): preto e branco, fundo branco Uso: impress√£o P&amp;B, publica√ß√µes acad√™micas theme_minimal(): minimalista, sem bordas Uso: apresenta√ß√µes modernas, relat√≥rios limpos Recomendado para iniciantes! theme_classic(): eixos simples, sem grades Uso: estilo cl√°ssico, gr√°ficos ‚Äúcient√≠ficos‚Äù theme_dark(): fundo escuro Uso: apresenta√ß√µes em projetores, dashboards theme_void(): completamente limpo Uso: mapas, visualiza√ß√µes art√≠sticas Como personalizar temas? Use theme() para ajustar elementos espec√≠ficos: theme( plot.title = element_text(size = 16, face = &quot;bold&quot;), axis.text = element_text(size = 12), legend.position = &quot;bottom&quot;, panel.grid.minor = element_blank() # Remove grade secund√°ria ) Elementos ajust√°veis: element_text(): texto (t√≠tulo, eixos, legendas) element_line(): linhas (eixos, grades) element_rect(): ret√¢ngulos (fundo, bordas) element_blank(): remove o elemento Dica: Combine tema pronto + ajustes finos: theme_minimal() + theme(legend.position = &quot;bottom&quot;) 9.4.3 Escalas (scales) - Controle fino O que s√£o scales? Scales controlam como os dados s√£o mapeados para propriedades visuais. Toda aesthetic (x, y, color, size, etc.) tem uma scale. Por que ajustar scales? Cores mais bonitas ou acess√≠veis Eixos com quebras espec√≠ficas Transforma√ß√µes (log, sqrt) Formata√ß√£o de valores (moeda, percentual) Tipos principais: 1. Scales de posi√ß√£o (eixos x e y) # Controlar quebras e limites scale_y_continuous( breaks = seq(0, 100, 10), # Onde mostrar marcas limits = c(0, 100), # Limite do eixo expand = c(0, 0) # Remover espa√ßo extra ) # Transforma√ß√µes scale_y_log10() # Escala logar√≠tmica scale_x_sqrt() # Raiz quadrada scale_x_reverse() # Inverter eixo 2. Scales de cor # Cores manuais scale_color_manual(values = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) # Paletas viridis (acess√≠veis para dalt√¥nicos!) scale_color_viridis_d() # Discreta (categ√≥rica) scale_color_viridis_c() # Cont√≠nua (num√©rica) # Paletas Brewer scale_color_brewer(palette = &quot;Set1&quot;) 3. Formata√ß√£o com scales (pacote) library(scales) # Formatar n√∫meros scale_y_continuous(labels = label_comma()) # 1,000 scale_y_continuous(labels = label_percent()) # 50% scale_y_continuous(labels = label_dollar()) # $100 scale_y_continuous(labels = label_number( prefix = &quot;R$ &quot;, decimal.mark = &quot;,&quot;, big.mark = &quot;.&quot; )) # R$ 1.000,00 Cores para dalt√¥nicos: Use paletas acess√≠veis! ~8% dos homens t√™m daltonismo. ‚úÖ Boas escolhas: - scale_color_viridis_d() (melhor!) - scale_color_brewer(palette = \"Set2\") - Esquemas azul-laranja (distingu√≠veis) ‚ùå Evite: - Vermelho-verde (indistingu√≠veis para dalt√¥nicos) - Muitas cores similares ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) + geom_point() + labs( title = &quot;Rela√ß√£o entre Nadadeira e Massa Corporal&quot;, subtitle = &quot;Dados do Arquip√©lago Palmer, Ant√°rtica&quot;, x = &quot;Comprimento da Nadadeira (mm)&quot;, y = &quot;Massa Corporal (g)&quot;, color = &quot;Esp√©cie&quot;, caption = &quot;Fonte: palmerpenguins package&quot; ) 9.4.4 Temas (themes) grafico_base &lt;- ggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) + geom_boxplot() + labs(title = &quot;Massa Corporal por Esp√©cie&quot;) # Tema padr√£o (gray) grafico_base # Tema minimalista grafico_base + theme_minimal() # Tema BW grafico_base + theme_bw() # Tema cl√°ssico grafico_base + theme_classic() # Tema escuro grafico_base + theme_dark() # Customizar tema grafico_base + theme_minimal() + theme( plot.title = element_text(size = 16, face = &quot;bold&quot;), axis.text = element_text(size = 12), legend.position = &quot;bottom&quot; ) 9.4.5 Escalas (scales) library(scales) # Escala de cores manual ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) + geom_point() + scale_color_manual(values = c(&quot;darkorange&quot;, &quot;purple&quot;, &quot;cyan4&quot;)) # Escala de cores viridis (acess√≠vel e bonita) ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) + geom_point() + scale_color_viridis_d() # Escala de eixo ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + geom_point() + scale_y_continuous( labels = label_comma(), # Formatar n√∫meros com v√≠rgula breaks = seq(3000, 6000, 500) ) # Transforma√ß√£o logar√≠tmica ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + geom_point() + scale_y_log10() 9.5 Combinando Gr√°ficos (patchwork) Por que combinar gr√°ficos? Muitas vezes voc√™ quer mostrar m√∫ltiplas visualiza√ß√µes relacionadas lado a lado: Comparar diferentes aspectos dos mesmos dados Mostrar ‚Äúantes e depois‚Äù Pain√©is para relat√≥rios e apresenta√ß√µes Contar uma hist√≥ria visual completa patchwork vs alternativas: Base R (par(mfrow), layout): complexo, limitado gridExtra (grid.arrange): funcional mas verboso patchwork: simples, intuitivo, poderoso ‚úÖ Sintaxe b√°sica de patchwork: # + : lado a lado (horizontal) grafico1 + grafico2 # / : um em cima do outro (vertical) grafico1 / grafico2 # Combinar: () agrupa opera√ß√µes (grafico1 + grafico2) / grafico3 Operadores: - + : lado a lado - / : empilhar - | : lado a lado (alternativa ao +) - () : agrupar Layouts complexos: # 2x2 (g1 + g2) / (g3 + g4) # L-shape g1 + (g2 / g3) # Tamanhos diferentes g1 + g2 + plot_layout(widths = c(2, 1)) # g1 √© 2x mais largo Funcionalidades √∫teis: 1. plot_annotation(): Adicionar t√≠tulo geral e caption (g1 + g2) / (g3 + g4) + plot_annotation( title = &quot;An√°lise Completa&quot;, subtitle = &quot;Dados de 2024&quot;, caption = &quot;Fonte: MinhaFonte&quot;, tag_levels = &quot;A&quot; # Adiciona A, B, C, D... ) 2. plot_layout(): Controlar layout g1 + g2 + g3 + plot_layout( ncol = 2, # N√∫mero de colunas guides = &quot;collect&quot;, # Coletar legendas widths = c(2, 1, 1), # Larguras relativas heights = c(1, 2) # Alturas relativas ) 3. Legendas unificadas: (g1 + g2) / (g3 + g4) + plot_layout(guides = &quot;collect&quot;) &amp; # &amp; aplica a todos theme(legend.position = &quot;bottom&quot;) Dicas de design: Mantenha escalas consistentes entre gr√°ficos relacionados Use cores consistentes para mesmas categorias N√£o sobrecarregue - m√°ximo 4-6 pain√©is Considere se um √∫nico gr√°fico com facetas seria melhor 9.6 Salvando Gr√°ficos (ggsave) Por que usar ggsave? Voc√™ precisa salvar gr√°ficos para: Incluir em relat√≥rios, artigos, apresenta√ß√µes Compartilhar com colegas Backup de visualiza√ß√µes importantes Usar em outros softwares ggsave() √© inteligente: Detecta formato pela extens√£o (.png, .pdf, .jpg, etc.) Ajusta resolu√ß√£o automaticamente Salva o √∫ltimo gr√°fico por padr√£o (ou voc√™ especifica) Funciona perfeitamente com here() Sintaxe b√°sica: ggsave( filename = &quot;meu_grafico.png&quot;, # Nome e formato plot = meu_grafico, # Qual gr√°fico (opcional) width = 8, # Largura em polegadas height = 6, # Altura em polegadas dpi = 300 # Resolu√ß√£o (pontos por polegada) ) Formatos e quando usar: 1. PNG (.png) Raster (pixels) ‚úÖ Bom para: web, apresenta√ß√µes, compartilhamento r√°pido ‚úÖ Suporta transpar√™ncia ‚úÖ Tamanho razo√°vel com boa qualidade ‚ùå Perde qualidade ao ampliar muito DPI recomendado: 300 (alta qualidade), 150 (web) 2. PDF (.pdf) Vetor (matem√°tico) ‚úÖ Bom para: publica√ß√µes acad√™micas, impress√£o profissional ‚úÖ Escala infinitamente sem perder qualidade ‚úÖ Tamanho pequeno para gr√°ficos simples ‚ùå Pode ser grande com muitos pontos Sem DPI (vetor n√£o tem pixels) 3. SVG (.svg) Vetor (para web) ‚úÖ Bom para: web, design, edit√°vel em Illustrator ‚úÖ Escala perfeitamente ‚úÖ Pode ser editado como c√≥digo ‚ùå Suporte limitado em alguns contextos Sem DPI (vetor) 4. JPEG (.jpg) Raster (pixels) ‚úÖ Tamanho muito pequeno ‚ùå Perde qualidade (compress√£o) ‚ùå N√£o suporta transpar√™ncia Evite para gr√°ficos! (Use PNG) 5. TIFF (.tiff) Raster (pixels) ‚úÖ Alta qualidade sem compress√£o ‚úÖ Aceito em publica√ß√µes ‚ùå Arquivos muito grandes Use apenas se exigido Configura√ß√µes importantes: DPI (Dots Per Inch) - resolu√ß√£o: 72 dpi: tela de computador (baixa qualidade) 150 dpi: apresenta√ß√µes, web (qualidade m√©dia) 300 dpi: impress√£o, publica√ß√µes (alta qualidade) ‚úÖ 600 dpi: impress√£o profissional (raramente necess√°rio) Tamanho (width e height): Padr√£o: polegadas (inches) 1 polegada = 2.54 cm Tamanhos comuns: Apresenta√ß√£o slide: 10 x 7.5 polegadas (16:9) Artigo coluna √∫nica: 3.5 x 3.5 polegadas Artigo largura total: 7 x 5 polegadas Poster: 24 x 18 polegadas Boas pr√°ticas: # Use here() para portabilidade ggsave( here(&quot;output&quot;, &quot;figures&quot;, &quot;massa_especies.png&quot;), width = 8, height = 6, dpi = 300, bg = &quot;white&quot; # Fundo branco (√∫til com temas transparentes) ) # Salvar em m√∫ltiplos formatos for (fmt in c(&quot;png&quot;, &quot;pdf&quot;, &quot;svg&quot;)) { ggsave( here(&quot;output&quot;, &quot;figures&quot;, paste0(&quot;grafico.&quot;, fmt)), plot = meu_grafico, width = 8, height = 6, dpi = 300 ) } Resolu√ß√£o de problemas: Texto muito pequeno/grande: Ajuste width e height (n√£o dpi) Ou ajuste tamanhos de fonte no gr√°fico antes de salvar Arquivo muito grande: PNG: reduza DPI para 150 PDF com muitos pontos: converta para PNG Simplifique o gr√°fico (menos pontos, objetos) Cores diferentes do RStudio: Especifique bg = \"white\" (ou cor de fundo desejada) Alguns temas t√™m fundo transparente por padr√£o Eixos cortados: Adicione scale_y_continuous(expand = expansion(mult = 0.05)) Ou ajuste margens: theme(plot.margin = margin(1, 1, 1, 1, \"cm\")) library(patchwork) # Criar v√°rios gr√°ficos g1 &lt;- ggplot(penguins, aes(x = species, fill = species)) + geom_bar() + labs(title = &quot;Contagem por Esp√©cie&quot;) + theme_minimal() g2 &lt;- ggplot(penguins, aes(x = body_mass_g, fill = species)) + geom_density(alpha = 0.5) + labs(title = &quot;Distribui√ß√£o de Massa&quot;) + theme_minimal() g3 &lt;- ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) + geom_point() + labs(title = &quot;Nadadeira vs Massa&quot;) + theme_minimal() g4 &lt;- ggplot(penguins, aes(x = species, y = bill_length_mm, fill = species)) + geom_boxplot() + labs(title = &quot;Bico por Esp√©cie&quot;) + theme_minimal() # Combinar lado a lado g1 + g2 # Combinar em cima/embaixo g1 / g2 # Layout complexo (g1 + g2) / (g3 + g4) # Com t√≠tulo geral (g1 + g2) / (g3 + g4) + plot_annotation( title = &quot;An√°lise Explorat√≥ria de Pinguins&quot;, subtitle = &quot;Palmer Archipelago, Antarctica&quot;, caption = &quot;Dados: palmerpenguins&quot; ) # Coletar legendas (g1 + g2) / (g3 + g4) + plot_layout(guides = &quot;collect&quot;) &amp; theme(legend.position = &quot;bottom&quot;) # Criar gr√°fico meu_grafico &lt;- ggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) + geom_boxplot() + labs( title = &quot;Massa Corporal por Esp√©cie de Pinguim&quot;, x = &quot;Esp√©cie&quot;, y = &quot;Massa Corporal (g)&quot; ) + theme_minimal() + theme(legend.position = &quot;none&quot;) # Salvar como PNG # ggsave( # filename = here(&quot;output&quot;, &quot;figures&quot;, &quot;massa_especies.png&quot;), # plot = meu_grafico, # width = 8, # height = 6, # dpi = 300 # ) # Salvar como PDF (vetorial) # ggsave( # filename = here(&quot;output&quot;, &quot;figures&quot;, &quot;massa_especies.pdf&quot;), # plot = meu_grafico, # width = 8, # height = 6 # ) # Salvar √∫ltimo gr√°fico criado # ggsave(here(&quot;output&quot;, &quot;figures&quot;, &quot;ultimo_grafico.png&quot;), dpi = 300) # Diferentes formatos # ggsave(&quot;grafico.png&quot;) # PNG # ggsave(&quot;grafico.pdf&quot;) # PDF # ggsave(&quot;grafico.svg&quot;) # SVG (escal√°vel) # ggsave(&quot;grafico.jpg&quot;) # JPEG 9.7 Exerc√≠cios Pr√°ticos 9.7.1 Exerc√≠cio 1: Transforma√ß√£o de dados # Dados de temperatura (wide) temp_wide &lt;- tibble( cidade = c(&quot;S√£o Paulo&quot;, &quot;Rio de Janeiro&quot;, &quot;Belo Horizonte&quot;), jan = c(25, 28, 24), fev = c(26, 29, 25), mar = c(24, 27, 23), abr = c(22, 25, 21) ) # a) Transforme para formato long # b) Calcule temperatura m√©dia por cidade # c) Qual cidade teve maior varia√ß√£o? # d) Crie gr√°fico de linhas mostrando temperatura ao longo dos meses 9.7.2 Exerc√≠cio 2: Limpeza e I/O # a) Crie um dataset com nomes de colunas bagun√ßados e limpe com janitor # b) Adicione algumas linhas com NA e trate-os adequadamente # c) Salve o dataset limpo como CSV usando here() # d) Leia o arquivo de volta e confirme que est√° correto 9.7.3 Exerc√≠cio 3: Visualiza√ß√£o completa # Use o dataset penguins para criar: # a) Um gr√°fico de dispers√£o relacionando duas vari√°veis num√©ricas # b) Um boxplot comparando esp√©cies # c) Um histograma da distribui√ß√£o de massa corporal # d) Combine os 3 gr√°ficos usando patchwork # e) Personalize com temas, cores e labels apropriados # f) Salve o resultado final com ggsave() 9.8 Commit do Dia git add scripts/03_transformacao_viz.R git commit -m &quot;Dia 3: transforma√ß√£o, I/O e visualiza√ß√£o com ggplot2&quot; git push origin main 9.9 Checklist de Encerramento Dominou pivot_longer e pivot_wider Entendeu separate e unite Sabe tratar valores ausentes Consegue ler CSV e Excel Organiza projetos com here() Conhece janitor e skimr Cria gr√°ficos b√°sicos com ggplot2 Personaliza gr√°ficos (temas, cores, labels) Combina gr√°ficos com patchwork Salva gr√°ficos com ggsave() Fez commit no seu fork 9.10 Refer√™ncias R√°pidas ggplot2 cheatsheet: https://posit.co/resources/cheatsheets/ R for Data Science - Data Visualization: https://r4ds.hadley.nz/data-visualize tidyr documentation: https://tidyr.tidyverse.org/ patchwork: https://patchwork.data-imaginist.com/ R Graph Gallery: https://r-graph-gallery.com/ Amanh√£ no Dia 4: Integra√ß√£o do ChatGPT e Claude no RStudio! ü§ñ "],["dia-4-integra√ß√£o-do-chatgpt-e-claude-no-rstudio.html", "10 Dia 4: Integra√ß√£o do ChatGPT e Claude no RStudio 10.1 Conceitos e Modelos (19h00 - 19h30) 10.2 O que s√£o APIs? 10.3 Limites e Custos 10.4 Boas Pr√°ticas de Uso Respons√°vel de IA 10.5 Configura√ß√£o de Chaves e Ambiente (19h30 - 20h15) 10.6 Criando Chaves de API 10.7 Instala√ß√£o de Pacotes 10.8 INTERVALO (20h15 - 20h30) 10.9 RStudio + chattr (20h30 - 21h00)", " 10 Dia 4: Integra√ß√£o do ChatGPT e Claude no RStudio Objetivo do dia Capacitar voc√™ a usar ChatGPT (OpenAI) e Claude (Anthropic) diretamente no RStudio para: Explicar erros e fazer debug do c√≥digo Revisar e refatorar c√≥digo Gerar c√≥digo e fun√ß√µes Criar rascunhos de relat√≥rios e documenta√ß√£o Automatizar tarefas via API Tempo previsto: 19h00‚Äì22h00 (intervalo 20h15‚Äì20h30) 10.0.1 Revis√£o R√°pida dos Dias Anteriores (‚âà 10 min) library(tidyverse) 10.1 Conceitos e Modelos (19h00 - 19h30) 10.1.1 O que s√£o LLMs (Large Language Models)? LLM = Large Language Model (Modelo de Linguagem Grande) O que s√£o: Modelos de intelig√™ncia artificial treinados em volumes massivos de texto Aprendem padr√µes da linguagem, conceitos e rela√ß√µes Capazes de gerar texto, c√≥digo, explica√ß√µes e muito mais Como funcionam (simplificado): Treinamento: Leem bilh√µes de p√°ginas de texto da internet, livros, c√≥digo Aprendizado: Identificam padr√µes - como palavras se relacionam, estruturas de c√≥digo Gera√ß√£o: Preveem a pr√≥xima palavra/token mais prov√°vel dada uma entrada N√£o s√£o: ‚ùå Bancos de dados que ‚Äúbuscam‚Äù respostas ‚ùå Sistemas de busca como Google ‚ùå Calculadoras ou compiladores S√£o: ‚úÖ Sistemas de reconhecimento de padr√µes estat√≠sticos ‚úÖ Geradores de texto coerente baseados em probabilidades ‚úÖ Assistentes que ‚Äúentendem‚Äù contexto 10.1.2 Modelos principais que usaremos 1. ChatGPT (OpenAI) Fam√≠lia GPT-4: gpt-4o: Mais r√°pido e barato, multimodal (texto + imagem) gpt-4o-mini: Ainda mais r√°pido e barato, excelente custo-benef√≠cio gpt-4-turbo: Balanceado entre velocidade e qualidade Pontos fortes: ‚úÖ Explica√ß√µes did√°ticas e passo a passo ‚úÖ Gera√ß√£o r√°pida de c√≥digo ‚úÖ Bom em tarefas criativas ‚úÖ Interface conversacional natural ‚úÖ Mais barato que Claude Quando usar: Explicar conceitos de forma simples Gerar c√≥digo rapidamente (prot√≥tipos) Criar documenta√ß√£o b√°sica Responder d√∫vidas gerais 2. Claude (Anthropic) Fam√≠lia Claude 3: claude-3-5-sonnet-latest: Melhor modelo, mais inteligente claude-3-opus: Mais preciso, melhor para an√°lises complexas claude-3-sonnet: Balanceado claude-3-haiku: Mais r√°pido e barato Pontos fortes: ‚úÖ An√°lise profunda de c√≥digo ‚úÖ Respostas mais longas e detalhadas ‚úÖ Melhor em racioc√≠nio complexo ‚úÖ Mais cuidadoso e preciso ‚úÖ Melhor contexto (200k tokens vs 128k do GPT) Quando usar: Revisar c√≥digo complexo An√°lise e refatora√ß√£o profunda Explica√ß√µes t√©cnicas detalhadas Debugging de problemas dif√≠ceis 10.1.3 Compara√ß√£o pr√°tica Crit√©rio ChatGPT Claude Velocidade Muito r√°pido ‚ö°‚ö°‚ö° R√°pido ‚ö°‚ö° Custo Mais barato üí∞ Mais caro üí∞üí∞ Explica√ß√µes simples Excelente ‚≠ê‚≠ê‚≠ê Muito bom ‚≠ê‚≠ê An√°lise profunda Bom ‚≠ê‚≠ê Excelente ‚≠ê‚≠ê‚≠ê C√≥digo complexo Bom ‚≠ê‚≠ê Excelente ‚≠ê‚≠ê‚≠ê Contexto (tokens) 128k 200k Criatividade Alta ‚≠ê‚≠ê‚≠ê Moderada ‚≠ê‚≠ê Precis√£o t√©cnica Boa ‚≠ê‚≠ê Excelente ‚≠ê‚≠ê‚≠ê 10.2 O que s√£o APIs? API = Application Programming Interface (Interface de Programa√ß√£o de Aplica√ß√µes) Analogia do restaurante: Voc√™ = seu c√≥digo R Cozinha = servidor da OpenAI/Anthropic com o modelo de IA Gar√ßom = API que leva seu pedido e traz a resposta Card√°pio = documenta√ß√£o da API (o que voc√™ pode pedir) Como funciona: Voc√™ faz uma requisi√ß√£o (pergunta) &quot;Explique o que este c√≥digo faz: x &lt;- mean(1:10)&quot; API envia para o modelo de IA Viaja pela internet at√© os servidores Processa sua pergunta Modelo gera resposta Analisa contexto Gera texto/c√≥digo API retorna resposta &quot;Este c√≥digo calcula a m√©dia dos n√∫meros de 1 a 10...&quot; Componentes de uma API: Endpoint: URL para onde enviar requisi√ß√µes OpenAI: https://api.openai.com/v1/chat/completions Anthropic: https://api.anthropic.com/v1/messages M√©todo HTTP: Como enviar (GET, POST, etc.) Usaremos POST (enviar dados) Headers: Informa√ß√µes sobre a requisi√ß√£o Authorization: sua chave API Content-Type: formato dos dados (JSON) Body: Os dados da requisi√ß√£o Modelo a usar Sua pergunta/prompt Par√¢metros (temperatura, max_tokens, etc.) Response: A resposta do servidor Conte√∫do gerado Metadados (tokens usados, etc.) 10.3 Limites e Custos 10.3.1 Custos por modelo OpenAI (GPT-4o-mini) - mais barato: - Input: $0.150 / 1M tokens (~750k palavras) - Output: $0.600 / 1M tokens Exemplo pr√°tico: - 1 conversa t√≠pica = ~1000 tokens = $0.0015 (menos de 1 centavo!) - 1000 conversas = ~$1.50 Anthropic (Claude 3.5 Sonnet) - mais caro mas melhor: - Input: $3.00 / 1M tokens - Output: $15.00 / 1M tokens Exemplo pr√°tico: - 1 conversa t√≠pica = ~1000 tokens = $0.03 (3 centavos) - 1000 conversas = ~$30 O que √© um token? - Token ‚âà 0.75 palavras em ingl√™s - Token ‚âà 0.5 palavras em portugu√™s (devido aos acentos) - ‚ÄúOl√°, como voc√™ est√°?‚Äù ‚âà 7-8 tokens 10.3.2 Rate Limits (Limites de taxa) Por que existem: - Prevenir abuso e spam - Garantir disponibilidade para todos - Controlar custos Limites t√≠picos (conta gratuita/tier 1): OpenAI: - ~10,000 tokens/minuto - ~3 requisi√ß√µes/minuto (com GPT-4) - ~200 requisi√ß√µes/dia Anthropic: - ~10,000 tokens/minuto - ~5 requisi√ß√µes/minuto - ~1000 requisi√ß√µes/dia O que acontece se exceder: - Erro HTTP 429: ‚ÄúToo Many Requests‚Äù - Precisa esperar (geralmente 1 minuto) Como evitar: - N√£o fa√ßa loops r√°pidos com chamadas √† API - Implemente delays entre requisi√ß√µes - Use um modelo mais barato para testes 10.4 Boas Pr√°ticas de Uso Respons√°vel de IA 10.4.1 Privacidade e Dados Sens√≠veis ‚ö†Ô∏è NUNCA envie para APIs de IA: ‚ùå Senhas ou credenciais ‚ùå Dados pessoais identific√°veis (CPF, RG, etc.) ‚ùå Informa√ß√µes m√©dicas ou financeiras privadas ‚ùå Dados propriet√°rios ou confidenciais da empresa ‚ùå C√≥digo com chaves de API ou tokens O que √© seguro enviar: ‚úÖ C√≥digo gen√©rico e exemplos ‚úÖ Dados p√∫blicos ou sint√©ticos ‚úÖ Perguntas conceituais ‚úÖ Erros e stacktraces (sem informa√ß√£o sens√≠vel) Lembre-se: Tudo que voc√™ envia pode ser usado para treinar modelos futuros! 10.4.2 Versionamento de C√≥digo Gerado por IA Por que versionar: Transpar√™ncia sobre origem do c√≥digo Rastreabilidade de mudan√ßas Facilita debugging futuro √âtica e honestidade acad√™mica/profissional Como fazer: # Bom: documenta que IA gerou # Esta fun√ß√£o foi gerada por ChatGPT em 2024-11-25 # Prompt: &quot;Crie fun√ß√£o para calcular z-score&quot; zscore &lt;- function(x) { (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE) } # Commits descritivos git commit -m &quot;feat: adiciona fun√ß√£o zscore (gerada com ChatGPT)&quot; 10.4.3 Valida√ß√£o e Teste ‚ö†Ô∏è CR√çTICO: NUNCA use c√≥digo de IA sem entender e testar! Processo recomendado: Entenda o c√≥digo gerado Leia linha por linha Pergunte √† IA se n√£o entender algo Pesquise fun√ß√µes desconhecidas Teste extensivamente # Sempre teste casos extremos zscore(c(1, 2, 3)) # Normal zscore(c(1, 1, 1)) # Todos iguais (sd = 0?) zscore(c(1, NA, 3)) # Com NA zscore(numeric(0)) # Vetor vazio Valide resultados Compare com m√©todos conhecidos Verifique casos conhecidos Use diferentes inputs Refatore se necess√°rio Melhore legibilidade Adicione valida√ß√µes Otimize performance 10.4.4 Uso √âtico Fa√ßa: - ‚úÖ Use IA como assistente, n√£o substituto do aprendizado - ‚úÖ Entenda o que a IA est√° fazendo - ‚úÖ Cite quando c√≥digo foi gerado por IA (contextos acad√™micos) - ‚úÖ Revise e melhore c√≥digo gerado - ‚úÖ Use para aprender conceitos novos N√£o fa√ßa: - ‚ùå Submeta c√≥digo de IA sem entender (em trabalhos/provas) - ‚ùå Confie cegamente nas respostas - ‚ùå Use como substituto de documenta√ß√£o oficial - ‚ùå Compartilhe chaves de API - ‚ùå Use para gerar trabalhos acad√™micos inteiros sem transpar√™ncia 10.5 Configura√ß√£o de Chaves e Ambiente (19h30 - 20h15) 10.5.1 Vari√°veis de Ambiente no R O que s√£o vari√°veis de ambiente? Vari√°veis de ambiente s√£o configura√ß√µes que ficam armazenadas fora do seu c√≥digo, dispon√≠veis para todos os programas no seu sistema operacional. Por que usar para chaves de API? Seguran√ßa: ‚úÖ Chaves n√£o ficam no c√≥digo (evita commit acidental para GitHub) ‚úÖ Diferentes chaves para diferentes ambientes (dev, prod) ‚úÖ F√°cil rota√ß√£o de chaves sem mudar c√≥digo Como funcionam no R: # Ler vari√°vel de ambiente Sys.getenv(&quot;NOME_DA_VARIAVEL&quot;) # Definir vari√°vel (apenas na sess√£o atual) Sys.setenv(NOME_DA_VARIAVEL = &quot;valor&quot;) # Listar todas Sys.getenv() 10.5.2 O arquivo .Renviron O que √© .Renviron: Arquivo de texto simples que define vari√°veis de ambiente Carregado automaticamente quando R inicia Localiza√ß√£o: diret√≥rio home do usu√°rio (~/.Renviron) Vantagens: Vari√°veis persistem entre sess√µes N√£o precisa redefinir toda vez F√°cil de gerenciar Como criar/editar: # Abrir .Renviron no RStudio (cria se n√£o existir) usethis::edit_r_environ() # Ou manualmente encontrar localiza√ß√£o path.expand(&quot;~/.Renviron&quot;) Formato do arquivo: # Arquivo .Renviron # Linhas come√ßando com # s√£o coment√°rios # Formato: VARIAVEL=valor (SEM espa√ßos ao redor do =) OPENAI_API_KEY=XXXXXX ANTHROPIC_API_KEY=XXXXX # ERRADO (com espa√ßos): # VARIAVEL = valor # CERTO (sem espa√ßos): # VARIAVEL=valor Depois de editar: Salve o arquivo Reinicie o R: Session ‚Üí Restart R ou .rs.restartR() Teste: Sys.getenv(\"OPENAI_API_KEY\") 10.6 Criando Chaves de API 10.6.1 OpenAI (ChatGPT) Passo 1: Criar conta Acesse https://platform.openai.com/ Crie uma conta ou Login Verifique email Passo 2: Adicionar m√©todo de pagamento Quickstart Adicione m√©todo de pagamento Importante: Configure um limite de gastos! Recomendado: $5-10/m√™s para aprendizado Evita surpresas na fatura Passo 3: Criar API Key Settings ‚Üí API Keys Create new secret key D√™ um nome descritivo: ‚ÄúRStudio - Curso R‚Äù ‚ö†Ô∏è COPIE A CHAVE AGORA! (s√≥ aparece uma vez) Formato: sk-proj-... Guarde em local seguro temporariamente Passo 4: Configurar no R usethis::edit_r_environ() # Adicione: OPENAI_API_KEY=sk-proj-SUA_CHAVE_AQUI # Salve e reinicie R Passo 5: Testar Sys.getenv(&quot;OPENAI_API_KEY&quot;) # Deve mostrar: &quot;sk-proj-...&quot; 10.6.2 Anthropic (Claude) Passo 1: Criar conta Acesse https://console.anthropic.com/ Crie uma conta ou Login Verifique email Passo 2: Obter cr√©ditos Contas novas ganham alguns cr√©ditos gratuitos ($5-10) Depois precisa adicionar m√©todo de pagamento Passo 3: Criar API Key Settings ‚Üí API Keys Create Key Nome: ‚ÄúRStudio - Curso R‚Äù ‚ö†Ô∏è COPIE A CHAVE! (s√≥ aparece uma vez) Formato: sk-ant-... Passo 4: Configurar no R usethis::edit_r_environ() # Adicione: ANTHROPIC_API_KEY= # Salve e reinicie R Passo 5: Testar Sys.getenv(&quot;ANTHROPIC_API_KEY&quot;) # Deve mostrar: &quot;sk-ant-...&quot; 10.7 Instala√ß√£o de Pacotes # Pacotes necess√°rios install.packages(c( &quot;gptstudio&quot;, # Interface para ChatGPT no RStudio &quot;chattr&quot;, # Interface para m√∫ltiplos LLMs &quot;httr2&quot;, # Cliente HTTP moderno (para APIs) &quot;jsonlite&quot;, # Trabalhar com JSON &quot;shiny&quot;, &quot;ellmer&quot; )) # Verificar instala√ß√£o library(gptstudio) library(chattr) library(httr2) library(jsonlite) library(shiny) library(tidyverse) library(ellmer) 10.7.1 O que cada pacote faz gptstudio: Addins no RStudio para ChatGPT Chat panel integrado Sele√ß√£o de c√≥digo + an√°lise Gera√ß√£o de documenta√ß√£o Corre√ß√£o de erros chattr: Interface unificada para m√∫ltiplos LLMs Suporta OpenAI, Anthropic, Google, outros Chat interativo no console Configura√ß√£o flex√≠vel de modelos httr2: Cliente HTTP moderno para R Fazer requisi√ß√µes para APIs Melhor que httr (vers√£o anterior) Pipe-friendly (|&gt;) jsonlite: Converter entre R e JSON APIs usam JSON para comunica√ß√£o Parse de respostas JSON 10.8 INTERVALO (20h15 - 20h30) Aproveite para: Verificar se suas chaves est√£o configuradas Instalar os pacotes Tomar √°gua/caf√©! 10.9 RStudio + chattr (20h30 - 21h00) 10.9.1 Conhecendo o chattr chattr adiciona superpoderes de IA ao RStudio atrav√©s de Addins. Recursos principais: ChatGPT Chat: Painel de chat lateral Comment Code: Adiciona coment√°rios ao c√≥digo Explain Code: Explica c√≥digo selecionado Write Code: Gera c√≥digo a partir de descri√ß√£o Edit Code: Refatora/melhora c√≥digo 10.9.2 Acessando os Addins Menu: Addins ‚Üí chattr ‚Üí ... Atalhos de teclado (configur√°veis): Tools ‚Üí Modify Keyboard Shortcuts Busque ‚Äúchattr‚Äù Configure atalhos personalizados 10.9.3 Definindo o modelo de IA para ser utilizado Modelos dispon√≠veis no ChatGPT (OpenAI) models_openai() Modelos dispon√≠veis no Claude (Anthropic). models_anthropic() Escolhendo o modelo para uso: my_chat &lt;- ellmer::chat_anthropic() my_chat &lt;- ellmer::chat_anthropic(model = &#39;claude-opus-4-1-20250805&#39;) my_chat &lt;- ellmer::chat_openai() my_chat &lt;- ellmer::chat_openai(model = &#39;gpt-5.1-codex-mini&#39;) Depois do modelo escolhido, defina ele como padr√£o para ser utilizado no chattr. chattr_use(my_chat) 10.9.4 Chat Integrado Como abrir: chattr_app(as_job = TRUE) Interface do Chat: Painel lateral direito Campo de input na parte inferior Hist√≥rico de conversa acima Bot√µes para copiar/limpar Uso b√°sico: # Criar um vetor num√©rico em R chattr(&quot;Como criar um vetor em R?&quot;) # Explicar conceitos chattr(&quot;O que √© um data.frame?&quot;) # Gerar c√≥digo chattr(&quot;Crie uma fun√ß√£o que calcule m√©dia e desvio padr√£o&quot;) # Debugging chattr(&quot;Por que este c√≥digo d√° erro: mean(NA)&quot;) Dicas para bons prompts: Seja espec√≠fico D√™ contexto quando necess√°rio Pe√ßa explica√ß√µes passo a passo Solicite exemplos 10.9.5 Explicar C√≥digo Selecionado Exemplo: # Selecione este c√≥digo e pe√ßa explica√ß√£o dados %&gt;% filter(!is.na(valor)) %&gt;% group_by(categoria) %&gt;% summarize( n = n(), media = mean(valor), dp = sd(valor) ) %&gt;% arrange(desc(media)) chattr(&quot;Explique este codigo: dados %&gt;% filter(!is.na(valor)) %&gt;% group_by(categoria) %&gt;% summarize( n = n(), media = mean(valor), dp = sd(valor) ) %&gt;% arrange(desc(media))&quot;) O que o LLM explica: O que cada linha faz Ordem de execu√ß√£o Fun√ß√µes usadas Resultado esperado 10.9.6 Casos de Uso Pr√°ticos 10.9.6.1 Caso 1: Explicar um erro # C√≥digo com erro dados &lt;- data.frame(x = 1:5, y = c(2, 4, NA, 8, 10)) mean(dados$y) # Retorna NA # Prompt para ChatGPT: chattr(&quot;Por que mean(dados$y) retorna NA? Como corrigir?&quot;) 10.9.6.2 Caso 2: Refatorar fun√ß√£o # Fun√ß√£o verbosa calcular &lt;- function(x, y) { resultado1 &lt;- x + y resultado2 &lt;- x * y resultado3 &lt;- x / y output &lt;- list() output$soma &lt;- resultado1 output$produto &lt;- resultado2 output$divisao &lt;- resultado3 return(output) } # Prompt: # Armazene o c√≥digo em uma vari√°vel primeiro codigo &lt;- &#39;calcular &lt;- function(x, y) {{ resultado1 &lt;- x + y resultado2 &lt;- x * y resultado3 &lt;- x / y output &lt;- list() output$soma &lt;- resultado1 output$produto &lt;- resultado2 output$divisao &lt;- resultado3 return(output) }}&#39; chattr(paste(&quot;Refatore esta fun√ß√£o para ser mais concisa e clara:\\n\\n&quot;, codigo)) 10.9.6.3 Caso 3: Gerar testes unit√°rios # Sua fun√ß√£o codigo &lt;- &quot;zscore &lt;- function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)&quot; # Prompt: chattr( paste(&quot;Gere 3 testes unit√°rios simples para validar esta fun√ß√£o zscore:&quot;,codigo)) 10.9.7 Chat Program√°tico # Fazer pergunta diretamente resposta &lt;- chattr(&quot;Como calcular m√©dia em R?&quot;) cat(resposta) # Com contexto/c√≥digo codigo &lt;- &quot; dados &lt;- data.frame(x = 1:5, y = c(2, 4, NA, 8, 10)) mean(dados$y) &quot; resposta &lt;- chattr(paste0( &quot;Explique o que acontece neste c√≥digo:\\n&quot;, codigo )) cat(resposta) # Salvar hist√≥rico historico &lt;- chattr_history() print(historico) 10.9.7.1 Caso 1: An√°lise profunda de c√≥digo pipeline_complexo &lt;- &quot;library(tidyverse) resultado &lt;- mtcars %&gt;% mutate( eficiencia = mpg / wt, categoria_cyl = case_when( cyl &lt;= 4 ~ &#39;Pequeno&#39;, cyl &lt;= 6 ~ &#39;M√©dio&#39;, TRUE ~ &#39;Grande&#39; ) ) %&gt;% group_by(categoria_cyl, gear) %&gt;% summarize( n = n(), media_ef = mean(eficiencia), dp_ef = sd(eficiencia), .groups = &#39;drop&#39; ) %&gt;% filter(n &gt;= 3) %&gt;% arrange(desc(media_ef))&quot; chattr(paste0(&quot;Faca uma analise profunda desse codigo:&quot;, pipeline_complexo)) "],["prompt.html", "11 Prompt: 11.1 Exerc√≠cio Guiado de Integra√ß√£o (21h30 - 22h00) 11.2 Checklist Final 11.3 Recursos Adicionais 11.4 Troubleshooting 11.5 Problemas de conex√£o 11.6 Dicas Finais", " 11 Prompt: ‚ÄúAnalise este pipeline tidyverse em detalhes: O que cada etapa faz? H√° potenciais problemas ou melhorias? O c√≥digo est√° otimizado? Claude fornece an√°lise profunda: Explica√ß√£o linha por linha Identifica√ß√£o de poss√≠veis NAs n√£o tratados Sugest√µes de otimiza√ß√£o Alertas sobre edge cases 11.0.0.1 Caso 2: Gerar uma nova fun√ß√£o # Prompt para Claude: prompt &lt;- &quot;Crie uma fun√ß√£o em R que: 1. Receba um data.frame e nome de coluna num√©rica 2. Remova NAs 3. Retorne lista com m√©dia e desvio padr√£o 4. Inclua valida√ß√µes de tipo e mensagens de erro claras 5. Documente com coment√°rios&quot; chattr(prompt) 11.0.0.2 Caso 3: Explicar traceback complexo # Erro complexo erro &lt;- &quot; Error in mutate(., nova_col = antiga_col * 2) : ‚Ñπ In argument: `nova_col = antiga_col * 2`. Caused by error: ! object &#39;antiga_col&#39; not found Run `rlang::last_trace()` to see where the error occurred. &quot; chattr(erro) 11.1 Exerc√≠cio Guiado de Integra√ß√£o (21h30 - 22h00) 11.1.1 Tarefa 1: Revisar c√≥digo com chattr Objetivo: Usar IA para revisar um script tidyverse e propor melhorias. C√≥digo para revisar: library(tidyverse) library(palmerpenguins) # An√°lise de pinguins dados &lt;- penguins dados &lt;- dados %&gt;% filter(!is.na(bill_length_mm)) dados &lt;- dados %&gt;% filter(!is.na(bill_depth_mm)) dados &lt;- dados %&gt;% filter(!is.na(flipper_length_mm)) dados &lt;- dados %&gt;% filter(!is.na(body_mass_g)) resultado &lt;- dados %&gt;% mutate(bill_ratio = bill_length_mm / bill_depth_mm) %&gt;% group_by(species) %&gt;% summarize( n = n(), bill_ratio_mean = mean(bill_ratio), bill_ratio_sd = sd(bill_ratio), mass_mean = mean(body_mass_g), mass_sd = sd(body_mass_g) ) print(resultado) # # Seus codigos aqui Passos: Selecione todo o c√≥digo Use chattr ‚Üí Explain Code Depois use chattr ‚Üí Write Code com prompt: ‚ÄúSugira 2 melhorias para este c√≥digo‚Äù 11.1.2 Tarefa 2: Gerar fun√ß√£o com chattr (Claude) Objetivo: Usar LLM para gerar um arquivo de dados. # # Criar um data.frame que contem dados de um experimento com dois tratamentos # em DIC em bovinos leitiros para avaliar se existe diferen√ßa estatistica na # producao de leite de vacas alimentadas com duas dietas diferentes. prompt &lt;- &quot;Criar um data.frame que contem dados de um experimento com dois tratamentos em DIC em bovinos leitiros para avaliar se existe diferen√ßa estatistica na producao de leite de vacas alimentadas com duas dietas diferentes.&quot; chattr(prompt) 11.1.3 Tarefa 3: Criar um gr√°fico utilizando o ggplot2. Objetivo: Usar LLM para automatizar o processo prompt &lt;- &#39;Crie um gr√°fico boxplot utilizando o ggplot a partir de dados simulados de pesos ao nascimento de bovinos de corte&#39; chattr(prompt) 11.1.4 Compara√ß√£o ChatGPT vs Claude ChatGPT: Velocidade: [sua observa√ß√£o] Qualidade: [sua observa√ß√£o] Melhor para: [sua conclus√£o] Claude: Velocidade: [sua observa√ß√£o] Qualidade: [sua observa√ß√£o] Melhor para: [sua conclus√£o] 11.1.5 Reflex√£o Final [Escreva um par√°grafo sobre como voc√™ pretende usar IA no seu trabalho com R] 11.2 Checklist Final Antes de fazer o commit final, verifique: .Renviron configurado com ambas as chaves Sys.getenv(&quot;OPENAI_API_KEY&quot;) # Deve mostrar sk-proj-... Sys.getenv(&quot;ANTHROPIC_API_KEY&quot;) # Deve mostrar sk-ant-... Pacotes instalados library(gptstudio) library(chattr) library(httr2) library(jsonlite) Addins do gptstudio funcionando Addins ‚Üí GPTSTUDIO ‚Üí ChatGPT Chat abre? Chamada m√≠nima via httr2 para cada API funciona # Teste ChatGPT (simplificado) req &lt;- request(&quot;https://api.openai.com/v1/chat/completions&quot;) |&gt; req_method(&quot;POST&quot;) |&gt; req_headers(Authorization = paste(&quot;Bearer&quot;, Sys.getenv(&quot;OPENAI_API_KEY&quot;))) |&gt; req_body_json(list( model = &quot;gpt-4o-mini&quot;, messages = list(list(role = &quot;user&quot;, content = &quot;Diga ol√°&quot;)) )) resp &lt;- req_perform(req) resp_body_json(resp)$choices[[1]]$message$content # Teste Claude (simplificado) req &lt;- request(&quot;https://api.anthropic.com/v1/messages&quot;) |&gt; req_method(&quot;POST&quot;) |&gt; req_headers( Authorization = paste(&quot;Bearer&quot;, Sys.getenv(&quot;ANTHROPIC_API_KEY&quot;)), &quot;anthropic-version&quot; = &quot;2023-06-01&quot;, &quot;content-type&quot; = &quot;application/json&quot; ) |&gt; req_body_json(list( model = &quot;claude-3-5-sonnet-latest&quot;, max_tokens = 100, messages = list(list(role = &quot;user&quot;, content = &quot;Diga ol√°&quot;)) )) resp &lt;- req_perform(req) resp_body_json(resp)$content[[1]]$text Arquivos criados: scripts/04_ia_integracao_gptstudio.R scripts/04_ia_integracao_claude.R docs/relatorio_ia.Rmd 11.2.1 Commit e Push # Adicionar arquivos git add scripts/04_*.R docs/relatorio_ia.Rmd # Commit descritivo git commit -m &quot;feat: integra√ß√£o ChatGPT e Claude no RStudio (Dia 4) - Configura APIs OpenAI e Anthropic - Implementa revis√£o de c√≥digo com gptstudio - Gera fun√ß√£o robusta com Claude - Documenta processo e aprendizados&quot; # Push para seu fork git push origin main IMPORTANTE: N√ÉO fa√ßa commit do arquivo .Renviron com suas chaves! 11.3 Recursos Adicionais 11.3.1 Documenta√ß√£o Oficial OpenAI: - API Reference: https://platform.openai.com/docs/api-reference - Pricing: https://openai.com/pricing - Best Practices: https://platform.openai.com/docs/guides/prompt-engineering Anthropic: - API Reference: https://docs.anthropic.com/claude/reference - Pricing: https://www.anthropic.com/pricing - Prompt Engineering: https://docs.anthropic.com/claude/docs/intro-to-prompting Pacotes R: - gptstudio: https://github.com/MichelNivard/gptstudio - chattr: https://mlverse.github.io/chattr/ - httr2: https://httr2.r-lib.org/ 11.3.2 Tutoriais e Cursos Prompt Engineering Guide: https://www.promptingguide.ai/ Learn Prompting: https://learnprompting.org/ OpenAI Cookbook: https://cookbook.openai.com/ 11.3.3 Comunidades r/ChatGPT: https://reddit.com/r/ChatGPT r/ClaudeAI: https://reddit.com/r/ClaudeAI RStudio Community: https://community.rstudio.com/ 11.4 Troubleshooting 11.4.1 Erro: API Key inv√°lida Error: 401 Unauthorized Causas: - Chave copiada errada - Chave expirada - Chave n√£o configurada corretamente Solu√ß√µes: 1. Verifique: Sys.getenv(\"OPENAI_API_KEY\") 2. Recrie chave no dashboard 3. Edite .Renviron: usethis::edit_r_environ() 4. Reinicie R 11.4.2 Erro: Rate Limit excedido Error: 429 Too Many Requests Causa: Muitas requisi√ß√µes em pouco tempo Solu√ß√£o: - Espere 1 minuto - Reduza frequ√™ncia de chamadas - Use modelo mais barato para testes 11.4.3 Erro: Insufficient credits Error: 402 Payment Required Causa: Cr√©ditos/limite de gastos esgotado Solu√ß√£o: - Adicione cr√©ditos (OpenAI/Anthropic dashboard) - Configure limite de gastos - Verifique m√©todo de pagamento 11.4.4 gptstudio n√£o aparece nos Addins Solu√ß√µes: 1. Reinstale: install.packages(\"gptstudio\") 2. Reinicie RStudio 3. Verifique se instalou corretamente: library(gptstudio) 11.5 Problemas de conex√£o Error: Could not resolve host Solu√ß√µes: - Verifique conex√£o com internet - Teste: ping api.openai.com - Desative VPN se houver - Configure proxy se necess√°rio 11.6 Dicas Finais 11.6.1 Prompts Eficazes Seja espec√≠fico: ‚ùå ‚ÄúMelhore este c√≥digo‚Äù ‚úÖ ‚ÄúRefatore este c√≥digo para usar tidyverse em vez de loops for‚Äù D√™ contexto: ‚ùå ‚ÄúComo fazer isso?‚Äù ‚úÖ ‚ÄúTenho um data.frame com colunas x, y, z. Como filtrar linhas onde x &gt; 10 e calcular m√©dia de y por z?‚Äù Pe√ßa passo a passo: ‚úÖ ‚ÄúExplique passo a passo como criar um gr√°fico ggplot2 com facetas‚Äù Solicite valida√ß√µes: ‚úÖ ‚ÄúGere esta fun√ß√£o e inclua valida√ß√£o de inputs e tratamento de erros‚Äù 11.6.2 Itera√ß√£o com IA Primeira tentativa: Prompt simples Refinar: Se n√£o satisfat√≥rio, refine o prompt Especificar: Adicione detalhes que faltaram Validar: Sempre teste o c√≥digo gerado Iterar: Pe√ßa ajustes espec√≠ficos 11.6.3 Quando N√ÉO usar IA ‚ùå C√≥digo com dados sens√≠veis/confidenciais ‚ùå Decis√µes cr√≠ticas sem valida√ß√£o ‚ùå Substituir documenta√ß√£o oficial ‚ùå Aprendizado de conceitos fundamentais (use IA como complemento, n√£o substituto) 11.6.4 Quando SIM usar IA ‚úÖ Entender erros complexos ‚úÖ Gerar boilerplate code ‚úÖ Refatorar c√≥digo existente ‚úÖ Criar testes ‚úÖ Documentar c√≥digo ‚úÖ Aprender novas fun√ß√µes/pacotes ‚úÖ Brainstorming de solu√ß√µes "],["conclus√£o-do-curso.html", "12 Conclus√£o do Curso 12.1 O que voc√™ aprendeu: 12.2 Pr√≥ximos passos:", " 12 Conclus√£o do Curso üéâ Parab√©ns! Voc√™ completou o curso de R com GitHub e IA! 12.1 O que voc√™ aprendeu: Dia 1: - Fundamentos de R (vetores, data.frames, fatores) - Git e GitHub - Workflow com fork - Organiza√ß√£o de projetos Dia 2: - Operadores e condicionais - Fun√ß√µes personalizadas - Tidyverse e dplyr - Manipula√ß√£o de datas Dia 3: - Transforma√ß√£o com tidyr - Tratamento de NAs - I/O de dados - Visualiza√ß√£o com ggplot2 Dia 4: - Integra√ß√£o de IA no workflow - APIs OpenAI e Anthropic - Pacote chattr - Uso respons√°vel de IA 12.2 Pr√≥ximos passos: Pratique regularmente - Consist√™ncia &gt; Intensidade Trabalhe em projetos reais - Aplique em seus dados Participe da comunidade R - Twitter, Reddit, RStudio Community Continue aprendendo: R for Data Science: https://r4ds.hadley.nz/ Advanced R: https://adv-r.hadley.nz/ TidyTuesday: https://github.com/rfordatascience/tidytuesday Use IA como assistente - Mas sempre entenda o c√≥digo! Obrigado por participar! Mantenha contato: - Email: junqueiravinicius@hotmail.com - GitHub: https://github.com/viniciusjunqueira/curso-r-github-ia - LinkedIn: linkedin.com/in/junqueiravinicius Bons c√≥digos e boas an√°lises! üöÄüìä "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
